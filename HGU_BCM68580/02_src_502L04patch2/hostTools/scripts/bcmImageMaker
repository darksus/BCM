#!/usr/bin/env perl

use strict;
use warnings;
use bytes;

use Getopt::Long;

my $cferom;
my $cfesecrom;
my $precferom;
my $pmcrom;
my $pmcflag;
my $blocksize;
my $rootfs;
my $bootfs;
my $image;
my $verbose;
my $flashtype;
my $fsonly;
my $ubifs;
my $squbifs;
my $bootofs;
my $bootsize;
my $bootofsinkb;
my $bootsizeinkb;
my $blocksizeinkb;
my $securehdr;
my $mediatype;
my $unsecurehdr;
my $secbtdatadir;
my $secbtldr;
my $btrmflag;
my $ubionlyimage;
my $storedir;
my $romenc;
my $usefldoem;
my $imgsizealloc;
my $nvramalloc;


sub add_nvram_mirror {
	my $fname=shift;
	my $blk_size=shift;
	my $added=0;


	my $Tdev,my $Tino,my $Tmode,my $Tnlink,my $Tuid,my $Tgid,my $Trdev,my $offset,my $Tatime,my $Tmtime,my $Tctime,my $Tblksize,my $Tblocks;

	($Tdev,$Tino,$Tmode,$Tnlink,$Tuid,$Tgid,$Trdev,$offset,$Tatime,$Tmtime,$Tctime,$Tblksize,$Tblocks)
		= stat($fname);


	my $init_byte="\377";
	my $d=0;
	if( int(($offset + 2048)/$blk_size) > int($offset/$blk_size))
	{
		$d=($blk_size - ($offset%$blk_size));
		print("Crossing the block boundry, adding buffer $d\n");
	}
	elsif ($offset%2048 != 0)
	{
		$d=(2048-($offset%2048));
		print("Aligning to 2048 page, adding buffer $d\n");
	}
	my $b=$init_byte x $d;
	$offset=$offset+$d;
	if(open(Fd, ">>$fname"))
	{
		print Fd $b;
		print Fd "nVrAmDaTaSiGnAtUrE";
		print Fd ($init_byte x (2048-18));
		close(Fd);
	}
return $added;
	
}

=pod
=explaination of the patch 
 When and address is sent out (e.g ABCDEF) Last 2 nibbles are ignored and 
 only next 3 nibbles are sent on wire So ABCDEF becomes BCD.
 During bootrom development, this issue was not discovered, and we do direct address access for
 a structure.
 to work around this issue we have to create a fake header before the actual CFEROM and add
 copy the contents of the structure from real CFE header to the BCD offset.
 now the total cache is only 2K, so BCD cannpt exceed 0x400

Additional information from email exchange -
   
The patch to the flash image is based on the fact that the SPI controller still send out the SPI READ cmd(0x3) with the full 3 byte address to device when we do the XIP access from  btrm.  The btrm first check the magic number using the SPI NAND function at 1KB boundary. This mean the whole 2K page is loaded to device cache using the PAGE READ cmd.  The subsequent read of the image header length using XIP will actually succeed but map to a different address in the same page. 
 
The SPI NOR read uses 3 byte address[23:0] which our chip does the same for XIP.  But for SPI NAND read, it is the same read cmd(0x3) but it only uses 12 bit column address in the middle. The first 4 MSB bits are dummy bits(some vendors use for wrap, plane selection option) and the 8 LSB bits are dummy bits(except the gigadevice rev C device) so only address[19:8] is actually used as the offset the 2KB page cache to read the data back in XIP case.   In our test case we build our image at 68KB offset the XIP access addr pUnAuthHdr->hdrLen is 0xffd11010. The address send to the SPI NAND is 0x11010 and the SPI NAND drop the 8 bit dummy LSB and return the value at 0x110 in that page.  The data we interested in at 0x10 offset so we are reading 0x120 for the value of hdrLen and 0x130 for the value of pAuthHdr->hdrLen. 
 
But these locations are the in cfe rom code. In order to preserve the CFE rom code, we will insert 1KB dummy data at the beginning of page boundary for patching and the SBI image starts at 1KB offset in the same page. This way the patch wont touch any cfe rom code.   But this also means that we can only have image up to 256KB bytes or to be precise, (1KB-0x20)*256= 248KB.  If we preserve the first 64KB and our cfe rom is about 80KB now so we can only have two images with this workaround. 
 
To calculate the exact location for patching and data content:
1.  Assuming the SBI image address is sbiAddr after 1KB zero padding in the front,  sbiPageAddr = sbiAddr  0x400 and patchBase = (sbiAddr>>8)+ sbiPageAddr;
2. If patchBase+0x20 > 0x400, stop.
3.  Set patchBase+0x10 to pUnAuthHdr->hdrLen
4.  Set patchBase+0x14 to pUnAuthHdr->sbiSize
5.  Set patchBase+0x20 to pAuthHdr->hdrLen
6. Repeat for next sbi image.

=end explaination
=cut

sub read_file {
   my $file_to_read=$_[0];
   my $input_data="";
   if(open(sFileba, "<$file_to_read"))
   {
      binmode sFileba;
      local $/ = undef;
      $input_data=<sFileba>;
      close(sFileba);
   }
   return $input_data;
}

#@src1, target
sub concat_file{

    my @srcfiles=@{$_[0]};
    my $target_file_to_append=$_[1];

    open(tFileba, ">$target_file_to_append");
    binmode tFileba;
    my $input_data="";
    my $i=0;

    foreach(@srcfiles)
    {
       $input_data=read_file($_);
       print tFileba $input_data;
       $i=$i+1;
    }
    close(tFileba);
}

sub concat_with_expand{

    my $destfile=$_[0];
    my @srcfiles=@{$_[1]};
    my $expand_to_size=$_[2];

    open(tFileba, ">>$destfile");
    binmode tFileba;

    foreach(@srcfiles)
    {
        my $input_data=read_file($_);
        print tFileba $input_data;
    }
    if($expand_to_size-tell(tFileba) >= 0)
    {
        $expand_to_size=$expand_to_size-tell(tFileba);
        my $zero="\000"x$expand_to_size;
        print tFileba $zero;
    }
    else
    {
        truncate tFileba, $expand_to_size;
    }
    close(tFileba);

}

sub create_spi_nand_patch {

my $offset=shift;
my $bindata;
my $cfe_headered_file_name=shift;
my $init_byte=shift;

if (!$init_byte)
{
	$init_byte="\377";
}

	open CHFN, "<$cfe_headered_file_name" or die "Error opening $cfe_headered_file_name";
	binmode CHFN;

	read(CHFN, $bindata, 1024, 0);

	close (CHFN);

	my $b="";
	if ($offset%4096 != 0)
	{
		my $d=4096-($offset%4096);
		$b=$init_byte x $d;
		$offset= $offset+$d;
	}

	my $real_offset=$offset+0x400;
	my $patch_base=(($real_offset&0xfffff)>>8);

	if(($patch_base + 0x20) > 0x400) {
		return $init_byte x 1024;
	}

	( my $magic_1, my $magic_2, my $ver, my $modeElegible, my $hdrLen, my $sbiSize, my $Ver, my $crc, my $authhdrLen) = unpack("IIIIIIIII", $bindata);

	$patch_base=$patch_base+0x10;
	my $binary=$init_byte x $patch_base;
	$binary=$binary.pack('I', $hdrLen);
	$binary=$binary.pack('I', $sbiSize);
	$binary=$binary.pack('II', 0xffffffff, 0xffffffff);
	$binary=$binary.pack('I', $authhdrLen);
	$binary=$binary.$init_byte x (0x400-($patch_base+4+16));

return $b.$binary;

}

sub create_secure_enabled_image {
	#arguments
	my $bootsize=$_[9];#9
	my $bootofs=$_[8];#8
	my $nvramalloc=$_[7];#7
	my $imgsizealloc=$_[6]; #6
	my $intrm_image=$_[5]; #5
	my $storedir=$_[4]; #4
	my $secbtldr=$_[3]; #3
	my $cferom=$_[2]; #2
	my $mediatype=$_[1]; #1
	my $securehdr=$_[0]; #0

	#local vars
	my $secopt = "skp_no spu_no";

	my $i;
        my $j;

	# hwa - hardware acceleration;
	if ($securehdr eq "hwa_skp") { 
		$secopt="skp_yes spu_no";
	} else { 
		if ($securehdr eq "hwa_skp_spu") {
			$secopt="skp_yes spu_yes";
		} 
	}

	# Gen3 secure boot. Cferom within secure,headered image might be in the clear or AES encrypted (2 times with two different keys)
	if ($ENV{SECURE_BOOT_ENCRYPT_BTLDRS} eq "y") {
                print "Packaging gen3 secure boot in which the cfe rom is encrypted. This image expects the bootrom to run ...\n";
                # We know we need a mfg-only secure, headered cferom that is encrypted with Kaes-mfg, so build it
		# This is a mfg-secure only image, so it doesn't matter what the oem_fld setting is ... just set it to no
		e("$ENV{HOSTTOOLS_DIR}/SecureBootUtils/makeGen3SecureBootCfe $mediatype $ENV{BRCM_CHIP} $ENV{PROFILE_DIR} encr-Kaes-mfg oem_fld_no $secopt --cferom $cferom");
		if ( ($secbtldr) && (-e $secbtldr) ) {
			e("mv $secbtldr $storedir/cfe$ENV{BRCM_CHIP}sec_enc_mfg.bin");
		} else {
			die("The file $secbtldr was not successfully created. Exiting.");
                }

                # We need a field-only secure, headered cferom that is encrypted with either Kroe-fld or Kaes-fld
                if ($ENV{SECURE_BOOT_PROCESS_FLD_OEM_COT} eq "y") {
                    e("$ENV{HOSTTOOLS_DIR}/SecureBootUtils/makeGen3SecureBootCfe $mediatype $ENV{BRCM_CHIP} $ENV{PROFILE_DIR} encr-Kaes-fld oem_fld_yes $secopt --cferom $cferom");
                    if ( ! (($secbtldr) && (-e $secbtldr)) ) {
                        die("The file $secbtldr was not successfully created. Exiting.");
                    }
                } else {
                   e("$ENV{HOSTTOOLS_DIR}/SecureBootUtils/makeGen3SecureBootCfe $mediatype $ENV{BRCM_CHIP} $ENV{PROFILE_DIR} encr-Kroe-fld oem_fld_no $secopt --cferom $cferom");
                   if ( ! (($secbtldr) && (-e $secbtldr)) ) {
                       	die("The file $secbtldr was not successfully created. Exiting.");
                   }
		    
                }

                # Build the boot partition
                for ($i = 1; $i <= $ENV{BTRM_NUM_IMAGES_IN_PARTITION}; $i++) {
                    $j=$bootofs+$nvramalloc+($i*$imgsizealloc);
                    if ($i < ($ENV{BTRM_NUM_IMAGES_IN_PARTITION} - 1)) { 
                        concat_with_expand($intrm_image, [ $secbtldr],$j);
                    } else {
                        if ($i < $ENV{BTRM_NUM_IMAGES_IN_PARTITION}) { 
                            concat_with_expand($intrm_image, ["$storedir/cfe$ENV{BRCM_CHIP}unsec_unenc.bin" ], $j);
                        }
                        if ($i == $ENV{BTRM_NUM_IMAGES_IN_PARTITION}) { 
                            concat_with_expand($intrm_image, ["$storedir/cfe$ENV{BRCM_CHIP}sec_enc_mfg.bin" ], $j);
                        }
                    }
                    if ($mediatype eq "nand")
                    {
                        #no point in having a back up nvram in the same block as the primary
                        if($j/$blocksize >= 1)
                        {
                            $j=$j+add_nvram_mirror("image.tmp", $blocksize);
                        }
                    }
                }
                concat_with_expand($intrm_image,[],$bootsize);

            } else {

	        # cferom is in the clear. Only need to build a headered image in which it is good for both mfg secure mode and field secure mode
                print "Packaging gen3 secure boot in which the cfe rom is not encrypted. This image expects the bootrom to run ...\n";

                if ($ENV{SECURE_BOOT_PROCESS_FLD_OEM_COT} eq "y") {
                    e("$ENV{HOSTTOOLS_DIR}/SecureBootUtils/makeGen3SecureBootCfe $mediatype $ENV{BRCM_CHIP} $ENV{PROFILE_DIR} unencr oem_fld_yes $secopt --cferom $cferom");
                } else {
               	    e("$ENV{HOSTTOOLS_DIR}/SecureBootUtils/makeGen3SecureBootCfe $mediatype $ENV{BRCM_CHIP} $ENV{PROFILE_DIR} unencr oem_fld_no $secopt --cferom $cferom");
                }
                if ( ($secbtldr) && (-e $secbtldr) ) {

                    for ($i = 1; $i <= $ENV{BTRM_NUM_IMAGES_IN_PARTITION}; $i++) {
                        $j=$bootofs+$nvramalloc+($i*$imgsizealloc);
			if ($i < $ENV{BTRM_NUM_IMAGES_IN_PARTITION}) { 
                            concat_with_expand($intrm_image, [$secbtldr], $j);
                        } else {
                            concat_with_expand($intrm_image, ["$storedir/cfe$ENV{BRCM_CHIP}unsec_unenc.bin"], $j);
                        }
                        if ($mediatype eq "nand")
                        {
                            #no point in having a back up nvram in the same block as the primary
                            if($j/$blocksize >= 1)
                            {
                                $j=$j+add_nvram_mirror("image.tmp", $blocksize);
                            }
                        }
                    }
                    e("cat $intrm_image fileboot.tmp | head --bytes=$bootsize > image2.tmp");
                    concat_with_expand($intrm_image, [], $bootsize);

                } else {
                    die("The file $secbtldr was not successfully created. Exiting.");
                }
            }
}

GetOptions(
    "cferom=s", \$cferom, "pmcrom=s", \$pmcrom, "blocksize=i", \$blocksize, "rootfs=s", \$rootfs,  "bootfs=s", \$bootfs,
    "fsonly=s", \$fsonly, "image=s",     \$image,     "verbose",  \$verbose, "ubifs",    \$ubifs,  "squbifs", \$squbifs,
    "bootofs=i", \$bootofs, "bootsize=i", \$bootsize, "securehdr=s", \$securehdr, "unsecurehdr", \$unsecurehdr, "mediatype=s",\$mediatype,
    "ubionlyimage", \$ubionlyimage, "precferom=s", \$precferom , "cfesecrom=s",\$cfesecrom,

) or die("bad option");

my @required_env = (
    qw[
      PROFILE_DIR HOSTTOOLS_DIR BRCM_VOICE_BOARD_ID BRCM_NUM_MAC_ADDRESSES BRCM_BOARD_ID
      ]
);

foreach (@required_env) {
    $ENV{$_}
      or die("$_ not defined in environment");
}

if ( $blocksize == 16 * 1024 ) {
    $flashtype = "NAND16";
}
elsif ( $blocksize == 128 * 1024 ) {
    $flashtype = "NAND128";
}
elsif ( $blocksize == 256 * 1024 ) {
    $flashtype = "NAND256";
}
elsif ( $blocksize == 512 * 1024 ) {
    $flashtype = "NAND512";
}
elsif ( $blocksize == 1024 * 1024 ) {
    $flashtype = "NAND1024";
}
elsif ( $blocksize == 2048 * 1024 ) {
    $flashtype = "NAND2048";
}
elsif ( $blocksize == 2048 ) {
    $flashtype = "Generic2048";
}
else {
    die("blocksize not supported");
}

unless( $bootofs < $bootsize )
{
    die ("invalid boot offset");
}

unless ( ( $bootsize % $blocksize ) == 0 )
{
    die ("invalid boot size, must be multiple of block size.");
}


chdir $ENV{PROFILE_DIR};

$storedir = "$ENV{PROFILE_DIR}/../cfe";

$bootsizeinkb = $bootsize/1024;
$bootofsinkb = $bootofs/1024;
$blocksizeinkb = $blocksize/1024;

if ( ($pmcrom) && (-e $pmcrom) ) {
    concat_with_expand("bootofs.tmp",[$pmcrom], $bootofs);
    $pmcflag = 1;
}
else {
    concat_with_expand("bootofs.tmp",[], $bootofs);
    $pmcflag = 0;
}
if ( ($precferom) && (-e $precferom) ) {

    if( !$securehdr) {

        e("$ENV{HOSTTOOLS_DIR}/SecureBootUtils/makeGen3UnsecureBootCfe nand $ENV{BRCM_CHIP} $ENV{PROFILE_DIR} --cferom $precferom");
        my $btldr = "$storedir/cfe$ENV{BRCM_CHIP}bi_nand.bin";
        my $one_k_patch=create_spi_nand_patch(0, $btldr, "\000");
        open(patch_bin, ">patch_pre_cfe.bin");
        binmode patch_bin;
        print patch_bin $one_k_patch;
        close(patch_bin);
	e("rm bootofs.tmp");
        concat_with_expand("bootofs.tmp", ["patch_pre_cfe.bin", "$btldr"], $bootofs);
        e("rm patch_pre_cfe.bin");
    }
    else {
        print("Ignore precferom in secure environment");
    }

}

if ( !$mediatype || $mediatype eq "") 
{
	$mediatype="nand";
}

if ( ($unsecurehdr) || ($securehdr) ) {

    # if unsecurehdr is defined, then we know it is gen3 and we are building an unsecure boot
    # if securehdr is defined, then it could be gen1, 2 or 3 and we are building secure boot
    $btrmflag = 1;

    $secbtldr = "$storedir/cfe$ENV{BRCM_CHIP}bi_$mediatype.bin";
    e("rm -f $secbtldr");

    if ($ENV{BTRM_BOOT_ONLY} eq "y") {

        # XIP to flash not supported. Bootrom boot only, therefore need a flash layout the bootrom recognizes. 

	# Build the beginning of the boot partition that is common to all bootrom-boot-only flash layouts
	$nvramalloc=1024*4;
        $imgsizealloc=1024*$ENV{BTRM_IMAGE_SIZE_ALLOCATION};
        $bootsize=1024*$ENV{BTRM_NAND_BOOT_PARTITION_SIZE};
        concat_with_expand( "nvramalloc.tmp", [$cferom], $nvramalloc );
        concat_file(["bootofs.tmp", "nvramalloc.tmp"], "image.tmp"); 
        my $i;
        my $j;

        # We know we always need an unsecure, headered cferom, so build it
        e("$ENV{HOSTTOOLS_DIR}/SecureBootUtils/makeGen3UnsecureBootCfe $mediatype $ENV{BRCM_CHIP} $ENV{PROFILE_DIR} --cferom $cferom");
        if ( ($secbtldr) && (-e $secbtldr) ) {
            e("mv $secbtldr $storedir/cfe$ENV{BRCM_CHIP}unsec_unenc.bin");
        } else {
            die("The file $secbtldr was not successfully created. Exiting.");
        }

        if ($securehdr) {
		create_secure_enabled_image($securehdr,$mediatype, $cferom, $secbtldr, $storedir, 
			"image.tmp", $imgsizealloc, $nvramalloc, $bootofs, $bootsize);
        } else {

            # Unsecure only boot partition. Build the entire boot partition
            print "Packaging gen3 unsecure boot. This image expects the bootrom to run ...\n";

            for ($i = 1; $i <= $ENV{BTRM_NUM_IMAGES_IN_PARTITION}; $i++) {
		my  $patch="";
		if($ENV{BRCM_CHIP} == "4908" or $ENV{BRCM_CHIP} == "6858" and $mediatype eq "nand" )
		{
			$patch="patch.bin";
			my $Tdev,my $Tino,my $Tmode,my $Tnlink,my $Tuid,my $Tgid,my $Trdev,my $Tsize,my $Tatime,my $Tmtime,my $Tctime,my $Tblksize,my $Tblocks;
			($Tdev,$Tino,$Tmode,$Tnlink,$Tuid,$Tgid,$Trdev,$Tsize,$Tatime,$Tmtime,$Tctime,$Tblksize,$Tblocks)
			       = stat("image.tmp");
				my $one_k_patch=create_spi_nand_patch($Tsize, "$storedir/cfe$ENV{BRCM_CHIP}unsec_unenc.bin");
				open(patch_bin, ">patch.bin");
				binmode patch_bin;
				print patch_bin $one_k_patch;
				close(patch_bin);
		}
                $j=$bootofs+$nvramalloc+($i*$imgsizealloc)+($i*1024);
                concat_with_expand("image.tmp", ["$patch", "$storedir/cfe$ENV{BRCM_CHIP}unsec_unenc.bin"], $j);
		if ($mediatype eq "nand")
		{
			#no point in having a back up nvram in the same block as the primary
			if($j/$blocksize >= 1)
			{
				$j=$j+add_nvram_mirror("image.tmp", $blocksize);
			}
		}
            }
            concat_with_expand("image.tmp", [],$bootsize);
        }
    } else {

        # gen1 (63268) or gen2 secure boot. Build the entire boot partition
	my @cmd_secboot_gen2 = ("$ENV{HOSTTOOLS_DIR}/SecureBootUtils/makeSecureBootCfe", "$mediatype", "$ENV{BRCM_CHIP}", "$ENV{PROFILE_DIR}", "$bootsize", "$secbtldr", "$cfesecrom" );
        system(@cmd_secboot_gen2) == 0 or die "ERROR: @cmd_secboot_gen2 has failed"; 
        if ( ($secbtldr) && (-e $secbtldr) ) {
            if ($ENV{BRCM_CHIP} == "63268") {
                print "Packaging with gen1 secure boot support ...\n";
                concat_with_expand("bootofs.tmp",[$secbtldr], $bootsize);
            } else {
                print "Packaging with gen2 secure boot support ...\n";
                concat_with_expand("image.tmp",["bootofs.tmp",$cferom], $bootsize);
	        my $i;
	        my $j;
                for ($i = 1; $i < $ENV{SECURE_BOOT_NUM_BOOT_BLKS}; $i++) {
                    $j=($i + 1)*$bootsize;
                    if ($i <= $ENV{SECURE_BOOT_NUM_BTLDR_IMAGES}) {
                        concat_with_expand("image.tmp", [$secbtldr], $j);
                    } else {
                        concat_with_expand("image.tmp", [], $j);
                    }
                }
                $bootsize = $j;
            }
        } else {
            die("The file $secbtldr was not successfully created. Exiting.");
        }

    }
    e("rm -f $secbtldr");

} else {

    # Legacy XIP to flash boot
    print "Packaging with XIP boot support ...\n";
    $btrmflag = 0;
    concat_file(["bootofs.tmp", $cferom], "image.tmp");

}


if ($mediatype eq "nand" ) {
	if (($ubifs) || ($squbifs)){
    		if ($ubifs) {
        		e("$ENV{HOSTTOOLS_DIR}/BcmFsTag -s 2 -u $blocksize > marker.tmp");
    		}
    		if ($squbifs) {
        		e("$ENV{HOSTTOOLS_DIR}/BcmFsTag -s 2 -q $blocksize > marker.tmp");
    		}
    		if ($ubionlyimage) {
        		concat_with_expand("image.tmp", [], $bootsize);
			concat_file(["image.tmp",$rootfs], $image);
    		} else {
        		concat_with_expand("image.tmp", [], $bootsize);
			concat_file(["image.tmp",$bootfs, "marker.tmp", $rootfs], "$image");
    		}
    		if ($fsonly) {
        		concat_file(["$bootfs", "marker.tmp", $rootfs], "merged.tmp");
        		e("$ENV{HOSTTOOLS_DIR}/addvtoken --endian $ENV{ARCH_ENDIAN} --chip $ENV{BRCM_CHIP} --flashtype $flashtype --btrm $btrmflag merged.tmp $fsonly.w");
    		}
	} else {
		concat_with_expand("image.tmp", [], $bootsize); 
		concat_file(["image.tmp",$rootfs], "$image");
		if ($fsonly) {
			e("$ENV{HOSTTOOLS_DIR}/addvtoken --endian $ENV{ARCH_ENDIAN} --chip $ENV{BRCM_CHIP} --flashtype $flashtype --btrm $btrmflag $rootfs $fsonly.w");
		}
	}

	e("$ENV{HOSTTOOLS_DIR}/addvtoken --endian $ENV{ARCH_ENDIAN} --chip $ENV{BRCM_CHIP} --flashtype $flashtype --pmc $pmcflag --btrm $btrmflag $image $image.w");

	e(      "$ENV{HOSTTOOLS_DIR}/createimg.pl --set boardid=$ENV{BRCM_BOARD_ID} "
       . " endian $ENV{ARCH_ENDIAN}"
       . " numbermac=$ENV{BRCM_NUM_MAC_ADDRESSES}"
       . " macaddr=$ENV{BRCM_BASE_MAC_ADDRESS}"
       . " tp=$ENV{BRCM_MAIN_TP_NUM}"
       . " psisize=$ENV{BRCM_PSI_SIZE}"
       . " flblksz=$blocksizeinkb"
       . " auxfsprcnt=$ENV{BRCM_AUXFS_PERCENT}"
       . " gponsn=$ENV{BRCM_GPON_SERIAL_NUMBER}"
       . " gponpw=$ENV{BRCM_GPON_PASSWORD}"
       . " misc1=$ENV{BRCM_MISC1_PARTITION_SIZE}"
      . " misc2=$ENV{BRCM_MISC2_PARTITION_SIZE}"
      . " misc3=$ENV{BRCM_MISC3_PARTITION_SIZE}"
      . " misc4=$ENV{BRCM_MISC4_PARTITION_SIZE}"
      . " --wholeflashfile=$image.w"
      . " --nvramfile $ENV{HOSTTOOLS_DIR}/nvram.h"
      . " --nvramdefsfile $ENV{HOSTTOOLS_DIR}/nvram_defaults.h"
      . " --conf $ENV{HOSTTOOLS_DIR}/local_install/conf/$ENV{TOOLCHAIN_PREFIX}.conf");
} else  {
	if ($mediatype eq "emmc" ) {
		concat_with_expand("image.tmp", [], $bootsize); 
		concat_file(["image.tmp"], "$image.bin");
	} 
}

# five lines below used for emulation
# e("cat $image | head --bytes=1048576 > dummy.tmp");
# my $objcopy;
# $objcopy = "/opt/toolchains/crosstools-aarch64-gcc-4.9-linux-4.1-glibc-2.20-binutils-2.24/usr/bin/aarch64-buildroot-linux-gnu-objcopy";
# e("$objcopy --output-target=srec --input-target=binary --srec-forceS3 --change-addresses=0xffe00000 dummy.tmp $image.srec");
# e("rm -f dummy.tmp");


e("rm -f $image merged.tmp marker.tmp image.tmp imgsizealloc.tmp nvramalloc.tmp fileboot.tmp bootofs.tmp patch.bin");
e("rm -f $storedir/cfe$ENV{BRCM_CHIP}unsec_unenc.bin $storedir/cfe$ENV{BRCM_CHIP}sec_enc_mfg.bin");

sub e {
    my $cmnd = shift;
    if ($verbose) {
        print "bcmImageMaker: $cmnd\n";
    }
    system($cmnd);
}

