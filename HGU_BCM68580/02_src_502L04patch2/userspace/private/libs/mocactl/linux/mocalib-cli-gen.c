/***************************************************************************
 *
 *     Copyright (c) 2008-2011, Broadcom Corporation
 *     All Rights Reserved
 *     Confidential Property of Broadcom Corporation
 *
 *  THIS SOFTWARE MAY ONLY BE USED SUBJECT TO AN EXECUTED SOFTWARE LICENSE
 *  AGREEMENT  BETWEEN THE USER AND BROADCOM.  YOU HAVE NO RIGHT TO USE OR
 *  EXPLOIT THIS MATERIAL EXCEPT SUBJECT TO THE TERMS OF SUCH AN AGREEMENT.
 *
 *  Description: Generated libmoca CLI functions - DO NOT EDIT
 *
<:label-BRCM:2017:proprietary:standard

 This program is the proprietary software of Broadcom and/or its
 licensors, and may only be used, duplicated, modified or distributed pursuant
 to the terms and conditions of a separate, written license agreement executed
 between you and Broadcom (an "Authorized License").  Except as set forth in
 an Authorized License, Broadcom grants no license (express or implied), right
 to use, or waiver of any kind with respect to the Software, and Broadcom
 expressly reserves all rights in and to the Software and all intellectual
 property rights therein.  IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU HAVE
 NO RIGHT TO USE THIS SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY
 BROADCOM AND DISCONTINUE ALL USE OF THE SOFTWARE.

 Except as expressly set forth in the Authorized License,

 1. This program, including its structure, sequence and organization,
    constitutes the valuable trade secrets of Broadcom, and you shall use
    all reasonable efforts to protect the confidentiality thereof, and to
    use this information only in connection with your use of Broadcom
    integrated circuit products.

 2. TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
    AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES, REPRESENTATIONS OR
    WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH
    RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY DISCLAIMS ANY AND
    ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT,
    FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR
    COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE
    TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT OF USE OR
    PERFORMANCE OF THE SOFTWARE.

 3. TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR
    ITS LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL, INCIDENTAL, SPECIAL,
    INDIRECT, OR EXEMPLARY DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY
    WAY RELATING TO YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN
    IF BROADCOM HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES;
    OR (ii) ANY AMOUNT IN EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE
    SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE LIMITATIONS
    SHALL APPLY NOTWITHSTANDING ANY FAILURE OF ESSENTIAL PURPOSE OF ANY
    LIMITED REMEDY.
:>
 ***************************************************************************/

#include "mocalib.h"

uint32_t gCheckinit = 0;

static void mocacli_print_init_note(void)
{
   printf("Note: Parameter will take effect after next MoCA core initialization.\n");
}

MOCALIB_CLI_PRINT void mocacli_print_preferred_nc (uint32_t * in)
{
   printf("preferred_nc: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_single_channel_operation (uint32_t * in)
{
   printf("single_channel_operation: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_continuous_power_tx_mode (uint32_t * in)
{
   printf("continuous_power_tx_mode: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_continuous_rx_mode_attn (int32_t * in)
{
   printf("continuous_rx_mode_attn: 0x%x  ( %d )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_lof (uint32_t * in)
{
   printf("lof: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_max_nbas_primary (uint32_t * in)
{
   printf("max_nbas_primary: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_ps_swch_tx1 (uint32_t * in)
{
   printf("ps_swch_tx1: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_ps_swch_tx2 (uint32_t * in)
{
   printf("ps_swch_tx2: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_ps_swch_rx1 (uint32_t * in)
{
   printf("ps_swch_rx1: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_ps_swch_rx2 (uint32_t * in)
{
   printf("ps_swch_rx2: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_ps_swch_rx3 (uint32_t * in)
{
   printf("ps_swch_rx3: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_bonding (uint32_t * in)
{
   printf("bonding: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_listening_freq_mask (uint32_t * in)
{
   printf("listening_freq_mask: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_listening_duration (uint32_t * in)
{
   printf("listening_duration: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_limit_traffic (uint32_t * in)
{
   printf("limit_traffic: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_remote_man (uint32_t * in)
{
   printf("remote_man: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_c4_moca20_en (uint32_t * in)
{
   printf("c4_moca20_en: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_power_save_mechanism_dis (uint32_t * in)
{
   printf("power_save_mechanism_dis: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_psm_config (uint32_t * in)
{
   printf("psm_config: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_use_ext_data_mem (uint32_t * in)
{
   printf("use_ext_data_mem: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_aif_mode (uint32_t * in)
{
   printf("aif_mode: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_prof_pad_ctrl_deg_6802c0_bonding (uint32_t * in)
{
   printf("prof_pad_ctrl_deg_6802c0_bonding: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_prop_bonding_compatibility_mode (uint32_t * in)
{
   printf("prop_bonding_compatibility_mode: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_rdeg_3450 (uint32_t * in)
{
   printf("rdeg_3450: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_phy_clock (uint32_t * in)
{
   printf("phy_clock: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_max_nbas_secondary (uint32_t * in)
{
   printf("max_nbas_secondary: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_mac_addr (struct moca_mac_addr * in)
{
   printf("== mac_addr ");
   printf(" ========================================== \n");
   printf("val: %02x:%02x:%02x:%02x:%02x:%02x \n", MOCA_DISPLAY_MAC(in->val));
   printf("== end mac_addr ");
   printf(" ====================================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_node_status (struct moca_node_status * in)
{
   printf("== node_status ");
   printf(" ======================================= \n");
   printf("vendor_id            : %u  ( 0x%x )\n", in->vendor_id, in->vendor_id);
   printf("moca_hw_version      : %u  ( 0x%x )\n", in->moca_hw_version, in->moca_hw_version);
   printf("moca_sw_version_major: %u  ( 0x%x )\n", in->moca_sw_version_major, in->moca_sw_version_major);
   printf("moca_sw_version_minor: %u  ( 0x%x )\n", in->moca_sw_version_minor, in->moca_sw_version_minor);
   printf("moca_sw_version_rev  : %u  ( 0x%x )\n", in->moca_sw_version_rev, in->moca_sw_version_rev);
   printf("self_moca_version    : %u  ( 0x%x )\n", in->self_moca_version, in->self_moca_version);
   printf("qam_256_support      : %u  ( 0x%x )\n", in->qam_256_support, in->qam_256_support);
   printf("== end node_status ");
   printf(" =================================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_fw_version (struct moca_fw_version * in)
{
   printf("== fw_version ");
   printf(" ======================================== \n");
   printf("version_moca : %u  ( 0x%x )\n", in->version_moca, in->version_moca);
   printf("version_major: %u  ( 0x%x )\n", in->version_major, in->version_major);
   printf("version_minor: %u  ( 0x%x )\n", in->version_minor, in->version_minor);
   printf("version_patch: %u  ( 0x%x )\n", in->version_patch, in->version_patch);
   printf("== end fw_version ");
   printf(" ==================================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_max_tx_power_tune (struct moca_max_tx_power_tune * in)
{
   uint32_t i;

   printf("== max_tx_power_tune ");
   printf(" ================================= \n");
   printf("offset[86]: ");
   for (i = 0; i < 86; i++) {
      printf(" %4d: %d\n", i*25, in->offset[i]);
   }
   printf("\n");
   printf("padding   : %u  ( 0x%04x )\n", in->padding, in->padding);
   printf("== end max_tx_power_tune ");
   printf(" ============================= \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_max_tx_power_tune_sec_ch (struct moca_max_tx_power_tune_sec_ch * in)
{
   uint32_t i;

   printf("== max_tx_power_tune_sec_ch ");
   printf(" ========================== \n");
   printf("offset[86]: ");
   for (i = 0; i < 86; i++) {
      printf(" %4d: %d\n", i*25, in->offset[i]);
   }
   printf("\n");
   printf("padding   : %u  ( 0x%04x )\n", in->padding, in->padding);
   printf("== end max_tx_power_tune_sec_ch ");
   printf(" ====================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_rx_power_tune (struct moca_rx_power_tune * in)
{
   uint32_t i;

   printf("== rx_power_tune ");
   printf(" ===================================== \n");
   printf("offset[86]: ");
   for (i = 0; i < 86; i++) {
      printf(" %4d: %d\n", i*25, in->offset[i]);
   }
   printf("\n");
   printf("padding   : %u  ( 0x%04x )\n", in->padding, in->padding);
   printf("== end rx_power_tune ");
   printf(" ================================= \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_impedance_mode_bonding (uint32_t * in)
{
   printf("impedance_mode_bonding: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_rework_6802 (uint32_t * in)
{
   printf("rework_6802: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_prof_pad_ctrl_deg_6802c0_single (struct moca_prof_pad_ctrl_deg_6802c0_single * in)
{
   uint32_t i;

   printf("== prof_pad_ctrl_deg_6802c0_single ");
   printf(" =================== \n");
   printf("offset[86]: ");
   for (i = 0; i < 86; i++) {
      printf(" %4d: %d\n", i*25, in->offset[i]);
   }
   printf("\n");
   printf("padding   : %u  ( 0x%04x )\n", in->padding, in->padding);
   printf("== end prof_pad_ctrl_deg_6802c0_single ");
   printf(" =============== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_drv_info (struct moca_drv_info * in)
{
   uint32_t i;

   printf("== drv_info ");
   printf(" ========================================== \n");
   printf("version              : %u  ( 0x%x )\n", in->version, in->version);
   printf("build_number         : %u  ( 0x%x )\n", in->build_number, in->build_number);
   printf("hw_rev               : %u  ( 0x%x )\n", in->hw_rev, in->hw_rev);
   printf("uptime               : %02uh:%02um:%02us \n", (in->uptime / 3600), ((in->uptime % 3600) / 60), (in->uptime % 60));
   printf("link_uptime          : %02uh:%02um:%02us \n", (in->link_uptime / 3600), ((in->link_uptime % 3600) / 60), (in->link_uptime % 60));
   printf("core_uptime          : %02uh:%02um:%02us \n", (in->core_uptime / 3600), ((in->core_uptime % 3600) / 60), (in->core_uptime % 60));
   printf("ifname[16]           : ");
   for (i = 0; i < 16; i++) {
      printf("%c", in->ifname[i]);
   }
   printf("\n");
   printf("devname[64]          : ");
   for (i = 0; i < 64; i++) {
      printf("%c", in->devname[i]);
   }
   printf("\n");
   printf("rf_band              : %d (%s)\n", in->rf_band, (in->rf_band == 0 ? "HIGHRF" : (in->rf_band == 1 ? "MIDRF" : (in->rf_band == 2 ? "WANRF" : (in->rf_band == 3 ? "Ext_D" : (in->rf_band == 4 ? "D_LOW" : (in->rf_band == 5 ? "D_HIGH" : (in->rf_band == 6 ? "E" : (in->rf_band == 7 ? "F" : "Unknown")))))))));
   printf("chip_id              : %u  ( 0x%x )\n", in->chip_id, in->chip_id);
   printf("reset_count          : %u  ( 0x%x )\n", in->reset_count, in->reset_count);
   printf("link_up_count        : %u  ( 0x%x )\n", in->link_up_count, in->link_up_count);
   printf("link_down_count      : %u  ( 0x%x )\n", in->link_down_count, in->link_down_count);
   printf("topology_change_count: %u  ( 0x%x )\n", in->topology_change_count, in->topology_change_count);
   printf("assert_count         : %u  ( 0x%x )\n", in->assert_count, in->assert_count);
   printf("last_assert_num      : 0x%x  ( %d )\n", in->last_assert_num, in->last_assert_num);
   printf("wdog_count           : %u  ( 0x%x )\n", in->wdog_count, in->wdog_count);
   printf("restart_history      : %d %d %d %d \n", ((in->restart_history >> 24) & 0xFF), ((in->restart_history >> 16) & 0xFF), ((in->restart_history >> 8) & 0xFF), (in->restart_history & 0xFF));
   printf("== end drv_info ");
   printf(" ====================================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_en_capable (uint32_t * in)
{
   printf("en_capable: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_mocad_version (struct moca_mocad_version * in)
{
   printf("== mocad_version ");
   printf(" ===================================== \n");
   printf("mocad_version_moca : %u  ( 0x%x )\n", in->mocad_version_moca, in->mocad_version_moca);
   printf("mocad_version_major: %u  ( 0x%x )\n", in->mocad_version_major, in->mocad_version_major);
   printf("mocad_version_minor: %u  ( 0x%x )\n", in->mocad_version_minor, in->mocad_version_minor);
   printf("mocad_version_patch: %u  ( 0x%x )\n", in->mocad_version_patch, in->mocad_version_patch);
   printf("== end mocad_version ");
   printf(" ================================= \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_lof_update (uint32_t * in)
{
   printf("lof_update: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_primary_ch_offset (int32_t * in)
{
   printf("primary_ch_offset: 0x%x  ( %d )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_assertText (uint32_t * in)
{
   printf("assertText: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_wdog_enable (uint32_t * in)
{
   printf("wdog_enable: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_mr_seq_num (uint32_t * in)
{
   printf("mr_seq_num: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_secondary_ch_offset (int32_t * in)
{
   printf("secondary_ch_offset: 0x%x  ( %d )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_amp_type (uint32_t * in)
{
   printf("amp_type: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_HELP static void mocacli_preferred_nc__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = normal node \n");
   printf("1 = preferred NC\n");
   printf("Default:\n");
   printf("0 \n1 (BAND_E)\n1 (BAND_F)\n");
}

MOCALIB_CLI_HELP static void mocacli_get_preferred_nc_help( void )
{
   printf("In MoCA 1.1, Preferred NC nodes have a preference over the other nodes in the MoCA Network to become the NC node.\n");
   printf("(GCAP.37)\n");

   printf("\nmocap get --preferred_nc\n");
}

MOCALIB_CLI_GET static int mocacli_get_preferred_nc_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t preferred_nc;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_preferred_nc_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&preferred_nc, 0, sizeof(preferred_nc));

      ret = moca_get_preferred_nc(handle, &preferred_nc);

      if (ret == 0) {
         mocacli_print_preferred_nc(&preferred_nc);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_preferred_nc_help( void )
{
   printf("In MoCA 1.1, Preferred NC nodes have a preference over the other nodes in the MoCA Network to become the NC node.\n");
   printf("(GCAP.37)\n");

   printf("\nmocap set --preferred_nc <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_preferred_nc_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t preferred_nc;

   if (handle != NULL)
   {
      ret = moca_get_preferred_nc(handle, &preferred_nc);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_preferred_nc_help();
            mocacli_preferred_nc__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &preferred_nc);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_preferred_nc__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_preferred_nc(handle, preferred_nc);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_single_channel_operation__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = Normal Network Search operation\n");
   printf("1 = Single Channel Operation.\n");
   printf("Default:\n");
   printf("0 \n1 (BAND_GENERIC)\n");
}

MOCALIB_CLI_HELP static void mocacli_get_single_channel_operation_help( void )
{
   printf("This is the Single Channel Operation indication.\n");
   printf("Enable the MoCA for automatic Network Search, using the LOF and RF_TYPE parameters, or use the OSP Single Channel Operation.\n");

   printf("\nmocap get --single_channel_operation\n");
}

MOCALIB_CLI_GET static int mocacli_get_single_channel_operation_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t single_channel_operation;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_single_channel_operation_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&single_channel_operation, 0, sizeof(single_channel_operation));

      ret = moca_get_single_channel_operation(handle, &single_channel_operation);

      if (ret == 0) {
         mocacli_print_single_channel_operation(&single_channel_operation);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_single_channel_operation_help( void )
{
   printf("This is the Single Channel Operation indication.\n");
   printf("Enable the MoCA for automatic Network Search, using the LOF and RF_TYPE parameters, or use the OSP Single Channel Operation.\n");

   printf("\nmocap set --single_channel_operation <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_single_channel_operation_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t single_channel_operation;

   if (handle != NULL)
   {
      ret = moca_get_single_channel_operation(handle, &single_channel_operation);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_single_channel_operation_help();
            mocacli_single_channel_operation__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &single_channel_operation);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_single_channel_operation__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_single_channel_operation(handle, single_channel_operation);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_continuous_power_tx_mode__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = Normal operation \n");
   printf("1 = Continuous power TX mode \n");
   printf("2 = Continuous RX mode \n");
   printf("5 = Continuous power TX mode Secondary (bonded chips only)\n");
   printf("6 = Continuous power TX mode Bonded (bonded chips only)\n");
   printf("7= Continuous power Standby mode\n");
   printf("8= Continuous power down mode\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_continuous_power_tx_mode_help( void )
{
   printf("Ability to transmit in a constant power mode as defined by the spec. It is used only for lab testing. The transmit channel will be the LOF.\n");

   printf("\nmocap get --continuous_power_tx_mode\n");
}

MOCALIB_CLI_GET static int mocacli_get_continuous_power_tx_mode_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t continuous_power_tx_mode;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_continuous_power_tx_mode_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&continuous_power_tx_mode, 0, sizeof(continuous_power_tx_mode));

      ret = moca_get_continuous_power_tx_mode(handle, &continuous_power_tx_mode);

      if (ret == 0) {
         mocacli_print_continuous_power_tx_mode(&continuous_power_tx_mode);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_continuous_power_tx_mode_help( void )
{
   printf("Ability to transmit in a constant power mode as defined by the spec. It is used only for lab testing. The transmit channel will be the LOF.\n");

   printf("\nmocap set --continuous_power_tx_mode <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_continuous_power_tx_mode_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t continuous_power_tx_mode;

   if (handle != NULL)
   {
      ret = moca_get_continuous_power_tx_mode(handle, &continuous_power_tx_mode);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_continuous_power_tx_mode_help();
            mocacli_continuous_power_tx_mode__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &continuous_power_tx_mode);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_continuous_power_tx_mode__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_continuous_power_tx_mode(handle, continuous_power_tx_mode);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_continuous_rx_mode_attn__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("-1 \n");
   printf("Maximum:\n");
   printf("63 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_continuous_rx_mode_attn_help( void )
{

   printf("\nmocap get --continuous_rx_mode_attn\n");
}

MOCALIB_CLI_GET static int mocacli_get_continuous_rx_mode_attn_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   int32_t continuous_rx_mode_attn;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_continuous_rx_mode_attn_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&continuous_rx_mode_attn, 0, sizeof(continuous_rx_mode_attn));

      ret = moca_get_continuous_rx_mode_attn(handle, &continuous_rx_mode_attn);

      if (ret == 0) {
         mocacli_print_continuous_rx_mode_attn(&continuous_rx_mode_attn);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_continuous_rx_mode_attn_help( void )
{

   printf("\nmocap set --continuous_rx_mode_attn <int32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_continuous_rx_mode_attn_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   int32_t continuous_rx_mode_attn;

   if (handle != NULL)
   {
      ret = moca_get_continuous_rx_mode_attn(handle, &continuous_rx_mode_attn);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_continuous_rx_mode_attn_help();
            mocacli_continuous_rx_mode_attn__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_int32(*pp_parms, &continuous_rx_mode_attn);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_continuous_rx_mode_attn__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_continuous_rx_mode_attn(handle, continuous_rx_mode_attn);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_lof__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("Frequency in MHz \n");
   printf("\n");
   printf("Band D: 1125 - 1625 \n");
   printf("Band D-Low: 1125 - 1225 \n");
   printf("Band D-High: 1350 - 1625 \n");
   printf("Band E: 500 - 600 \n");
   printf("Band F: 675 - 850 \n");
   printf("Band C4: 1000 \n");
   printf("Band H: 975 - 1025\n");
   printf("Default:\n");
   printf("0 \n1150 (BAND_EX_D)\n1150 (BAND_D_LOW)\n1150 (BAND_GENERIC)\n1400 (BAND_D_HIGH)\n575 (BAND_E)\n800 (BAND_F)\n1000 (BAND_C4)\n1000 (BAND_H)\n");
}

MOCALIB_CLI_HELP static void mocacli_get_lof_help( void )
{
   printf("Last Operation Frequency. RF frequency to which the MoCA interface was tuned when last operational.\n");
   printf("(GCAP.8)\n");
   printf("This field is used also for setting required frequency of operation, when not in Network Search mode.\n");

   printf("\nmocap get --lof\n");
}

MOCALIB_CLI_GET static int mocacli_get_lof_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t lof;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_lof_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&lof, 0, sizeof(lof));

      ret = moca_get_lof(handle, &lof);

      if (ret == 0) {
         mocacli_print_lof(&lof);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_lof_help( void )
{
   printf("Last Operation Frequency. RF frequency to which the MoCA interface was tuned when last operational.\n");
   printf("(GCAP.8)\n");
   printf("This field is used also for setting required frequency of operation, when not in Network Search mode.\n");

   printf("\nmocap set --lof <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_lof_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t lof;

   if (handle != NULL)
   {
      ret = moca_get_lof(handle, &lof);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_lof_help();
            mocacli_lof__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &lof);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_lof__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_lof(handle, lof);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_max_nbas_primary__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_max_nbas_primary_help( void )
{

   printf("\nmocap get --max_nbas_primary\n");
}

MOCALIB_CLI_GET static int mocacli_get_max_nbas_primary_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t max_nbas_primary;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_max_nbas_primary_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&max_nbas_primary, 0, sizeof(max_nbas_primary));

      ret = __moca_get_max_nbas_primary(handle, &max_nbas_primary);

      if (ret == 0) {
         mocacli_print_max_nbas_primary(&max_nbas_primary);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_max_nbas_primary_help( void )
{

   printf("\nmocap set --max_nbas_primary <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_max_nbas_primary_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t max_nbas_primary;

   if (handle != NULL)
   {
      ret = __moca_get_max_nbas_primary(handle, &max_nbas_primary);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_max_nbas_primary_help();
            mocacli_max_nbas_primary__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &max_nbas_primary);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_max_nbas_primary__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_max_nbas_primary(handle, max_nbas_primary);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_ps_swch_tx1__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = Normal operation mode \n");
   printf("1 = Keep Tx controls activated constantly\n");
   printf(">1 = Enable/Disable switching of particular controls per the CLI register value.\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_ps_swch_tx1_help( void )
{

   printf("\nmocap get --ps_swch_tx1\n");
}

MOCALIB_CLI_GET static int mocacli_get_ps_swch_tx1_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t ps_swch_tx1;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_ps_swch_tx1_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&ps_swch_tx1, 0, sizeof(ps_swch_tx1));

      ret = __moca_get_ps_swch_tx1(handle, &ps_swch_tx1);

      if (ret == 0) {
         mocacli_print_ps_swch_tx1(&ps_swch_tx1);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_ps_swch_tx1_help( void )
{

   printf("\nmocap set --ps_swch_tx1 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_ps_swch_tx1_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t ps_swch_tx1;

   if (handle != NULL)
   {
      ret = __moca_get_ps_swch_tx1(handle, &ps_swch_tx1);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_ps_swch_tx1_help();
            mocacli_ps_swch_tx1__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &ps_swch_tx1);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_ps_swch_tx1__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_ps_swch_tx1(handle, ps_swch_tx1);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_ps_swch_tx2__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = Normal operation mode \n");
   printf("1 = Keep Tx controls activated constantly\n");
   printf(">1 = Enable/Disable switching of particular controls per the CLI register value.\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_ps_swch_tx2_help( void )
{

   printf("\nmocap get --ps_swch_tx2\n");
}

MOCALIB_CLI_GET static int mocacli_get_ps_swch_tx2_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t ps_swch_tx2;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_ps_swch_tx2_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&ps_swch_tx2, 0, sizeof(ps_swch_tx2));

      ret = __moca_get_ps_swch_tx2(handle, &ps_swch_tx2);

      if (ret == 0) {
         mocacli_print_ps_swch_tx2(&ps_swch_tx2);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_ps_swch_tx2_help( void )
{

   printf("\nmocap set --ps_swch_tx2 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_ps_swch_tx2_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t ps_swch_tx2;

   if (handle != NULL)
   {
      ret = __moca_get_ps_swch_tx2(handle, &ps_swch_tx2);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_ps_swch_tx2_help();
            mocacli_ps_swch_tx2__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &ps_swch_tx2);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_ps_swch_tx2__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_ps_swch_tx2(handle, ps_swch_tx2);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_ps_swch_rx1__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = Normal operation mode \n");
   printf("1 = Keep Rx controls activated constantly\n");
   printf(">1 = Enable/Disable switching of particular controls per the CLI register value.\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_ps_swch_rx1_help( void )
{

   printf("\nmocap get --ps_swch_rx1\n");
}

MOCALIB_CLI_GET static int mocacli_get_ps_swch_rx1_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t ps_swch_rx1;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_ps_swch_rx1_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&ps_swch_rx1, 0, sizeof(ps_swch_rx1));

      ret = __moca_get_ps_swch_rx1(handle, &ps_swch_rx1);

      if (ret == 0) {
         mocacli_print_ps_swch_rx1(&ps_swch_rx1);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_ps_swch_rx1_help( void )
{

   printf("\nmocap set --ps_swch_rx1 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_ps_swch_rx1_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t ps_swch_rx1;

   if (handle != NULL)
   {
      ret = __moca_get_ps_swch_rx1(handle, &ps_swch_rx1);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_ps_swch_rx1_help();
            mocacli_ps_swch_rx1__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &ps_swch_rx1);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_ps_swch_rx1__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_ps_swch_rx1(handle, ps_swch_rx1);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_ps_swch_rx2__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = Normal operation mode \n");
   printf("1 = Keep Rx controls activated constantly\n");
   printf(">1 = Enable/Disable switching of particular controls per the CLI register value.\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_ps_swch_rx2_help( void )
{

   printf("\nmocap get --ps_swch_rx2\n");
}

MOCALIB_CLI_GET static int mocacli_get_ps_swch_rx2_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t ps_swch_rx2;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_ps_swch_rx2_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&ps_swch_rx2, 0, sizeof(ps_swch_rx2));

      ret = __moca_get_ps_swch_rx2(handle, &ps_swch_rx2);

      if (ret == 0) {
         mocacli_print_ps_swch_rx2(&ps_swch_rx2);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_ps_swch_rx2_help( void )
{

   printf("\nmocap set --ps_swch_rx2 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_ps_swch_rx2_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t ps_swch_rx2;

   if (handle != NULL)
   {
      ret = __moca_get_ps_swch_rx2(handle, &ps_swch_rx2);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_ps_swch_rx2_help();
            mocacli_ps_swch_rx2__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &ps_swch_rx2);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_ps_swch_rx2__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_ps_swch_rx2(handle, ps_swch_rx2);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_ps_swch_rx3__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = Normal operation mode \n");
   printf("1 = Keep Rx controls activated constantly\n");
   printf(">1 = Enable/Disable switching of particular controls per the CLI register value.\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_ps_swch_rx3_help( void )
{

   printf("\nmocap get --ps_swch_rx3\n");
}

MOCALIB_CLI_GET static int mocacli_get_ps_swch_rx3_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t ps_swch_rx3;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_ps_swch_rx3_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&ps_swch_rx3, 0, sizeof(ps_swch_rx3));

      ret = __moca_get_ps_swch_rx3(handle, &ps_swch_rx3);

      if (ret == 0) {
         mocacli_print_ps_swch_rx3(&ps_swch_rx3);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_ps_swch_rx3_help( void )
{

   printf("\nmocap set --ps_swch_rx3 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_ps_swch_rx3_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t ps_swch_rx3;

   if (handle != NULL)
   {
      ret = __moca_get_ps_swch_rx3(handle, &ps_swch_rx3);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_ps_swch_rx3_help();
            mocacli_ps_swch_rx3__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &ps_swch_rx3);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_ps_swch_rx3__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_ps_swch_rx3(handle, ps_swch_rx3);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_bonding__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n0 (BONDING_SUPPORTED)\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("0 \n0 (BAND_D_LOW)\n1 (BONDING_SUPPORTED)\n");
}

MOCALIB_CLI_HELP static void mocacli_get_bonding_help( void )
{
   printf("Enables bonding on chips that support it.\n");

   printf("\nmocap get --bonding\n");
}

MOCALIB_CLI_GET static int mocacli_get_bonding_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t bonding;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_bonding_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&bonding, 0, sizeof(bonding));

      ret = moca_get_bonding(handle, &bonding);

      if (ret == 0) {
         mocacli_print_bonding(&bonding);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_bonding_help( void )
{
   printf("Enables bonding on chips that support it.\n");

   printf("\nmocap set --bonding <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_bonding_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t bonding;

   if (handle != NULL)
   {
      ret = moca_get_bonding(handle, &bonding);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_bonding_help();
            mocacli_bonding__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &bonding);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_bonding__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_bonding(handle, bonding);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_listening_freq_mask__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0xFFFFFFFF \n");
}

MOCALIB_CLI_HELP static void mocacli_get_listening_freq_mask_help( void )
{
   printf("Bit mask for specifying which frequencies should be scanned during the listening phase of network search. Depending on the RF band of operation, the MSB of this parameter corresponds to the lowest frequency channel of the band. Each subsequent bit of this parameter represents the next highest 25MHz channel. The base channels for each RF band are as follows: \n");
   printf("Band D-Low : 46 (1150 MHz) \n");
   printf("Band D-High: 56 (1400 MHz) \n");
   printf("Band Ext-D : 46 (1150 MHz) \n");
   printf("Band C4 : 40 (1000 MHz) \n");
   printf("Band E : 20 ( 500 MHz) \n");
   printf("Band F : 27 ( 675 MHz) \n");
   printf("Band H : 39 ( 975 MHz)\n");

   printf("\nmocap get --listening_freq_mask\n");
}

MOCALIB_CLI_GET static int mocacli_get_listening_freq_mask_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t listening_freq_mask;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_listening_freq_mask_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&listening_freq_mask, 0, sizeof(listening_freq_mask));

      ret = moca_get_listening_freq_mask(handle, &listening_freq_mask);

      if (ret == 0) {
         mocacli_print_listening_freq_mask(&listening_freq_mask);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_listening_freq_mask_help( void )
{
   printf("Bit mask for specifying which frequencies should be scanned during the listening phase of network search. Depending on the RF band of operation, the MSB of this parameter corresponds to the lowest frequency channel of the band. Each subsequent bit of this parameter represents the next highest 25MHz channel. The base channels for each RF band are as follows: \n");
   printf("Band D-Low : 46 (1150 MHz) \n");
   printf("Band D-High: 56 (1400 MHz) \n");
   printf("Band Ext-D : 46 (1150 MHz) \n");
   printf("Band C4 : 40 (1000 MHz) \n");
   printf("Band E : 20 ( 500 MHz) \n");
   printf("Band F : 27 ( 675 MHz) \n");
   printf("Band H : 39 ( 975 MHz)\n");

   printf("\nmocap set --listening_freq_mask <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_listening_freq_mask_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t listening_freq_mask;

   if (handle != NULL)
   {
      ret = moca_get_listening_freq_mask(handle, &listening_freq_mask);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_listening_freq_mask_help();
            mocacli_listening_freq_mask__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &listening_freq_mask);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_listening_freq_mask__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_listening_freq_mask(handle, listening_freq_mask);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_listening_duration__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("1050 \n");
   printf("Minimum:\n");
   printf("100 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_listening_duration_help( void )
{
   printf("The duration in milliseconds that should be spent listening for beacons on each channel during the network search listening phase.\n");

   printf("\nmocap get --listening_duration\n");
}

MOCALIB_CLI_GET static int mocacli_get_listening_duration_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t listening_duration;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_listening_duration_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&listening_duration, 0, sizeof(listening_duration));

      ret = moca_get_listening_duration(handle, &listening_duration);

      if (ret == 0) {
         mocacli_print_listening_duration(&listening_duration);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_listening_duration_help( void )
{
   printf("The duration in milliseconds that should be spent listening for beacons on each channel during the network search listening phase.\n");

   printf("\nmocap set --listening_duration <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_listening_duration_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t listening_duration;

   if (handle != NULL)
   {
      ret = moca_get_listening_duration(handle, &listening_duration);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_listening_duration_help();
            mocacli_listening_duration__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &listening_duration);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_listening_duration__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_listening_duration(handle, listening_duration);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_limit_traffic__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("2 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_limit_traffic_help( void )
{
   printf("Limit traffic for extra power save mode.\n");

   printf("\nmocap get --limit_traffic\n");
}

MOCALIB_CLI_GET static int mocacli_get_limit_traffic_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t limit_traffic;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_limit_traffic_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&limit_traffic, 0, sizeof(limit_traffic));

      ret = moca_get_limit_traffic(handle, &limit_traffic);

      if (ret == 0) {
         mocacli_print_limit_traffic(&limit_traffic);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_limit_traffic_help( void )
{
   printf("Limit traffic for extra power save mode.\n");

   printf("\nmocap set --limit_traffic <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_limit_traffic_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t limit_traffic;

   if (handle != NULL)
   {
      ret = moca_get_limit_traffic(handle, &limit_traffic);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_limit_traffic_help();
            mocacli_limit_traffic__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &limit_traffic);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_limit_traffic__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_limit_traffic(handle, limit_traffic);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_remote_man__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = Disabled \n");
   printf("1 = Management over Ethernet enabled \n");
   printf("2 = Management over Ethernet and MoCA enabled\n");
   printf("Default:\n");
   printf("0 \n1 (STANDALONE,6802B0)\n2 (STANDALONE,6802C0)\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("2 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_remote_man_help( void )
{
   printf("Remote management mode\n");

   printf("\nmocap get --remote_man\n");
}

MOCALIB_CLI_GET static int mocacli_get_remote_man_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t remote_man;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_remote_man_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&remote_man, 0, sizeof(remote_man));

      ret = moca_get_remote_man(handle, &remote_man);

      if (ret == 0) {
         mocacli_print_remote_man(&remote_man);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_remote_man_help( void )
{
   printf("Remote management mode\n");

   printf("\nmocap set --remote_man <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_remote_man_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t remote_man;

   if (handle != NULL)
   {
      ret = moca_get_remote_man(handle, &remote_man);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_remote_man_help();
            mocacli_remote_man__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &remote_man);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_remote_man__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_remote_man(handle, remote_man);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_c4_moca20_en__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = Disable MoCA 2.0 on C4 band.\n");
   printf("1 = Enable MoCA 2.0 also on C4 band.\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_c4_moca20_en_help( void )
{
   printf("Enables MoCA 2.0 also on C4 band.\n");

   printf("\nmocap get --c4_moca20_en\n");
}

MOCALIB_CLI_GET static int mocacli_get_c4_moca20_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t c4_moca20_en;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_c4_moca20_en_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&c4_moca20_en, 0, sizeof(c4_moca20_en));

      ret = moca_get_c4_moca20_en(handle, &c4_moca20_en);

      if (ret == 0) {
         mocacli_print_c4_moca20_en(&c4_moca20_en);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_c4_moca20_en_help( void )
{
   printf("Enables MoCA 2.0 also on C4 band.\n");

   printf("\nmocap set --c4_moca20_en <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_c4_moca20_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t c4_moca20_en;

   if (handle != NULL)
   {
      ret = moca_get_c4_moca20_en(handle, &c4_moca20_en);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_c4_moca20_en_help();
            mocacli_c4_moca20_en__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &c4_moca20_en);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_c4_moca20_en__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_c4_moca20_en(handle, c4_moca20_en);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_power_save_mechanism_dis__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = Normal operation mode \n");
   printf("1 = Disable PSM \n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_power_save_mechanism_dis_help( void )
{
   printf("Enables disable of the PSM.\n");

   printf("\nmocap get --power_save_mechanism_dis\n");
}

MOCALIB_CLI_GET static int mocacli_get_power_save_mechanism_dis_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t power_save_mechanism_dis;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_power_save_mechanism_dis_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&power_save_mechanism_dis, 0, sizeof(power_save_mechanism_dis));

      ret = moca_get_power_save_mechanism_dis(handle, &power_save_mechanism_dis);

      if (ret == 0) {
         mocacli_print_power_save_mechanism_dis(&power_save_mechanism_dis);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_power_save_mechanism_dis_help( void )
{
   printf("Enables disable of the PSM.\n");

   printf("\nmocap set --power_save_mechanism_dis <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_power_save_mechanism_dis_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t power_save_mechanism_dis;

   if (handle != NULL)
   {
      ret = moca_get_power_save_mechanism_dis(handle, &power_save_mechanism_dis);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_power_save_mechanism_dis_help();
            mocacli_power_save_mechanism_dis__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &power_save_mechanism_dis);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_power_save_mechanism_dis__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_power_save_mechanism_dis(handle, power_save_mechanism_dis);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_psm_config__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("Bitwise value which each bit indicate component <1- enable, 0- disable> \n");
   printf("Bit 0 = 3451 \n");
   printf("Bit 1 = PLL \n");
   printf("Bit 2 = Analog \n");
   printf("Default:\n");
   printf("7 \n6 (7425)\n3 (28NM)\n");
   printf("Minimum:\n");
   printf("0 \n2 (7425)\n");
   printf("Maximum:\n");
   printf("7 \n3 (28NM)\n");
}

MOCALIB_CLI_HELP static void mocacli_get_psm_config_help( void )
{
   printf("Configure which PSM components are enabled.\n");

   printf("\nmocap get --psm_config\n");
}

MOCALIB_CLI_GET static int mocacli_get_psm_config_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t psm_config;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_psm_config_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&psm_config, 0, sizeof(psm_config));

      ret = moca_get_psm_config(handle, &psm_config);

      if (ret == 0) {
         mocacli_print_psm_config(&psm_config);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_psm_config_help( void )
{
   printf("Configure which PSM components are enabled.\n");

   printf("\nmocap set --psm_config <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_psm_config_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t psm_config;

   if (handle != NULL)
   {
      ret = moca_get_psm_config(handle, &psm_config);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_psm_config_help();
            mocacli_psm_config__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &psm_config);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_psm_config__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_psm_config(handle, psm_config);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_use_ext_data_mem__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("0 \n1 (BONDING_SUPPORTED)\n");
}

MOCALIB_CLI_HELP static void mocacli_get_use_ext_data_mem_help( void )
{
   printf("Configures whether to use extended memory in bonded chip running as single\n");

   printf("\nmocap get --use_ext_data_mem\n");
}

MOCALIB_CLI_GET static int mocacli_get_use_ext_data_mem_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t use_ext_data_mem;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_use_ext_data_mem_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&use_ext_data_mem, 0, sizeof(use_ext_data_mem));

      ret = moca_get_use_ext_data_mem(handle, &use_ext_data_mem);

      if (ret == 0) {
         mocacli_print_use_ext_data_mem(&use_ext_data_mem);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_use_ext_data_mem_help( void )
{
   printf("Configures whether to use extended memory in bonded chip running as single\n");

   printf("\nmocap set --use_ext_data_mem <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_use_ext_data_mem_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t use_ext_data_mem;

   if (handle != NULL)
   {
      ret = moca_get_use_ext_data_mem(handle, &use_ext_data_mem);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_use_ext_data_mem_help();
            mocacli_use_ext_data_mem__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &use_ext_data_mem);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_use_ext_data_mem__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_use_ext_data_mem(handle, use_ext_data_mem);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_aif_mode__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("bit_0 -- AIF Enable (1), AIF in Bypass (0)\n");
   printf("bit_1 -- CVAR: ON (1) - OFF (0)\n");
   printf("bit_2 -- Delay: ON (1) - OFF (0)\n");
   printf("bit_3 -- MDAC F-EQ: ON (1) - OFF (0)\n");
   printf("bit_4 -- DCO: ON (1) - OFF (0)\n");
   printf("bit_5 -- Notch: ON (1) - OFF (0)\n");
   printf("bit_6 -- DCO_THR: ON (1) - OFF (0)\n");
   printf("bit_7 -- AGC_LA ON (1) - OFF (0)\n");
   printf("bit_8 -- NR_AGC: ON (1) - OFF (0)\n");
   printf("bit_9 -- PN Gain: ON (1) - OFF (0)\n");
   printf("bit_10-- MDAC B-EQ: ON (1) - OFF (0)\n");
   printf("Default:\n");
   printf("0x9 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("0x7FF \n");
}

MOCALIB_CLI_HELP static void mocacli_get_aif_mode_help( void )
{
   printf("Specifies bitmask for the required AIF calibrations\n");

   printf("\nmocap get --aif_mode\n");
}

MOCALIB_CLI_GET static int mocacli_get_aif_mode_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t aif_mode;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_aif_mode_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&aif_mode, 0, sizeof(aif_mode));

      ret = moca_get_aif_mode(handle, &aif_mode);

      if (ret == 0) {
         mocacli_print_aif_mode(&aif_mode);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_aif_mode_help( void )
{
   printf("Specifies bitmask for the required AIF calibrations\n");

   printf("\nmocap set --aif_mode <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_aif_mode_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t aif_mode;

   if (handle != NULL)
   {
      ret = moca_get_aif_mode(handle, &aif_mode);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_aif_mode_help();
            mocacli_aif_mode__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &aif_mode);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_aif_mode__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_aif_mode(handle, aif_mode);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_prof_pad_ctrl_deg_6802c0_bonding__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n0xB (BONDING_SUPPORTED)\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("0 \n0xF (BONDING_SUPPORTED)\n");
}

MOCALIB_CLI_HELP static void mocacli_get_prof_pad_ctrl_deg_6802c0_bonding_help( void )
{
   printf("Configures the PAD_CTRL_DEG in 6802C0 for bonded bursts\n");

   printf("\nmocap get --prof_pad_ctrl_deg_6802c0_bonding\n");
}

MOCALIB_CLI_GET static int mocacli_get_prof_pad_ctrl_deg_6802c0_bonding_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t prof_pad_ctrl_deg_6802c0_bonding;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_prof_pad_ctrl_deg_6802c0_bonding_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&prof_pad_ctrl_deg_6802c0_bonding, 0, sizeof(prof_pad_ctrl_deg_6802c0_bonding));

      ret = __moca_get_prof_pad_ctrl_deg_6802c0_bonding(handle, &prof_pad_ctrl_deg_6802c0_bonding);

      if (ret == 0) {
         mocacli_print_prof_pad_ctrl_deg_6802c0_bonding(&prof_pad_ctrl_deg_6802c0_bonding);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_prof_pad_ctrl_deg_6802c0_bonding_help( void )
{
   printf("Configures the PAD_CTRL_DEG in 6802C0 for bonded bursts\n");

   printf("\nmocap set --prof_pad_ctrl_deg_6802c0_bonding <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_prof_pad_ctrl_deg_6802c0_bonding_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t prof_pad_ctrl_deg_6802c0_bonding;

   if (handle != NULL)
   {
      ret = __moca_get_prof_pad_ctrl_deg_6802c0_bonding(handle, &prof_pad_ctrl_deg_6802c0_bonding);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_prof_pad_ctrl_deg_6802c0_bonding_help();
            mocacli_prof_pad_ctrl_deg_6802c0_bonding__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &prof_pad_ctrl_deg_6802c0_bonding);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_prof_pad_ctrl_deg_6802c0_bonding__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_prof_pad_ctrl_deg_6802c0_bonding(handle, prof_pad_ctrl_deg_6802c0_bonding);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_prop_bonding_compatibility_mode__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = Normal operation. \n");
   printf("1 = Switch automatically between primary and secondary seed and LO when a mismatch is detected. \n");
   printf("2 = Force backward compatibility on secondary channel seed and LO.\n");
   printf("Default:\n");
   printf("0 \n0 (BONDING_SUPPORTED)\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("0 \n2 (BONDING_SUPPORTED)\n");
}

MOCALIB_CLI_HELP static void mocacli_get_prop_bonding_compatibility_mode_help( void )
{
   printf("(Proprietary mode) Align secondary channel LO & seed to 2.10.6.x mode.\n");

   printf("\nmocap get --prop_bonding_compatibility_mode\n");
}

MOCALIB_CLI_GET static int mocacli_get_prop_bonding_compatibility_mode_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t prop_bonding_compatibility_mode;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_prop_bonding_compatibility_mode_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&prop_bonding_compatibility_mode, 0, sizeof(prop_bonding_compatibility_mode));

      ret = moca_get_prop_bonding_compatibility_mode(handle, &prop_bonding_compatibility_mode);

      if (ret == 0) {
         mocacli_print_prop_bonding_compatibility_mode(&prop_bonding_compatibility_mode);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_prop_bonding_compatibility_mode_help( void )
{
   printf("(Proprietary mode) Align secondary channel LO & seed to 2.10.6.x mode.\n");

   printf("\nmocap set --prop_bonding_compatibility_mode <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_prop_bonding_compatibility_mode_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t prop_bonding_compatibility_mode;

   if (handle != NULL)
   {
      ret = moca_get_prop_bonding_compatibility_mode(handle, &prop_bonding_compatibility_mode);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_prop_bonding_compatibility_mode_help();
            mocacli_prop_bonding_compatibility_mode__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &prop_bonding_compatibility_mode);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_prop_bonding_compatibility_mode__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_prop_bonding_compatibility_mode(handle, prop_bonding_compatibility_mode);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_rdeg_3450__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0xE \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("0xF \n");
}

MOCALIB_CLI_HELP static void mocacli_get_rdeg_3450_help( void )
{
   printf("Set rdeg 3450 only for chip gen4 types\n");

   printf("\nmocap get --rdeg_3450\n");
}

MOCALIB_CLI_GET static int mocacli_get_rdeg_3450_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t rdeg_3450;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_rdeg_3450_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&rdeg_3450, 0, sizeof(rdeg_3450));

      ret = moca_get_rdeg_3450(handle, &rdeg_3450);

      if (ret == 0) {
         mocacli_print_rdeg_3450(&rdeg_3450);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_rdeg_3450_help( void )
{
   printf("Set rdeg 3450 only for chip gen4 types\n");

   printf("\nmocap set --rdeg_3450 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_rdeg_3450_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t rdeg_3450;

   if (handle != NULL)
   {
      ret = moca_get_rdeg_3450(handle, &rdeg_3450);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_rdeg_3450_help();
            mocacli_rdeg_3450__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &rdeg_3450);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_rdeg_3450__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_rdeg_3450(handle, rdeg_3450);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_phy_clock__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n0 (3390B0)\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("0 \n1000 (3390B0)\n");
}

MOCALIB_CLI_HELP static void mocacli_get_phy_clock_help( void )
{
   printf("Set the phy clock in Mhz for tpcap usage only.\n");

   printf("\nmocap get --phy_clock\n");
}

MOCALIB_CLI_GET static int mocacli_get_phy_clock_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t phy_clock;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_phy_clock_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&phy_clock, 0, sizeof(phy_clock));

      ret = moca_get_phy_clock(handle, &phy_clock);

      if (ret == 0) {
         mocacli_print_phy_clock(&phy_clock);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_phy_clock_help( void )
{
   printf("Set the phy clock in Mhz for tpcap usage only.\n");

   printf("\nmocap set --phy_clock <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_phy_clock_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t phy_clock;

   if (handle != NULL)
   {
      ret = moca_get_phy_clock(handle, &phy_clock);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_phy_clock_help();
            mocacli_phy_clock__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &phy_clock);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_phy_clock__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_phy_clock(handle, phy_clock);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_max_nbas_secondary__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_max_nbas_secondary_help( void )
{

   printf("\nmocap get --max_nbas_secondary\n");
}

MOCALIB_CLI_GET static int mocacli_get_max_nbas_secondary_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t max_nbas_secondary;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_max_nbas_secondary_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&max_nbas_secondary, 0, sizeof(max_nbas_secondary));

      ret = __moca_get_max_nbas_secondary(handle, &max_nbas_secondary);

      if (ret == 0) {
         mocacli_print_max_nbas_secondary(&max_nbas_secondary);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_max_nbas_secondary_help( void )
{

   printf("\nmocap set --max_nbas_secondary <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_max_nbas_secondary_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t max_nbas_secondary;

   if (handle != NULL)
   {
      ret = __moca_get_max_nbas_secondary(handle, &max_nbas_secondary);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_max_nbas_secondary_help();
            mocacli_max_nbas_secondary__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &max_nbas_secondary);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_max_nbas_secondary__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_max_nbas_secondary(handle, max_nbas_secondary);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_mac_addr__val_help(void)
{
   printf("val:\n");
   printf("====\n");
}

MOCALIB_CLI_HELP static void mocacli_get_mac_addr_help( void )
{
   printf("Unique IDentifier (IEEE 48-bit Extended Unique Identifier) of a MoCA Node on the MoCA network. This MAC address is the MAC address of the ONT MoCA interface port.\n");

   printf("\nmocap get --mac_addr\n");
}

MOCALIB_CLI_GET static int mocacli_get_mac_addr_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_mac_addr mac_addr;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_mac_addr_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&mac_addr, 0, sizeof(mac_addr));

      ret = moca_get_mac_addr(handle, &mac_addr);

      if (ret == 0) {
         mocacli_print_mac_addr(&mac_addr);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_mac_addr_help( void )
{
   printf("Unique IDentifier (IEEE 48-bit Extended Unique Identifier) of a MoCA Node on the MoCA network. This MAC address is the MAC address of the ONT MoCA interface port.\n");

   printf("\nmocap set --mac_addr <options>\n");
   printf("options:\n");
   printf("   val   <macaddr, format xx:xx:xx:xx:xx:xx>\n");
}

MOCALIB_CLI_SET static int mocacli_set_mac_addr_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_mac_addr mac_addr;

   if (handle != NULL)
   {
      ret = moca_get_mac_addr(handle, &mac_addr);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "val"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_mac_addr__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_macaddr(*pp_parms, &mac_addr.val);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_mac_addr__val_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_mac_addr_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_mac_addr(handle, &mac_addr);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_get_node_status_help( void )
{
   printf("Retrieve general status information about this MoCA node.\n");

   printf("\nmocap get --node_status\n");
}

MOCALIB_CLI_GET static int mocacli_get_node_status_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_node_status node_status;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_node_status_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&node_status, 0, sizeof(node_status));

      ret = moca_get_node_status(handle, &node_status);

      if (ret == 0) {
         mocacli_print_node_status(&node_status);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_beacon_channel_set__channel_help(void)
{
   printf("channel:\n");
   printf("========\n");
}

MOCALIB_CLI_HELP static void mocacli_set_beacon_channel_set_help( void )
{
   printf("This is part of a user command to change channel (!)This IE is the first step in Channel Selection process.This IE will flag the MoCA Core to prepare for Channel Selection.The process of CS will be initiated by a user CLI/API, and the host function will do:1) Send down this IE MMP message.2) start a MR transaction using the MR_REQUEST command3) After the success of [2] (receive of MR_RESPONSE OK trap) this Assigned Channel number should be stored in NV init_param BEACON_CHANNEL field for future reboots.\n");

   printf("\nmocap set --beacon_channel_set <uint32 channel>\n");
}

MOCALIB_CLI_SET static int mocacli_set_beacon_channel_set_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t beacon_channel_set;

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_beacon_channel_set_help();
            mocacli_beacon_channel_set__channel_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &beacon_channel_set);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_beacon_channel_set__channel_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_beacon_channel_set(handle, beacon_channel_set);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_get_fw_version_help( void )
{
   printf("The MoCA firmware release version\n");

   printf("\nmocap get --fw_version\n");
}

MOCALIB_CLI_GET static int mocacli_get_fw_version_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_fw_version fw_version;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_fw_version_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&fw_version, 0, sizeof(fw_version));

      ret = moca_get_fw_version(handle, &fw_version);

      if (ret == 0) {
         mocacli_print_fw_version(&fw_version);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_max_tx_power_tune__offset_help(void)
{
   printf("offset[86]:\n");
   printf("===========\n");
   printf("\nValues:\n");
   printf("Defaults:\n");
   printf("offset[46..65] = 2\n");
   printf("offset[46..65] = 0 (7425B0)\n");
   printf("offset[46..65] = 0 (7435B0)\n");
   printf("offset[20..25] = 3 (6802C0)\n");
   printf("offset[28..33] = 2 (6802C0)\n");
   printf("offset[39..41] = 1 (6802C0)\n");
   printf("offset[46..65] = 0 (6802C0)\n");
   printf("offset[20..25] = 3 (6803C0)\n");
   printf("offset[28..33] = 2 (6803C0)\n");
   printf("offset[39..41] = 1 (6803C0)\n");
   printf("offset[46..65] = 0 (6803C0)\n");
   printf("offset[46..65] = 0 (7428B0)\n");
   printf("offset[20..25] = 2 (7428B0)\n");
   printf("offset[28..33] = 1 (7428B0)\n");
   printf("offset[20..24] = 6 (28NM)\n");
   printf("offset[25] = 5 (28NM)\n");
   printf("offset[28..33] = 4 (28NM)\n");
   printf("offset[39..41] = 0 (28NM)\n");
   printf("offset[46..65] = 0 (28NM)\n");
   printf("offset[46..65] = 2 (7445D0)\n");
   printf("offset[46..48] = 3 (74371B0)\n");
   printf("offset[49..55] = 4 (74371B0)\n");
   printf(" offset[56..57] = 5 (74371B0)\n");
   printf(" offset[58..60] = 4 (74371B0)\n");
   printf(" offset[61..63] = 3 (74371B0)\n");
   printf(" offset[64..65] = 2 (74371B0)\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("56 \n");
}

MOCALIB_CLI_HELP static void mocacli_max_tx_power_tune__padding_help(void)
{
   printf("padding:\n");
   printf("========\n");
}

MOCALIB_CLI_HELP static void mocacli_get_max_tx_power_tune_help( void )
{
   printf("tx power per frequency\n");

   printf("\nmocap get --max_tx_power_tune\n");
}

MOCALIB_CLI_GET static int mocacli_get_max_tx_power_tune_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_max_tx_power_tune max_tx_power_tune;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_max_tx_power_tune_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&max_tx_power_tune, 0, sizeof(max_tx_power_tune));

      ret = moca_get_max_tx_power_tune(handle, &max_tx_power_tune);

      if (ret == 0) {
         mocacli_print_max_tx_power_tune(&max_tx_power_tune);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_max_tx_power_tune_help( void )
{
   printf("tx power per frequency\n");

   printf("\nmocap set --max_tx_power_tune <options>\n");
   printf("options:\n");
   printf("   padding   <uint16>\n");
   printf("   offset    <int8 value> <index> <end index (optional)>\n");
}

MOCALIB_CLI_SET static int mocacli_set_max_tx_power_tune_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_max_tx_power_tune max_tx_power_tune;

   if (handle != NULL)
   {
      ret = moca_get_max_tx_power_tune(handle, &max_tx_power_tune);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "padding"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_max_tx_power_tune__padding_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint16(*pp_parms, &max_tx_power_tune.padding);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_max_tx_power_tune__padding_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "offset"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_max_tx_power_tune__offset_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_int8_array(&pp_parms, &num_parms, &max_tx_power_tune.offset[0], 25);
            if (ret != 0)
            {
               mocacli_max_tx_power_tune__offset_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_max_tx_power_tune_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_max_tx_power_tune(handle, &max_tx_power_tune);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_max_tx_power_tune_sec_ch__offset_help(void)
{
   printf("offset[86]:\n");
   printf("===========\n");
   printf("\nValues:\n");
   printf("Defaults:\n");
   printf("offset[46..65] = 2\n");
   printf("offset[46..65] = 0 (7425B0)\n");
   printf("offset[46..65] = 0 (7435B0)\n");
   printf("offset[20..25] = 3 (6802C0)\n");
   printf("offset[28..33] = 2 (6802C0)\n");
   printf("offset[39..41] = 1 (6802C0)\n");
   printf("offset[46..65] = 0 (6802C0)\n");
   printf("offset[20..25] = 3 (6803C0)\n");
   printf("offset[28..33] = 2 (6803C0)\n");
   printf("offset[39..41] = 1 (6803C0)\n");
   printf("offset[46..65] = 0 (6803C0)\n");
   printf("offset[46..65] = 0 (7428B0)\n");
   printf("offset[20..25] = 2 (7428B0)\n");
   printf("offset[28..33] = 1 (7428B0)\n");
   printf("offset[20..24] = 6 (28NM)\n");
   printf("offset[25] = 5 (28NM)\n");
   printf("offset[28..33] = 4 (28NM)\n");
   printf("offset[39..41] = 0 (28NM)\n");
   printf("offset[46..65] = 0 (28NM)\n");
   printf("offset[46..65] = 2 (7445D0)\n");
   printf("offset[46..48] = 3 (74371B0)\n");
   printf("offset[49..55] = 4 (74371B0)\n");
   printf(" offset[56..57] = 5 (74371B0)\n");
   printf(" offset[58..60] = 4 (74371B0)\n");
   printf(" offset[61..63] = 3 (74371B0)\n");
   printf(" offset[64..65] = 2 (74371B0)\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("56 \n");
}

MOCALIB_CLI_HELP static void mocacli_max_tx_power_tune_sec_ch__padding_help(void)
{
   printf("padding:\n");
   printf("========\n");
}

MOCALIB_CLI_HELP static void mocacli_get_max_tx_power_tune_sec_ch_help( void )
{
   printf("tx power per frequency\n");

   printf("\nmocap get --max_tx_power_tune_sec_ch\n");
}

MOCALIB_CLI_GET static int mocacli_get_max_tx_power_tune_sec_ch_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_max_tx_power_tune_sec_ch max_tx_power_tune_sec_ch;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_max_tx_power_tune_sec_ch_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&max_tx_power_tune_sec_ch, 0, sizeof(max_tx_power_tune_sec_ch));

      ret = moca_get_max_tx_power_tune_sec_ch(handle, &max_tx_power_tune_sec_ch);

      if (ret == 0) {
         mocacli_print_max_tx_power_tune_sec_ch(&max_tx_power_tune_sec_ch);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_max_tx_power_tune_sec_ch_help( void )
{
   printf("tx power per frequency\n");

   printf("\nmocap set --max_tx_power_tune_sec_ch <options>\n");
   printf("options:\n");
   printf("   padding   <uint16>\n");
   printf("   offset    <int8 value> <index> <end index (optional)>\n");
}

MOCALIB_CLI_SET static int mocacli_set_max_tx_power_tune_sec_ch_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_max_tx_power_tune_sec_ch max_tx_power_tune_sec_ch;

   if (handle != NULL)
   {
      ret = moca_get_max_tx_power_tune_sec_ch(handle, &max_tx_power_tune_sec_ch);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "padding"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_max_tx_power_tune_sec_ch__padding_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint16(*pp_parms, &max_tx_power_tune_sec_ch.padding);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_max_tx_power_tune_sec_ch__padding_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "offset"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_max_tx_power_tune_sec_ch__offset_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_int8_array(&pp_parms, &num_parms, &max_tx_power_tune_sec_ch.offset[0], 25);
            if (ret != 0)
            {
               mocacli_max_tx_power_tune_sec_ch__offset_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_max_tx_power_tune_sec_ch_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_max_tx_power_tune_sec_ch(handle, &max_tx_power_tune_sec_ch);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_rx_power_tune__offset_help(void)
{
   printf("offset[86]:\n");
   printf("===========\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("-120 \n");
   printf("Maximum:\n");
   printf("120 \n");
}

MOCALIB_CLI_HELP static void mocacli_rx_power_tune__padding_help(void)
{
   printf("padding:\n");
   printf("========\n");
}

MOCALIB_CLI_HELP static void mocacli_get_rx_power_tune_help( void )
{
   printf("rx power tuning per frequency\n");

   printf("\nmocap get --rx_power_tune\n");
}

MOCALIB_CLI_GET static int mocacli_get_rx_power_tune_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_rx_power_tune rx_power_tune;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_rx_power_tune_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&rx_power_tune, 0, sizeof(rx_power_tune));

      ret = moca_get_rx_power_tune(handle, &rx_power_tune);

      if (ret == 0) {
         mocacli_print_rx_power_tune(&rx_power_tune);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_rx_power_tune_help( void )
{
   printf("rx power tuning per frequency\n");

   printf("\nmocap set --rx_power_tune <options>\n");
   printf("options:\n");
   printf("   padding   <uint16>\n");
   printf("   offset    <int8 value> <index> <end index (optional)>\n");
}

MOCALIB_CLI_SET static int mocacli_set_rx_power_tune_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_rx_power_tune rx_power_tune;

   if (handle != NULL)
   {
      ret = moca_get_rx_power_tune(handle, &rx_power_tune);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "padding"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_rx_power_tune__padding_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint16(*pp_parms, &rx_power_tune.padding);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_rx_power_tune__padding_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "offset"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_rx_power_tune__offset_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_int8_array(&pp_parms, &num_parms, &rx_power_tune.offset[0], 25);
            if (ret != 0)
            {
               mocacli_rx_power_tune__offset_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_rx_power_tune_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_rx_power_tune(handle, &rx_power_tune);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_mocad_forwarding_rx_mac__mac_addr_help(void)
{
   printf("mac_addr:\n");
   printf("=========\n");
   printf("MAC address to filter on\n");
}

MOCALIB_CLI_HELP static void mocacli_set_mocad_forwarding_rx_mac_help( void )
{
   printf("Forward packets to mocad\n\n");

   printf("\nmocap set --mocad_forwarding_rx_mac <macaddr mac_addr>\n");
}

MOCALIB_CLI_SET static int mocacli_set_mocad_forwarding_rx_mac_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   macaddr_t mocad_forwarding_rx_mac;

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_mocad_forwarding_rx_mac_help();
            mocacli_mocad_forwarding_rx_mac__mac_addr_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_macaddr(*pp_parms, &mocad_forwarding_rx_mac);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_mocad_forwarding_rx_mac__mac_addr_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_mocad_forwarding_rx_mac(handle, &mocad_forwarding_rx_mac);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_impedance_mode_bonding__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n0x3C3 (BONDING_SUPPORTED)\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("0 \n0xFFF (BONDING_SUPPORTED)\n");
}

MOCALIB_CLI_HELP static void mocacli_get_impedance_mode_bonding_help( void )
{
   printf("Bonding impedance setting - Bonding[9..11], Secondary[4..7], Primary[0..3]\n");
   printf("||        Bonding        ||       Phy1 burst        ||         Phy0 burst      ||\n");
   printf("||   Phy 1   |   Phy 0   ||   Phy 1   |     Phy 0   ||     Phy 1   |   Phy 0   ||\n");
   printf("||c1_on|c0_on|c1_on|c0_on||c1_on|c0_on|c1_off|c0_off||c1_off|c0_off|c1_on|c0_on||\n");

   printf("\nmocap get --impedance_mode_bonding\n");
}

MOCALIB_CLI_GET static int mocacli_get_impedance_mode_bonding_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t impedance_mode_bonding;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_impedance_mode_bonding_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&impedance_mode_bonding, 0, sizeof(impedance_mode_bonding));

      ret = moca_get_impedance_mode_bonding(handle, &impedance_mode_bonding);

      if (ret == 0) {
         mocacli_print_impedance_mode_bonding(&impedance_mode_bonding);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_impedance_mode_bonding_help( void )
{
   printf("Bonding impedance setting - Bonding[9..11], Secondary[4..7], Primary[0..3]\n");
   printf("||        Bonding        ||       Phy1 burst        ||         Phy0 burst      ||\n");
   printf("||   Phy 1   |   Phy 0   ||   Phy 1   |     Phy 0   ||     Phy 1   |   Phy 0   ||\n");
   printf("||c1_on|c0_on|c1_on|c0_on||c1_on|c0_on|c1_off|c0_off||c1_off|c0_off|c1_on|c0_on||\n");

   printf("\nmocap set --impedance_mode_bonding <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_impedance_mode_bonding_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t impedance_mode_bonding;

   if (handle != NULL)
   {
      ret = moca_get_impedance_mode_bonding(handle, &impedance_mode_bonding);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_impedance_mode_bonding_help();
            mocacli_impedance_mode_bonding__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &impedance_mode_bonding);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_impedance_mode_bonding__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_impedance_mode_bonding(handle, impedance_mode_bonding);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_rework_6802__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 (BONDING_SUPPORTED)\n0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_rework_6802_help( void )
{
   printf("Mark whether the board is 6802 rework (0-normal, 1-rework)\n");

   printf("\nmocap get --rework_6802\n");
}

MOCALIB_CLI_GET static int mocacli_get_rework_6802_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t rework_6802;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_rework_6802_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&rework_6802, 0, sizeof(rework_6802));

      ret = moca_get_rework_6802(handle, &rework_6802);

      if (ret == 0) {
         mocacli_print_rework_6802(&rework_6802);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_rework_6802_help( void )
{
   printf("Mark whether the board is 6802 rework (0-normal, 1-rework)\n");

   printf("\nmocap set --rework_6802 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_rework_6802_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t rework_6802;

   if (handle != NULL)
   {
      ret = moca_get_rework_6802(handle, &rework_6802);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_rework_6802_help();
            mocacli_rework_6802__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &rework_6802);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_rework_6802__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_rework_6802(handle, rework_6802);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_prof_pad_ctrl_deg_6802c0_single__offset_help(void)
{
   printf("offset[86]:\n");
   printf("===========\n");
   printf("\nValues:\n");
   printf("Defaults:\n");
   printf("offset[46..53] = 11 (6802C0)\n");
   printf("offset[54..65] = 11 (6802C0)\n");
   printf("Default:\n");
   printf("0xB \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("0xF \n");
}

MOCALIB_CLI_HELP static void mocacli_prof_pad_ctrl_deg_6802c0_single__padding_help(void)
{
   printf("padding:\n");
   printf("========\n");
}

MOCALIB_CLI_HELP static void mocacli_get_prof_pad_ctrl_deg_6802c0_single_help( void )
{
   printf("Configures the PAD_CTRL_DEG in 6802C0 for single bursts\n");

   printf("\nmocap get --prof_pad_ctrl_deg_6802c0_single\n");
}

MOCALIB_CLI_GET static int mocacli_get_prof_pad_ctrl_deg_6802c0_single_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_prof_pad_ctrl_deg_6802c0_single prof_pad_ctrl_deg_6802c0_single;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_prof_pad_ctrl_deg_6802c0_single_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&prof_pad_ctrl_deg_6802c0_single, 0, sizeof(prof_pad_ctrl_deg_6802c0_single));

      ret = __moca_get_prof_pad_ctrl_deg_6802c0_single(handle, &prof_pad_ctrl_deg_6802c0_single);

      if (ret == 0) {
         mocacli_print_prof_pad_ctrl_deg_6802c0_single(&prof_pad_ctrl_deg_6802c0_single);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_prof_pad_ctrl_deg_6802c0_single_help( void )
{
   printf("Configures the PAD_CTRL_DEG in 6802C0 for single bursts\n");

   printf("\nmocap set --prof_pad_ctrl_deg_6802c0_single <options>\n");
   printf("options:\n");
   printf("   padding   <uint16>\n");
   printf("   offset    <int8 value> <index> <end index (optional)>\n");
}

MOCALIB_CLI_SET static int mocacli_set_prof_pad_ctrl_deg_6802c0_single_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_prof_pad_ctrl_deg_6802c0_single prof_pad_ctrl_deg_6802c0_single;

   if (handle != NULL)
   {
      ret = __moca_get_prof_pad_ctrl_deg_6802c0_single(handle, &prof_pad_ctrl_deg_6802c0_single);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "padding"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_prof_pad_ctrl_deg_6802c0_single__padding_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint16(*pp_parms, &prof_pad_ctrl_deg_6802c0_single.padding);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_prof_pad_ctrl_deg_6802c0_single__padding_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "offset"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_prof_pad_ctrl_deg_6802c0_single__offset_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_int8_array(&pp_parms, &num_parms, &prof_pad_ctrl_deg_6802c0_single.offset[0], 25);
            if (ret != 0)
            {
               mocacli_prof_pad_ctrl_deg_6802c0_single__offset_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_prof_pad_ctrl_deg_6802c0_single_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = __moca_set_prof_pad_ctrl_deg_6802c0_single(handle, &prof_pad_ctrl_deg_6802c0_single);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_start_help( void )
{
   printf("Instruct the MoCA daemon to load and start the MoCA core.\n");

   printf("\nmocap set --start\n");
}

MOCALIB_CLI_SET static int mocacli_set_start_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;


   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_set_start_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   if (handle != NULL)
   {
      ret = moca_set_start(handle);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_stop_help( void )
{
   printf("Instruct the MoCA daemon to stop the MoCA core.\n");

   printf("\nmocap set --stop\n");
}

MOCALIB_CLI_SET static int mocacli_set_stop_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;


   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_set_stop_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   if (handle != NULL)
   {
      ret = moca_set_stop(handle);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_drv_info__reset_stats_help(void)
{
   printf("reset_stats:\n");
   printf("============\n");
   printf("Reset the statistics fields following the read.\n");
   printf("\nValues:\n");
   printf("0 = Don't reset the statistics \n");
   printf("1 = Reset the statistics\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_drv_info_help( void )
{

   printf("\nmocap get --drv_info <uint32 reset_stats>\n");
}

MOCALIB_CLI_GET static int mocacli_get_drv_info_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_drv_info drv_info;
   uint32_t reset_stats = MOCA_DRV_INFO_DEF;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_drv_info_help();
      mocacli_drv_info__reset_stats_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_drv_info__reset_stats_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &reset_stats);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_drv_info__reset_stats_help();
               return(ret);
            }
         }
   }


   if (handle != NULL)
   {
      memset(&drv_info, 0, sizeof(drv_info));

      ret = moca_get_drv_info(handle, reset_stats, &drv_info);

      if (ret == 0) {
         mocacli_print_drv_info(&drv_info);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_en_capable__enable_help(void)
{
   printf("enable:\n");
   printf("=======\n");
   printf("Default:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_en_capable_help( void )
{

   printf("\nmocap get --en_capable\n");
}

MOCALIB_CLI_GET static int mocacli_get_en_capable_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t en_capable;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_en_capable_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&en_capable, 0, sizeof(en_capable));

      ret = moca_get_en_capable(handle, &en_capable);

      if (ret == 0) {
         mocacli_print_en_capable(&en_capable);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_en_capable_help( void )
{

   printf("\nmocap set --en_capable <uint32 enable>\n");
}

MOCALIB_CLI_SET static int mocacli_set_en_capable_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t en_capable;

   if (handle != NULL)
   {
      ret = moca_get_en_capable(handle, &en_capable);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_en_capable_help();
            mocacli_en_capable__enable_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &en_capable);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_en_capable__enable_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_en_capable(handle, en_capable);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_restore_defaults_help( void )
{

   printf("\nmocap set --restore_defaults\n");
}

MOCALIB_CLI_SET static int mocacli_set_restore_defaults_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;


   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_set_restore_defaults_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   if (handle != NULL)
   {
      ret = moca_set_restore_defaults(handle);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_get_mocad_version_help( void )
{
   printf("The mocad release version\n");

   printf("\nmocap get --mocad_version\n");
}

MOCALIB_CLI_GET static int mocacli_get_mocad_version_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_mocad_version mocad_version;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_mocad_version_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&mocad_version, 0, sizeof(mocad_version));

      ret = moca_get_mocad_version(handle, &mocad_version);

      if (ret == 0) {
         mocacli_print_mocad_version(&mocad_version);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_restart_help( void )
{
   printf("Instruct the MoCA daemon to restart the MoCA core.\n");

   printf("\nmocap set --restart\n");
}

MOCALIB_CLI_SET static int mocacli_set_restart_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;


   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_set_restart_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   if (handle != NULL)
   {
      ret = moca_set_restart(handle);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_lof_update__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = disable \n");
   printf("1 = enable\n");
   printf("Default:\n");
   printf("1 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_lof_update_help( void )
{
   printf("This parameter controls whether the LOF is updated when joining a network. If set to 'enabled' the LOF will be updated to the channel of the network that this node is currently linked on. If set to 'disabled' the LOF will not be updated.\n");

   printf("\nmocap get --lof_update\n");
}

MOCALIB_CLI_GET static int mocacli_get_lof_update_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t lof_update;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_lof_update_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&lof_update, 0, sizeof(lof_update));

      ret = moca_get_lof_update(handle, &lof_update);

      if (ret == 0) {
         mocacli_print_lof_update(&lof_update);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_lof_update_help( void )
{
   printf("This parameter controls whether the LOF is updated when joining a network. If set to 'enabled' the LOF will be updated to the channel of the network that this node is currently linked on. If set to 'disabled' the LOF will not be updated.\n");

   printf("\nmocap set --lof_update <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_lof_update_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t lof_update;

   if (handle != NULL)
   {
      ret = moca_get_lof_update(handle, &lof_update);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_lof_update_help();
            mocacli_lof_update__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &lof_update);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_lof_update__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_lof_update(handle, lof_update);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_primary_ch_offset__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("Frequency offset in MHz. Valid values are -25, 0, +25. A setting of 1 instructs firmware to use the default setting based on LOF.\n");
   printf("Default:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_primary_ch_offset_help( void )
{
   printf("For a MoCA 2.0 network, this parameter specifies the frequency offset of the primary channel relative to the beacon channel.This parameter is relevant when the node is NC.\n");

   printf("\nmocap get --primary_ch_offset\n");
}

MOCALIB_CLI_GET static int mocacli_get_primary_ch_offset_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   int32_t primary_ch_offset;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_primary_ch_offset_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&primary_ch_offset, 0, sizeof(primary_ch_offset));

      ret = moca_get_primary_ch_offset(handle, &primary_ch_offset);

      if (ret == 0) {
         mocacli_print_primary_ch_offset(&primary_ch_offset);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_primary_ch_offset_help( void )
{
   printf("For a MoCA 2.0 network, this parameter specifies the frequency offset of the primary channel relative to the beacon channel.This parameter is relevant when the node is NC.\n");

   printf("\nmocap set --primary_ch_offset <int32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_primary_ch_offset_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   int32_t primary_ch_offset;

   if (handle != NULL)
   {
      ret = moca_get_primary_ch_offset(handle, &primary_ch_offset);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_primary_ch_offset_help();
            mocacli_primary_ch_offset__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_int32(*pp_parms, &primary_ch_offset);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_primary_ch_offset__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_primary_ch_offset(handle, primary_ch_offset);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_assertText__assertText_help(void)
{
   printf("assertText:\n");
   printf("===========\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_assertText_help( void )
{

   printf("\nmocap get --assertText\n");
}

MOCALIB_CLI_GET static int mocacli_get_assertText_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t assertText;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_assertText_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&assertText, 0, sizeof(assertText));

      ret = moca_get_assertText(handle, &assertText);

      if (ret == 0) {
         mocacli_print_assertText(&assertText);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_assertText_help( void )
{

   printf("\nmocap set --assertText <uint32 assertText>\n");
}

MOCALIB_CLI_SET static int mocacli_set_assertText_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t assertText;

   if (handle != NULL)
   {
      ret = moca_get_assertText(handle, &assertText);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_assertText_help();
            mocacli_assertText__assertText_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &assertText);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_assertText__assertText_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_assertText(handle, assertText);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_wdog_enable__enable_help(void)
{
   printf("enable:\n");
   printf("=======\n");
   printf("Default:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_wdog_enable_help( void )
{

   printf("\nmocap get --wdog_enable\n");
}

MOCALIB_CLI_GET static int mocacli_get_wdog_enable_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t wdog_enable;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_wdog_enable_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&wdog_enable, 0, sizeof(wdog_enable));

      ret = moca_get_wdog_enable(handle, &wdog_enable);

      if (ret == 0) {
         mocacli_print_wdog_enable(&wdog_enable);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_wdog_enable_help( void )
{

   printf("\nmocap set --wdog_enable <uint32 enable>\n");
}

MOCALIB_CLI_SET static int mocacli_set_wdog_enable_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t wdog_enable;

   if (handle != NULL)
   {
      ret = moca_get_wdog_enable(handle, &wdog_enable);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_wdog_enable_help();
            mocacli_wdog_enable__enable_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &wdog_enable);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_wdog_enable__enable_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_wdog_enable(handle, wdog_enable);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_mr_seq_num__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("Any integer in the range of 0 to 0xFFFF\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("0xFFFF \n");
}

MOCALIB_CLI_HELP static void mocacli_get_mr_seq_num_help( void )
{
   printf("The sequence number used by the MR transaction.\n");

   printf("\nmocap get --mr_seq_num\n");
}

MOCALIB_CLI_GET static int mocacli_get_mr_seq_num_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t mr_seq_num;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_mr_seq_num_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&mr_seq_num, 0, sizeof(mr_seq_num));

      ret = moca_get_mr_seq_num(handle, &mr_seq_num);

      if (ret == 0) {
         mocacli_print_mr_seq_num(&mr_seq_num);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_mr_seq_num_help( void )
{
   printf("The sequence number used by the MR transaction.\n");

   printf("\nmocap set --mr_seq_num <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_mr_seq_num_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t mr_seq_num;

   if (handle != NULL)
   {
      ret = moca_get_mr_seq_num(handle, &mr_seq_num);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_mr_seq_num_help();
            mocacli_mr_seq_num__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &mr_seq_num);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_mr_seq_num__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_mr_seq_num(handle, mr_seq_num);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_secondary_ch_offset__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("Frequency offset in MHz. Valid values are -125, 0, +125. A setting of 1 instructs firmware to use the default value based on LOF.\n");
   printf("Default:\n");
   printf("1 \n125 (BAND_GENERIC)\n");
}

MOCALIB_CLI_HELP static void mocacli_get_secondary_ch_offset_help( void )
{
   printf("For a MoCA 2.0 network, this parameter specifies the frequency offset of the secondary channel relative to the beacon channel in bonded mode.This parameter is relevant when the node is NC.\n");

   printf("\nmocap get --secondary_ch_offset\n");
}

MOCALIB_CLI_GET static int mocacli_get_secondary_ch_offset_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   int32_t secondary_ch_offset;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_secondary_ch_offset_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&secondary_ch_offset, 0, sizeof(secondary_ch_offset));

      ret = moca_get_secondary_ch_offset(handle, &secondary_ch_offset);

      if (ret == 0) {
         mocacli_print_secondary_ch_offset(&secondary_ch_offset);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_secondary_ch_offset_help( void )
{
   printf("For a MoCA 2.0 network, this parameter specifies the frequency offset of the secondary channel relative to the beacon channel in bonded mode.This parameter is relevant when the node is NC.\n");

   printf("\nmocap set --secondary_ch_offset <int32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_secondary_ch_offset_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   int32_t secondary_ch_offset;

   if (handle != NULL)
   {
      ret = moca_get_secondary_ch_offset(handle, &secondary_ch_offset);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_secondary_ch_offset_help();
            mocacli_secondary_ch_offset__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_int32(*pp_parms, &secondary_ch_offset);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_secondary_ch_offset__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_secondary_ch_offset(handle, secondary_ch_offset);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_cof__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("Operating frequency in MHz\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_set_cof_help( void )
{
   printf("Current operating frequency. This parameter sets the LOF for MoCA on the next MoCA start/restart without saving the frequency in NVRAM. This parameter has no 'get' function. The interface_status rf_channel field should be read to obtain the actual operating frequency. Once a link is established, this parameter will have no effect unless it is set again followed by a MoCA start/restart.\n");

   printf("\nmocap set --cof <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_cof_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t cof;

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_cof_help();
            mocacli_cof__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &cof);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_cof__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_cof(handle, cof);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_amp_type__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 -- 3450\n");
   printf("1 -- 3451\n");
   printf("Default:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_amp_type_help( void )
{
   printf("Specifies the revision of PA/LNA. This setting is used if mocad cannotauto-detect (e.g. out-of-date bmoca kernel module)\n");

   printf("\nmocap get --amp_type\n");
}

MOCALIB_CLI_GET static int mocacli_get_amp_type_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t amp_type;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_amp_type_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&amp_type, 0, sizeof(amp_type));

      ret = moca_get_amp_type(handle, &amp_type);

      if (ret == 0) {
         mocacli_print_amp_type(&amp_type);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_amp_type_help( void )
{
   printf("Specifies the revision of PA/LNA. This setting is used if mocad cannotauto-detect (e.g. out-of-date bmoca kernel module)\n");

   printf("\nmocap set --amp_type <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_amp_type_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t amp_type;

   if (handle != NULL)
   {
      ret = moca_get_amp_type(handle, &amp_type);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_amp_type_help();
            mocacli_amp_type__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &amp_type);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_amp_type__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_amp_type(handle, amp_type);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_GET static int mocacli_get_node_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   char **tmpPtr = pp_parms; 
   int nump = num_parms; 
   char pstr[1][MAX_STRING_LENGTH]; 
   char *gOptmp[1]; 

   gOptmp[0] = &pstr[0][0]; 


   while (nump > 0)
   {
      if ((nump != 0) && !strcmp(*tmpPtr, "help"))
      {
         printf("The Node group of parameters contains configurable fields that arespecific to this node.\n");
         printf("IE list for this group: \n"); 
         printf("======================= \n"); 
         printf("preferred_nc\n"); 
         printf("single_channel_operation\n"); 
         printf("continuous_power_tx_mode\n"); 
         printf("continuous_rx_mode_attn\n"); 
         printf("lof\n"); 
         printf("max_nbas_primary\n"); 
         printf("ps_swch_tx1\n"); 
         printf("ps_swch_tx2\n"); 
         printf("ps_swch_rx1\n"); 
         printf("ps_swch_rx2\n"); 
         printf("ps_swch_rx3\n"); 
         printf("bonding\n"); 
         printf("listening_freq_mask\n"); 
         printf("listening_duration\n"); 
         printf("limit_traffic\n"); 
         printf("remote_man\n"); 
         printf("c4_moca20_en\n"); 
         printf("power_save_mechanism_dis\n"); 
         printf("psm_config\n"); 
         printf("use_ext_data_mem\n"); 
         printf("aif_mode\n"); 
         printf("prof_pad_ctrl_deg_6802c0_bonding\n"); 
         printf("prop_bonding_compatibility_mode\n"); 
         printf("rdeg_3450\n"); 
         printf("phy_clock\n"); 
         printf("max_nbas_secondary\n"); 
         printf("mac_addr\n"); 
         printf("node_status\n"); 
         printf("fw_version\n"); 
         printf("max_tx_power_tune\n"); 
         printf("max_tx_power_tune_sec_ch\n"); 
         printf("rx_power_tune\n"); 
         printf("impedance_mode_bonding\n"); 
         printf("rework_6802\n"); 
         printf("prof_pad_ctrl_deg_6802c0_single\n"); 
         printf("drv_info\n"); 
         printf("en_capable\n"); 
         printf("mocad_version\n"); 
         printf("lof_update\n"); 
         printf("primary_ch_offset\n"); 
         printf("assertText\n"); 
         printf("wdog_enable\n"); 
         printf("mr_seq_num\n"); 
         printf("secondary_ch_offset\n"); 
         printf("amp_type\n"); 
         return(0); 
      }
      tmpPtr++;
      nump--;
  }

   if (handle != NULL)
   {
      ret = mocacli_get_preferred_nc_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_single_channel_operation_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_continuous_power_tx_mode_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_continuous_rx_mode_attn_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_lof_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_max_nbas_primary_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_ps_swch_tx1_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_ps_swch_tx2_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_ps_swch_rx1_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_ps_swch_rx2_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_ps_swch_rx3_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_bonding_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_listening_freq_mask_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_listening_duration_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_limit_traffic_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_remote_man_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_c4_moca20_en_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_power_save_mechanism_dis_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_psm_config_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_use_ext_data_mem_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_aif_mode_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_prof_pad_ctrl_deg_6802c0_bonding_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_prop_bonding_compatibility_mode_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_rdeg_3450_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_phy_clock_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_max_nbas_secondary_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_mac_addr_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_node_status_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_fw_version_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_max_tx_power_tune_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_max_tx_power_tune_sec_ch_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_rx_power_tune_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_impedance_mode_bonding_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_rework_6802_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_prof_pad_ctrl_deg_6802c0_single_handler(handle, pp_parms, num_parms );


       sprintf(gOptmp[0],"%d", 0);
       ret = mocacli_get_drv_info_handler(handle, gOptmp, 0);


      ret = mocacli_get_en_capable_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_mocad_version_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_lof_update_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_primary_ch_offset_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_assertText_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_wdog_enable_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_mr_seq_num_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_secondary_ch_offset_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_amp_type_handler(handle, pp_parms, num_parms );

   }
   return(ret);
}

MOCALIB_CLI_PRINT void mocacli_print_tpc_en (uint32_t * in)
{
   printf("tpc_en: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_max_tx_power (int32_t * in)
{
   printf("max_tx_power: 0x%x  ( %d )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_beacon_pwr_reduction (uint32_t * in)
{
   printf("beacon_pwr_reduction: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_beacon_pwr_reduction_en (uint32_t * in)
{
   printf("beacon_pwr_reduction_en: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_bo_mode (uint32_t * in)
{
   printf("bo_mode: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_qam256_capability (uint32_t * in)
{
   printf("qam256_capability: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_otf_en (uint32_t * in)
{
   printf("otf_en: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_star_topology_en (uint32_t * in)
{
   printf("star_topology_en: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_ofdma_en (uint32_t * in)
{
   printf("ofdma_en: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_min_bw_alarm_threshold (uint32_t * in)
{
   printf("min_bw_alarm_threshold: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_target_phy_rate_qam128 (uint32_t * in)
{
   printf("target_phy_rate_qam128: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_target_phy_rate_qam256 (uint32_t * in)
{
   printf("target_phy_rate_qam256: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_sapm_en (uint32_t * in)
{
   printf("sapm_en: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_arpl_th_50 (int32_t * in)
{
   printf("arpl_th_50: 0x%x  ( %d )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_rlapm_en (uint32_t * in)
{
   printf("rlapm_en: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_freq_shift (uint32_t * in)
{
   printf("freq_shift: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_max_phy_rate (uint32_t * in)
{
   printf("max_phy_rate: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_bandwidth (uint32_t * in)
{
   printf("bandwidth: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_arpl_th_100 (int32_t * in)
{
   printf("arpl_th_100: 0x%x  ( %d )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_adc_mode (uint32_t * in)
{
   printf("adc_mode: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_max_phy_rate_turbo (uint32_t * in)
{
   printf("max_phy_rate_turbo: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_cp_const (uint32_t * in)
{
   printf("cp_const: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_preamble_uc_const (uint32_t * in)
{
   printf("preamble_uc_const: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_cp_margin_increase (uint32_t * in)
{
   printf("cp_margin_increase: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_ac_cc_shift (uint32_t * in)
{
   printf("ac_cc_shift: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_mfc_th_increase (uint32_t * in)
{
   printf("mfc_th_increase: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_agc_const_en (uint32_t * in)
{
   printf("agc_const_en: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_agc_const_address (uint32_t * in)
{
   printf("agc_const_address: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_min_bo_insert_2_bfm_lock (uint32_t * in)
{
   printf("min_bo_insert_2_bfm_lock: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_min_snr_avg_db_2_bfm_lock (uint32_t * in)
{
   printf("min_snr_avg_db_2_bfm_lock: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_max_phy_rate_50M (uint32_t * in)
{
   printf("max_phy_rate_50M: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_max_constellation_all (uint32_t * in)
{
   printf("max_constellation_all: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_max_constellation (struct moca_max_constellation * in)
{
   printf("== max_constellation ");
   printf(" ================================= \n");
   printf("node_id      : %u  ( 0x%x )\n", in->node_id, in->node_id);
   printf("p2p_limit_50 : %u  ( 0x%x )\n", in->p2p_limit_50, in->p2p_limit_50);
   printf("gcd_limit_50 : %u  ( 0x%x )\n", in->gcd_limit_50, in->gcd_limit_50);
   printf("p2p_limit_100: %u  ( 0x%x )\n", in->p2p_limit_100, in->p2p_limit_100);
   printf("gcd_limit_100: %u  ( 0x%x )\n", in->gcd_limit_100, in->gcd_limit_100);
   printf("== end max_constellation ");
   printf(" ============================= \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_snr_margin_table_rs (struct moca_snr_margin_table_rs * in)
{
   uint32_t i;

   printf("snr_margin_table_rs: ");
   for (i = 0; i < 22; i++) {
      printf("%d.%03d ", in->mgntable[i]>>8, (in->mgntable[i]&0xFF)*1000/256);
   }
   printf("\n");
}

MOCALIB_CLI_PRINT void mocacli_print_rlapm_table_50 (struct moca_rlapm_table_50 * in)
{
   uint32_t i;

   printf("== rlapm_table_50 ");
   printf(" ==================================== \n");
   printf("rlapmtable[66]: ");
   for (i = 0; i < 66; i++) {
      printf("%02x ", in->rlapmtable[i]);
      if (i % 8 == 7) printf("\n                ");
   }
   printf("\n");
   printf("== end rlapm_table_50 ");
   printf(" ================================ \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_phy_status (uint32_t * in)
{
   printf("phy_status: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_snr_margin_table_ldpc (struct moca_snr_margin_table_ldpc * in)
{
   uint32_t i;

   printf("snr_margin_table_ldpc: ");
   for (i = 0; i < 22; i++) {
      printf("%d.%03d ", in->mgntable[i]>>8, (in->mgntable[i]&0xFF)*1000/256);
   }
   printf("\n");
}

MOCALIB_CLI_PRINT void mocacli_print_snr_margin_table_ldpc_sec_ch (struct moca_snr_margin_table_ldpc_sec_ch * in)
{
   uint32_t i;

   printf("snr_margin_table_ldpc_sec_ch: ");
   for (i = 0; i < 22; i++) {
      printf("%d.%03d ", in->mgntable[i]>>8, (in->mgntable[i]&0xFF)*1000/256);
   }
   printf("\n");
}

MOCALIB_CLI_PRINT void mocacli_print_snr_margin_table_ldpc_pre5 (struct moca_snr_margin_table_ldpc_pre5 * in)
{
   uint32_t i;

   printf("snr_margin_table_ldpc_pre5: ");
   for (i = 0; i < 22; i++) {
      printf("%d.%03d ", in->mgntable[i]>>8, (in->mgntable[i]&0xFF)*1000/256);
   }
   printf("\n");
}

MOCALIB_CLI_PRINT void mocacli_print_snr_margin_table_ofdma (struct moca_snr_margin_table_ofdma * in)
{
   uint32_t i;

   printf("snr_margin_table_ofdma: ");
   for (i = 0; i < 22; i++) {
      printf("%d.%03d ", in->mgntable[i]>>8, (in->mgntable[i]&0xFF)*1000/256);
   }
   printf("\n");
}

MOCALIB_CLI_PRINT void mocacli_print_rlapm_table_100 (struct moca_rlapm_table_100 * in)
{
   uint32_t i;

   printf("== rlapm_table_100 ");
   printf(" =================================== \n");
   printf("rlapmtable[66]: ");
   for (i = 0; i < 66; i++) {
      printf("%02x ", in->rlapmtable[i]);
      if (i % 8 == 7) printf("\n                ");
   }
   printf("\n");
   printf("== end rlapm_table_100 ");
   printf(" =============================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_rx_gain_params (struct moca_rx_gain_params * in)
{
   printf("== rx_gain_params ");
   printf(" ==================================== \n");
   printf("lna_ctrl_reg: %u  ( 0x%x )\n", in->lna_ctrl_reg, in->lna_ctrl_reg);
   printf("is3451      : %u  ( 0x%x )\n", in->is3451, in->is3451);
   printf("== end rx_gain_params ");
   printf(" ================================ \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_rx_gain_agc_table (uint32_t * in, uint32_t num_entries)
{
   uint32_t i;

   for (i = 0; i < num_entries; i++)
   {
      printf("%4d:  |  | 0x%04x    |        |  0x%04x       |  0x%04x         |       0x%04x         |\n",
         i, (*in & 0x1e000) >> 13, (*in & 0x1e00) >> 9, (*in & 0x1c0) >> 6, (*in & 0x3f)  );
      in++;
   }
}

MOCALIB_CLI_PRINT void mocacli_print_tx_power_params (struct moca_tx_power_params * in)
{
   uint32_t i;

   printf("== tx_power_params ");
   printf(" =================================== \n");
   printf("channelMode        : %u  ( 0x%x )\n", in->channelMode, in->channelMode);
   printf("channel            : %u  ( 0x%x )\n", in->channel, in->channel);
   printf("user_reduce_power  : %u  ( 0x%x )\n", in->user_reduce_power, in->user_reduce_power);
   printf("channel_reduce_tune: %u  ( 0x%x )\n", in->channel_reduce_tune, in->channel_reduce_tune);
   printf("tx_digital_gain    : %u  ( 0x%x )\n", in->tx_digital_gain, in->tx_digital_gain);
   printf("pad_ctrl_deg       : %u  ( 0x%x )\n", in->pad_ctrl_deg, in->pad_ctrl_deg);
   printf("pa_ctrl_reg        : %u  ( 0x%x )\n", in->pa_ctrl_reg, in->pa_ctrl_reg);
   printf("is3451             : %u  ( 0x%x )\n", in->is3451, in->is3451);
   printf("table_max_index    : %u  ( 0x%x )\n", in->table_max_index, in->table_max_index);
   printf("tx_table[62]       : ");
   for (i = 0; i < 62; i++) {
      printf("0x%04x ", in->tx_table[i]);
      if (i % 8 == 7) printf("\n                     ");
   }
   printf("\n");
   printf("== end tx_power_params ");
   printf(" =============================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_snr_margin_table_ldpc_pri_ch (struct moca_snr_margin_table_ldpc_pri_ch * in)
{
   uint32_t i;

   printf("snr_margin_table_ldpc_pri_ch: ");
   for (i = 0; i < 22; i++) {
      printf("%d.%03d ", in->mgntable[i]>>8, (in->mgntable[i]&0xFF)*1000/256);
   }
   printf("\n");
}

MOCALIB_CLI_PRINT void mocacli_print_snr_margin_table_pre5_pri_ch (struct moca_snr_margin_table_pre5_pri_ch * in)
{
   uint32_t i;

   printf("snr_margin_table_pre5_pri_ch: ");
   for (i = 0; i < 22; i++) {
      printf("%d.%03d ", in->mgntable[i]>>8, (in->mgntable[i]&0xFF)*1000/256);
   }
   printf("\n");
}

MOCALIB_CLI_PRINT void mocacli_print_snr_margin_table_pre5_sec_ch (struct moca_snr_margin_table_pre5_sec_ch * in)
{
   uint32_t i;

   printf("snr_margin_table_pre5_sec_ch: ");
   for (i = 0; i < 22; i++) {
      printf("%d.%03d ", in->mgntable[i]>>8, (in->mgntable[i]&0xFF)*1000/256);
   }
   printf("\n");
}

MOCALIB_CLI_PRINT void mocacli_print_nv_cal_enable (uint32_t * in)
{
   printf("nv_cal_enable: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_rlapm_cap_50 (uint32_t * in)
{
   printf("rlapm_cap_50: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_snr_margin_rs (struct moca_snr_margin_rs * in)
{
   uint32_t i;

   printf("== snr_margin_rs ");
   printf(" ===================================== \n");
   printf("base_margin: %d.%03d \n", in->base_margin>>8, (in->base_margin&0xFF)*1000/256);
   printf("offsets[10]: ");
   for (i = 0; i < 10; i++) {
      printf("%d.%03d ", in->offsets[i]>>8, (in->offsets[i]&0xFF)*1000/256);
   }
   printf("\n");
   printf("== end snr_margin_rs ");
   printf(" ================================= \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_snr_margin_ldpc (struct moca_snr_margin_ldpc * in)
{
   uint32_t i;

   printf("== snr_margin_ldpc ");
   printf(" =================================== \n");
   printf("base_margin: %d.%03d \n", in->base_margin>>8, (in->base_margin&0xFF)*1000/256);
   printf("offsets[10]: ");
   for (i = 0; i < 10; i++) {
      printf("%d.%03d ", in->offsets[i]>>8, (in->offsets[i]&0xFF)*1000/256);
   }
   printf("\n");
   printf("== end snr_margin_ldpc ");
   printf(" =============================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_snr_margin_ldpc_sec_ch (struct moca_snr_margin_ldpc_sec_ch * in)
{
   uint32_t i;

   printf("== snr_margin_ldpc_sec_ch ");
   printf(" ============================ \n");
   printf("base_margin: %d.%03d \n", in->base_margin>>8, (in->base_margin&0xFF)*1000/256);
   printf("offsets[10]: ");
   for (i = 0; i < 10; i++) {
      printf("%d.%03d ", in->offsets[i]>>8, (in->offsets[i]&0xFF)*1000/256);
   }
   printf("\n");
   printf("== end snr_margin_ldpc_sec_ch ");
   printf(" ======================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_snr_margin_ldpc_pre5 (struct moca_snr_margin_ldpc_pre5 * in)
{
   uint32_t i;

   printf("== snr_margin_ldpc_pre5 ");
   printf(" ============================== \n");
   printf("base_margin: %d.%03d \n", in->base_margin>>8, (in->base_margin&0xFF)*1000/256);
   printf("offsets[10]: ");
   for (i = 0; i < 10; i++) {
      printf("%d.%03d ", in->offsets[i]>>8, (in->offsets[i]&0xFF)*1000/256);
   }
   printf("\n");
   printf("== end snr_margin_ldpc_pre5 ");
   printf(" ========================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_snr_margin_ofdma (struct moca_snr_margin_ofdma * in)
{
   uint32_t i;

   printf("== snr_margin_ofdma ");
   printf(" ================================== \n");
   printf("base_margin: %d.%03d \n", in->base_margin>>8, (in->base_margin&0xFF)*1000/256);
   printf("offsets[10]: ");
   for (i = 0; i < 10; i++) {
      printf("%d.%03d ", in->offsets[i]>>8, (in->offsets[i]&0xFF)*1000/256);
   }
   printf("\n");
   printf("== end snr_margin_ofdma ");
   printf(" ============================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_rlapm_cap_100 (uint32_t * in)
{
   printf("rlapm_cap_100: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_sapm_table_50 (struct moca_sapm_table_50 * in)
{
   uint32_t i;

   printf("sapm_table_50: ");
   for (i = 0; i < 256; i++) {
      printf("%02x ", in->val[i]);
      if (i % 8 == 7) printf("\n          ");
   }
   printf("\n");
}

MOCALIB_CLI_PRINT void mocacli_print_sapm_table_100 (struct moca_sapm_table_100 * in)
{
   uint32_t i;

   printf("sapm_table_100: ");
   for (i = 0; i < 512; i++) {
      printf("%02x ", in->val[i]);
      if (i % 8 == 7) printf("\n          ");
   }
   printf("\n");
}

MOCALIB_CLI_PRINT void mocacli_print_sapm_table_sec (struct moca_sapm_table_sec * in)
{
   uint32_t i;

   printf("sapm_table_sec: ");
   for (i = 0; i < 512; i++) {
      printf("%02x ", in->val[i]);
      if (i % 8 == 7) printf("\n          ");
   }
   printf("\n");
}

MOCALIB_CLI_PRINT void mocacli_print_amp_reg (struct moca_amp_reg * in)
{
   printf("== amp_reg ");
   printf(" =========================================== \n");
   printf("addr : 0x%x\n", in->addr);
   printf("value: %u  ( 0x%x )\n", in->value, in->value);
   printf("== end amp_reg ");
   printf(" ======================================= \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_snr_margin_ldpc_pri_ch (struct moca_snr_margin_ldpc_pri_ch * in)
{
   uint32_t i;

   printf("== snr_margin_ldpc_pri_ch ");
   printf(" ============================ \n");
   printf("base_margin: %d.%03d \n", in->base_margin>>8, (in->base_margin&0xFF)*1000/256);
   printf("offsets[10]: ");
   for (i = 0; i < 10; i++) {
      printf("%d.%03d ", in->offsets[i]>>8, (in->offsets[i]&0xFF)*1000/256);
   }
   printf("\n");
   printf("== end snr_margin_ldpc_pri_ch ");
   printf(" ======================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_snr_margin_pre5_pri_ch (struct moca_snr_margin_pre5_pri_ch * in)
{
   uint32_t i;

   printf("== snr_margin_pre5_pri_ch ");
   printf(" ============================ \n");
   printf("base_margin: %d.%03d \n", in->base_margin>>8, (in->base_margin&0xFF)*1000/256);
   printf("offsets[10]: ");
   for (i = 0; i < 10; i++) {
      printf("%d.%03d ", in->offsets[i]>>8, (in->offsets[i]&0xFF)*1000/256);
   }
   printf("\n");
   printf("== end snr_margin_pre5_pri_ch ");
   printf(" ======================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_snr_margin_pre5_sec_ch (struct moca_snr_margin_pre5_sec_ch * in)
{
   uint32_t i;

   printf("== snr_margin_pre5_sec_ch ");
   printf(" ============================ \n");
   printf("base_margin: %d.%03d \n", in->base_margin>>8, (in->base_margin&0xFF)*1000/256);
   printf("offsets[10]: ");
   for (i = 0; i < 10; i++) {
      printf("%d.%03d ", in->offsets[i]>>8, (in->offsets[i]&0xFF)*1000/256);
   }
   printf("\n");
   printf("== end snr_margin_pre5_sec_ch ");
   printf(" ======================== \n\n");
}

MOCALIB_CLI_HELP static void mocacli_tpc_en__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = disable\n");
   printf("1 = enable\n");
   printf("Default:\n");
   printf("1 \n0 (BAND_E)\n0 (BAND_F)\n0 (BAND_H)\n");
}

MOCALIB_CLI_HELP static void mocacli_get_tpc_en_help( void )
{
   printf("Enable Transmit Power Control (TPC).\n");
   printf("When enabled, the transmit power level is adjusted to a setting that will achieve the maximum target PHY bit rate. The adjusted power setting will be less than or equal to 'Tx Power'.\n");
   printf("When disabled, the transmit power level is set to <Tx Power>.\n");

   printf("\nmocap get --tpc_en\n");
}

MOCALIB_CLI_GET static int mocacli_get_tpc_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t tpc_en;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_tpc_en_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&tpc_en, 0, sizeof(tpc_en));

      ret = moca_get_tpc_en(handle, &tpc_en);

      if (ret == 0) {
         mocacli_print_tpc_en(&tpc_en);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_tpc_en_help( void )
{
   printf("Enable Transmit Power Control (TPC).\n");
   printf("When enabled, the transmit power level is adjusted to a setting that will achieve the maximum target PHY bit rate. The adjusted power setting will be less than or equal to 'Tx Power'.\n");
   printf("When disabled, the transmit power level is set to <Tx Power>.\n");

   printf("\nmocap set --tpc_en <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_tpc_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t tpc_en;

   if (handle != NULL)
   {
      ret = moca_get_tpc_en(handle, &tpc_en);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_tpc_en_help();
            mocacli_tpc_en__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &tpc_en);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_tpc_en__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_tpc_en(handle, tpc_en);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_max_tx_power__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("[dBm]\n");
   printf("Default:\n");
   printf("3 \n");
   printf("Minimum:\n");
   printf("-31 \n");
   printf("Maximum:\n");
   printf("3 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_max_tx_power_help( void )
{
   printf("Indicates the max transmitter power level allowed.\n");

   printf("\nmocap get --max_tx_power\n");
}

MOCALIB_CLI_GET static int mocacli_get_max_tx_power_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   int32_t max_tx_power;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_max_tx_power_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&max_tx_power, 0, sizeof(max_tx_power));

      ret = moca_get_max_tx_power(handle, &max_tx_power);

      if (ret == 0) {
         mocacli_print_max_tx_power(&max_tx_power);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_max_tx_power_help( void )
{
   printf("Indicates the max transmitter power level allowed.\n");

   printf("\nmocap set --max_tx_power <int32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_max_tx_power_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   int32_t max_tx_power;

   if (handle != NULL)
   {
      ret = moca_get_max_tx_power(handle, &max_tx_power);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_max_tx_power_help();
            mocacli_max_tx_power__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_int32(*pp_parms, &max_tx_power);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_max_tx_power__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_max_tx_power(handle, max_tx_power);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_beacon_pwr_reduction__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("Value is in 3dB units\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("5 \n0 (BAND_E)\n0 (BAND_F)\n");
}

MOCALIB_CLI_HELP static void mocacli_get_beacon_pwr_reduction_help( void )
{
   printf("Amount of power reduction multiple by 3 for beacons vs other transmissions. \n");
   printf("Beacon power reduction must be disabled for Bands E and F.\n");

   printf("\nmocap get --beacon_pwr_reduction\n");
}

MOCALIB_CLI_GET static int mocacli_get_beacon_pwr_reduction_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t beacon_pwr_reduction;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_beacon_pwr_reduction_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&beacon_pwr_reduction, 0, sizeof(beacon_pwr_reduction));

      ret = moca_get_beacon_pwr_reduction(handle, &beacon_pwr_reduction);

      if (ret == 0) {
         mocacli_print_beacon_pwr_reduction(&beacon_pwr_reduction);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_beacon_pwr_reduction_help( void )
{
   printf("Amount of power reduction multiple by 3 for beacons vs other transmissions. \n");
   printf("Beacon power reduction must be disabled for Bands E and F.\n");

   printf("\nmocap set --beacon_pwr_reduction <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_beacon_pwr_reduction_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t beacon_pwr_reduction;

   if (handle != NULL)
   {
      ret = moca_get_beacon_pwr_reduction(handle, &beacon_pwr_reduction);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_beacon_pwr_reduction_help();
            mocacli_beacon_pwr_reduction__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &beacon_pwr_reduction);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_beacon_pwr_reduction__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_beacon_pwr_reduction(handle, beacon_pwr_reduction);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_beacon_pwr_reduction_en__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = Disable \n");
   printf("1 = Enable\n");
   printf("Default:\n");
   printf("0 (6816)\n0 (BAND_E)\n0 (BAND_F)\n1 (7xxx)\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n0 (BAND_E)\n0 (BAND_F)\n");
}

MOCALIB_CLI_HELP static void mocacli_get_beacon_pwr_reduction_en_help( void )
{
   printf("Enable/Disable BEACON_PWR_REDUCTION. \n");
   printf("Beacon power reduction must be disabled for Bands E and F.\n");

   printf("\nmocap get --beacon_pwr_reduction_en\n");
}

MOCALIB_CLI_GET static int mocacli_get_beacon_pwr_reduction_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t beacon_pwr_reduction_en;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_beacon_pwr_reduction_en_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&beacon_pwr_reduction_en, 0, sizeof(beacon_pwr_reduction_en));

      ret = moca_get_beacon_pwr_reduction_en(handle, &beacon_pwr_reduction_en);

      if (ret == 0) {
         mocacli_print_beacon_pwr_reduction_en(&beacon_pwr_reduction_en);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_beacon_pwr_reduction_en_help( void )
{
   printf("Enable/Disable BEACON_PWR_REDUCTION. \n");
   printf("Beacon power reduction must be disabled for Bands E and F.\n");

   printf("\nmocap set --beacon_pwr_reduction_en <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_beacon_pwr_reduction_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t beacon_pwr_reduction_en;

   if (handle != NULL)
   {
      ret = moca_get_beacon_pwr_reduction_en(handle, &beacon_pwr_reduction_en);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_beacon_pwr_reduction_en_help();
            mocacli_beacon_pwr_reduction_en__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &beacon_pwr_reduction_en);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_beacon_pwr_reduction_en__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_beacon_pwr_reduction_en(handle, beacon_pwr_reduction_en);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_bo_mode__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = Fast B.O. convergence \n");
   printf("1 = slow convergence to final Back Off. Better noise immunity during Admission\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_bo_mode_help( void )
{
   printf("This flag enables two modes of operation, introducing tradeoff between fast Back Off convergence and better noise robustness of the system.\n");

   printf("\nmocap get --bo_mode\n");
}

MOCALIB_CLI_GET static int mocacli_get_bo_mode_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t bo_mode;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_bo_mode_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&bo_mode, 0, sizeof(bo_mode));

      ret = moca_get_bo_mode(handle, &bo_mode);

      if (ret == 0) {
         mocacli_print_bo_mode(&bo_mode);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_bo_mode_help( void )
{
   printf("This flag enables two modes of operation, introducing tradeoff between fast Back Off convergence and better noise robustness of the system.\n");

   printf("\nmocap set --bo_mode <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_bo_mode_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t bo_mode;

   if (handle != NULL)
   {
      ret = moca_get_bo_mode(handle, &bo_mode);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_bo_mode_help();
            mocacli_bo_mode__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &bo_mode);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_bo_mode__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_bo_mode(handle, bo_mode);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_qam256_capability__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = Disable \n");
   printf("1 = Enable (normal mode)\n");
   printf("Default:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_qam256_capability_help( void )
{
   printf("This fields specifies the QAM256 ability in Admission Res/Req negotiations (NODE_PROTOCOL_SUPPORT field).\n");

   printf("\nmocap get --qam256_capability\n");
}

MOCALIB_CLI_GET static int mocacli_get_qam256_capability_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t qam256_capability;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_qam256_capability_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&qam256_capability, 0, sizeof(qam256_capability));

      ret = moca_get_qam256_capability(handle, &qam256_capability);

      if (ret == 0) {
         mocacli_print_qam256_capability(&qam256_capability);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_qam256_capability_help( void )
{
   printf("This fields specifies the QAM256 ability in Admission Res/Req negotiations (NODE_PROTOCOL_SUPPORT field).\n");

   printf("\nmocap set --qam256_capability <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_qam256_capability_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t qam256_capability;

   if (handle != NULL)
   {
      ret = moca_get_qam256_capability(handle, &qam256_capability);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_qam256_capability_help();
            mocacli_qam256_capability__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &qam256_capability);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_qam256_capability__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_qam256_capability(handle, qam256_capability);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_otf_en__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = Disable \n");
   printf("1 = Enable\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_otf_en_help( void )
{
   printf("Enables/Disables On The Fly calibration. \n");
   printf("This feature calibrates the Tx Power periodically, and is used for overcoming max power change in temperatures.\n");

   printf("\nmocap get --otf_en\n");
}

MOCALIB_CLI_GET static int mocacli_get_otf_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t otf_en;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_otf_en_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&otf_en, 0, sizeof(otf_en));

      ret = moca_get_otf_en(handle, &otf_en);

      if (ret == 0) {
         mocacli_print_otf_en(&otf_en);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_otf_en_help( void )
{
   printf("Enables/Disables On The Fly calibration. \n");
   printf("This feature calibrates the Tx Power periodically, and is used for overcoming max power change in temperatures.\n");

   printf("\nmocap set --otf_en <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_otf_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t otf_en;

   if (handle != NULL)
   {
      ret = moca_get_otf_en(handle, &otf_en);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_otf_en_help();
            mocacli_otf_en__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &otf_en);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_otf_en__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_otf_en(handle, otf_en);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_star_topology_en__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = Disable \n");
   printf("1 = Enable\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_star_topology_en_help( void )
{
   printf("Enable support for star topology, which allows new nodes to admit to a network as long as the link to the NC is usable. The channel between ENs does not need to be usable in this mode.\n");

   printf("\nmocap get --star_topology_en\n");
}

MOCALIB_CLI_GET static int mocacli_get_star_topology_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t star_topology_en;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_star_topology_en_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&star_topology_en, 0, sizeof(star_topology_en));

      ret = moca_get_star_topology_en(handle, &star_topology_en);

      if (ret == 0) {
         mocacli_print_star_topology_en(&star_topology_en);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_star_topology_en_help( void )
{
   printf("Enable support for star topology, which allows new nodes to admit to a network as long as the link to the NC is usable. The channel between ENs does not need to be usable in this mode.\n");

   printf("\nmocap set --star_topology_en <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_star_topology_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t star_topology_en;

   if (handle != NULL)
   {
      ret = moca_get_star_topology_en(handle, &star_topology_en);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_star_topology_en_help();
            mocacli_star_topology_en__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &star_topology_en);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_star_topology_en__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_star_topology_en(handle, star_topology_en);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_ofdma_en__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = Disable \n");
   printf("1 = Enable\n");
   printf("Default:\n");
   printf("1 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_ofdma_en_help( void )
{
   printf("Enable support for OFDMA PHY Frames\n");

   printf("\nmocap get --ofdma_en\n");
}

MOCALIB_CLI_GET static int mocacli_get_ofdma_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t ofdma_en;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_ofdma_en_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&ofdma_en, 0, sizeof(ofdma_en));

      ret = moca_get_ofdma_en(handle, &ofdma_en);

      if (ret == 0) {
         mocacli_print_ofdma_en(&ofdma_en);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_ofdma_en_help( void )
{
   printf("Enable support for OFDMA PHY Frames\n");

   printf("\nmocap set --ofdma_en <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_ofdma_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t ofdma_en;

   if (handle != NULL)
   {
      ret = moca_get_ofdma_en(handle, &ofdma_en);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_ofdma_en_help();
            mocacli_ofdma_en__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &ofdma_en);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_ofdma_en__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_ofdma_en(handle, ofdma_en);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_min_bw_alarm_threshold__mbps_help(void)
{
   printf("mbps:\n");
   printf("=====\n");
   printf("\nValues:\n");
   printf("0 = threshold disabled\n");
   printf("otherwise, units are Mbps\n");
   printf("Default:\n");
   printf("100 \n");
   printf("Minimum:\n");
   printf("50 \n");
   printf("Maximum:\n");
   printf("3200 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_min_bw_alarm_threshold_help( void )
{
   printf("Indicates a user configured threshold for PHY link bandwidth between two nodes that will raise an alarm. This configurable threshold shouldn't be confused with a different alarm below a fixed threshold of 358 bits per symbol (~57Mbps), which is the minimum PHY rate to allow a connection between any two nodes, according to MoCA spec.\n");

   printf("\nmocap get --min_bw_alarm_threshold\n");
}

MOCALIB_CLI_GET static int mocacli_get_min_bw_alarm_threshold_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t min_bw_alarm_threshold;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_min_bw_alarm_threshold_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&min_bw_alarm_threshold, 0, sizeof(min_bw_alarm_threshold));

      ret = moca_get_min_bw_alarm_threshold(handle, &min_bw_alarm_threshold);

      if (ret == 0) {
         mocacli_print_min_bw_alarm_threshold(&min_bw_alarm_threshold);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_min_bw_alarm_threshold_help( void )
{
   printf("Indicates a user configured threshold for PHY link bandwidth between two nodes that will raise an alarm. This configurable threshold shouldn't be confused with a different alarm below a fixed threshold of 358 bits per symbol (~57Mbps), which is the minimum PHY rate to allow a connection between any two nodes, according to MoCA spec.\n");

   printf("\nmocap set --min_bw_alarm_threshold <uint32 mbps>\n");
}

MOCALIB_CLI_SET static int mocacli_set_min_bw_alarm_threshold_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t min_bw_alarm_threshold;

   if (handle != NULL)
   {
      ret = moca_get_min_bw_alarm_threshold(handle, &min_bw_alarm_threshold);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_min_bw_alarm_threshold_help();
            mocacli_min_bw_alarm_threshold__mbps_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &min_bw_alarm_threshold);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_min_bw_alarm_threshold__mbps_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_min_bw_alarm_threshold(handle, min_bw_alarm_threshold);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_target_phy_rate_qam128__mbps_help(void)
{
   printf("mbps:\n");
   printf("=====\n");
   printf("\nValues:\n");
   printf("0 = Disable the Target PHY rate algorithm\n");
   printf("Default:\n");
   printf("245 \n");
   printf("Maximum:\n");
   printf("500 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_target_phy_rate_qam128_help( void )
{
   printf("Target PHY rate in Mbps, according to MoCA spec.Target PHY rate may be changed only before Admission time. Otherwise, the expected results are not guaranteed.\n");

   printf("\nmocap get --target_phy_rate_qam128\n");
}

MOCALIB_CLI_GET static int mocacli_get_target_phy_rate_qam128_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t target_phy_rate_qam128;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_target_phy_rate_qam128_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&target_phy_rate_qam128, 0, sizeof(target_phy_rate_qam128));

      ret = moca_get_target_phy_rate_qam128(handle, &target_phy_rate_qam128);

      if (ret == 0) {
         mocacli_print_target_phy_rate_qam128(&target_phy_rate_qam128);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_target_phy_rate_qam128_help( void )
{
   printf("Target PHY rate in Mbps, according to MoCA spec.Target PHY rate may be changed only before Admission time. Otherwise, the expected results are not guaranteed.\n");

   printf("\nmocap set --target_phy_rate_qam128 <uint32 mbps>\n");
}

MOCALIB_CLI_SET static int mocacli_set_target_phy_rate_qam128_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t target_phy_rate_qam128;

   if (handle != NULL)
   {
      ret = moca_get_target_phy_rate_qam128(handle, &target_phy_rate_qam128);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_target_phy_rate_qam128_help();
            mocacli_target_phy_rate_qam128__mbps_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &target_phy_rate_qam128);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_target_phy_rate_qam128__mbps_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_target_phy_rate_qam128(handle, target_phy_rate_qam128);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_target_phy_rate_qam256__mbps_help(void)
{
   printf("mbps:\n");
   printf("=====\n");
   printf("\nValues:\n");
   printf("0 = Disable the Target PHY rate algorithm\n");
   printf("Default:\n");
   printf("275 \n");
   printf("Maximum:\n");
   printf("500 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_target_phy_rate_qam256_help( void )
{
   printf("Target PHY rate in Mbps, according to MoCA spec.Target PHY rate may be changed only before Admission time. Otherwise, the expected results are not guaranteed.\n");

   printf("\nmocap get --target_phy_rate_qam256\n");
}

MOCALIB_CLI_GET static int mocacli_get_target_phy_rate_qam256_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t target_phy_rate_qam256;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_target_phy_rate_qam256_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&target_phy_rate_qam256, 0, sizeof(target_phy_rate_qam256));

      ret = moca_get_target_phy_rate_qam256(handle, &target_phy_rate_qam256);

      if (ret == 0) {
         mocacli_print_target_phy_rate_qam256(&target_phy_rate_qam256);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_target_phy_rate_qam256_help( void )
{
   printf("Target PHY rate in Mbps, according to MoCA spec.Target PHY rate may be changed only before Admission time. Otherwise, the expected results are not guaranteed.\n");

   printf("\nmocap set --target_phy_rate_qam256 <uint32 mbps>\n");
}

MOCALIB_CLI_SET static int mocacli_set_target_phy_rate_qam256_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t target_phy_rate_qam256;

   if (handle != NULL)
   {
      ret = moca_get_target_phy_rate_qam256(handle, &target_phy_rate_qam256);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_target_phy_rate_qam256_help();
            mocacli_target_phy_rate_qam256__mbps_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &target_phy_rate_qam256);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_target_phy_rate_qam256__mbps_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_target_phy_rate_qam256(handle, target_phy_rate_qam256);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_sapm_en__bool_val_help(void)
{
   printf("bool_val:\n");
   printf("=========\n");
   printf("\nValues:\n");
   printf("0 = Disable \n");
   printf("1 = Enable\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_sapm_en_help( void )
{
   printf("Enabling the usage SNR Margin adjustments per sub carrier\n");

   printf("\nmocap get --sapm_en\n");
}

MOCALIB_CLI_GET static int mocacli_get_sapm_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t sapm_en;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_sapm_en_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&sapm_en, 0, sizeof(sapm_en));

      ret = moca_get_sapm_en(handle, &sapm_en);

      if (ret == 0) {
         mocacli_print_sapm_en(&sapm_en);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_sapm_en_help( void )
{
   printf("Enabling the usage SNR Margin adjustments per sub carrier\n");

   printf("\nmocap set --sapm_en <uint32 bool_val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_sapm_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t sapm_en;

   if (handle != NULL)
   {
      ret = moca_get_sapm_en(handle, &sapm_en);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_sapm_en_help();
            mocacli_sapm_en__bool_val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &sapm_en);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_sapm_en__bool_val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_sapm_en(handle, sapm_en);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_arpl_th_50__arpl_help(void)
{
   printf("arpl:\n");
   printf("=====\n");
   printf("\nValues:\n");
   printf("Units of dBm\n");
   printf("Default:\n");
   printf("-50 \n");
   printf("Minimum:\n");
   printf("-65 \n");
   printf("Maximum:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_arpl_th_50_help( void )
{
   printf("Aggregate Received Power Level (ARPL) Threshold for 50 MHz (MoCA 1.1) transmissionswhich MUST be specified from 0 to 65 dBm in steps of 1 dB to be used with the SAPM feature. \n");
   printf("See also: sapm_table_50\n");

   printf("\nmocap get --arpl_th_50\n");
}

MOCALIB_CLI_GET static int mocacli_get_arpl_th_50_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   int32_t arpl_th_50;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_arpl_th_50_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&arpl_th_50, 0, sizeof(arpl_th_50));

      ret = moca_get_arpl_th_50(handle, &arpl_th_50);

      if (ret == 0) {
         mocacli_print_arpl_th_50(&arpl_th_50);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_arpl_th_50_help( void )
{
   printf("Aggregate Received Power Level (ARPL) Threshold for 50 MHz (MoCA 1.1) transmissionswhich MUST be specified from 0 to 65 dBm in steps of 1 dB to be used with the SAPM feature. \n");
   printf("See also: sapm_table_50\n");

   printf("\nmocap set --arpl_th_50 <int32 arpl>\n");
}

MOCALIB_CLI_SET static int mocacli_set_arpl_th_50_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   int32_t arpl_th_50;

   if (handle != NULL)
   {
      ret = moca_get_arpl_th_50(handle, &arpl_th_50);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_arpl_th_50_help();
            mocacli_arpl_th_50__arpl_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_int32(*pp_parms, &arpl_th_50);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_arpl_th_50__arpl_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_arpl_th_50(handle, arpl_th_50);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_rlapm_en__bool_val_help(void)
{
   printf("bool_val:\n");
   printf("=========\n");
   printf("\nValues:\n");
   printf("0 = Disable \n");
   printf("1 = Enable\n");
   printf("Default:\n");
   printf("0 \n1 (BAND_E)\n1 (BAND_F)\n");
}

MOCALIB_CLI_HELP static void mocacli_get_rlapm_en_help( void )
{
   printf("Enabling the usage of SNR Margin adjustments according to Rx Power\n");

   printf("\nmocap get --rlapm_en\n");
}

MOCALIB_CLI_GET static int mocacli_get_rlapm_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t rlapm_en;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_rlapm_en_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&rlapm_en, 0, sizeof(rlapm_en));

      ret = moca_get_rlapm_en(handle, &rlapm_en);

      if (ret == 0) {
         mocacli_print_rlapm_en(&rlapm_en);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_rlapm_en_help( void )
{
   printf("Enabling the usage of SNR Margin adjustments according to Rx Power\n");

   printf("\nmocap set --rlapm_en <uint32 bool_val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_rlapm_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t rlapm_en;

   if (handle != NULL)
   {
      ret = moca_get_rlapm_en(handle, &rlapm_en);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_rlapm_en_help();
            mocacli_rlapm_en__bool_val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &rlapm_en);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_rlapm_en__bool_val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_rlapm_en(handle, rlapm_en);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_freq_shift__direction_help(void)
{
   printf("direction:\n");
   printf("==========\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_freq_shift_help( void )
{
   printf("XtalPull test for midRF CTP, used by ICAP.110.This configuration is relevant only after TX continuous mode is activated, and the host should prevent sending it in regular mode.\n");

   printf("\nmocap get --freq_shift\n");
}

MOCALIB_CLI_GET static int mocacli_get_freq_shift_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t freq_shift;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_freq_shift_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&freq_shift, 0, sizeof(freq_shift));

      ret = moca_get_freq_shift(handle, &freq_shift);

      if (ret == 0) {
         mocacli_print_freq_shift(&freq_shift);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_freq_shift_help( void )
{
   printf("XtalPull test for midRF CTP, used by ICAP.110.This configuration is relevant only after TX continuous mode is activated, and the host should prevent sending it in regular mode.\n");

   printf("\nmocap set --freq_shift <uint32 direction>\n");
}

MOCALIB_CLI_SET static int mocacli_set_freq_shift_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t freq_shift;

   if (handle != NULL)
   {
      ret = moca_get_freq_shift(handle, &freq_shift);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_freq_shift_help();
            mocacli_freq_shift__direction_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &freq_shift);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_freq_shift__direction_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_freq_shift(handle, freq_shift);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_max_phy_rate__mbps_help(void)
{
   printf("mbps:\n");
   printf("=====\n");
   printf("\nValues:\n");
   printf("Units of Mbps\n");
   printf("Default:\n");
   printf("670 \n630 (7425)\n");
}

MOCALIB_CLI_HELP static void mocacli_get_max_phy_rate_help( void )
{
   printf("The maximum PHY rate supported in non-turbo mode.\n");

   printf("\nmocap get --max_phy_rate\n");
}

MOCALIB_CLI_GET static int mocacli_get_max_phy_rate_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t max_phy_rate;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_max_phy_rate_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&max_phy_rate, 0, sizeof(max_phy_rate));

      ret = moca_get_max_phy_rate(handle, &max_phy_rate);

      if (ret == 0) {
         mocacli_print_max_phy_rate(&max_phy_rate);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_max_phy_rate_help( void )
{
   printf("The maximum PHY rate supported in non-turbo mode.\n");

   printf("\nmocap set --max_phy_rate <uint32 mbps>\n");
}

MOCALIB_CLI_SET static int mocacli_set_max_phy_rate_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t max_phy_rate;

   if (handle != NULL)
   {
      ret = moca_get_max_phy_rate(handle, &max_phy_rate);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_max_phy_rate_help();
            mocacli_max_phy_rate__mbps_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &max_phy_rate);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_max_phy_rate__mbps_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_max_phy_rate(handle, max_phy_rate);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_bandwidth__bandwidth_help(void)
{
   printf("bandwidth:\n");
   printf("==========\n");
   printf("\nValues:\n");
   printf("0-50MHz or 1-100MHz\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_bandwidth_help( void )
{
   printf("Configure the MoCA interface to operate using a 50MHz or 100MHz bandwidth.\n");

   printf("\nmocap get --bandwidth\n");
}

MOCALIB_CLI_GET static int mocacli_get_bandwidth_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t bandwidth;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_bandwidth_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&bandwidth, 0, sizeof(bandwidth));

      ret = moca_get_bandwidth(handle, &bandwidth);

      if (ret == 0) {
         mocacli_print_bandwidth(&bandwidth);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_bandwidth_help( void )
{
   printf("Configure the MoCA interface to operate using a 50MHz or 100MHz bandwidth.\n");

   printf("\nmocap set --bandwidth <uint32 bandwidth>\n");
}

MOCALIB_CLI_SET static int mocacli_set_bandwidth_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t bandwidth;

   if (handle != NULL)
   {
      ret = moca_get_bandwidth(handle, &bandwidth);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_bandwidth_help();
            mocacli_bandwidth__bandwidth_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &bandwidth);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_bandwidth__bandwidth_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_bandwidth(handle, bandwidth);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_arpl_th_100__arpl_help(void)
{
   printf("arpl:\n");
   printf("=====\n");
   printf("\nValues:\n");
   printf("Units of dBm\n");
   printf("Default:\n");
   printf("-50 \n");
   printf("Minimum:\n");
   printf("-65 \n");
   printf("Maximum:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_arpl_th_100_help( void )
{
   printf("Aggregate Received Power Level (ARPL) Threshold for 100 MHz PHY transmissions which MUST be specified from 0 to 65 dBm in steps of 1 dB to be used with the SAPM feature. \n");
   printf("See also: sapm_table_100\n");

   printf("\nmocap get --arpl_th_100\n");
}

MOCALIB_CLI_GET static int mocacli_get_arpl_th_100_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   int32_t arpl_th_100;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_arpl_th_100_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&arpl_th_100, 0, sizeof(arpl_th_100));

      ret = moca_get_arpl_th_100(handle, &arpl_th_100);

      if (ret == 0) {
         mocacli_print_arpl_th_100(&arpl_th_100);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_arpl_th_100_help( void )
{
   printf("Aggregate Received Power Level (ARPL) Threshold for 100 MHz PHY transmissions which MUST be specified from 0 to 65 dBm in steps of 1 dB to be used with the SAPM feature. \n");
   printf("See also: sapm_table_100\n");

   printf("\nmocap set --arpl_th_100 <int32 arpl>\n");
}

MOCALIB_CLI_SET static int mocacli_set_arpl_th_100_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   int32_t arpl_th_100;

   if (handle != NULL)
   {
      ret = moca_get_arpl_th_100(handle, &arpl_th_100);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_arpl_th_100_help();
            mocacli_arpl_th_100__arpl_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_int32(*pp_parms, &arpl_th_100);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_arpl_th_100__arpl_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_arpl_th_100(handle, arpl_th_100);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_adc_mode__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = normal mode \n");
   printf("1 = special mode\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_adc_mode_help( void )
{
   printf("ADC clock mode\n");

   printf("\nmocap get --adc_mode\n");
}

MOCALIB_CLI_GET static int mocacli_get_adc_mode_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t adc_mode;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_adc_mode_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&adc_mode, 0, sizeof(adc_mode));

      ret = moca_get_adc_mode(handle, &adc_mode);

      if (ret == 0) {
         mocacli_print_adc_mode(&adc_mode);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_adc_mode_help( void )
{
   printf("ADC clock mode\n");

   printf("\nmocap set --adc_mode <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_adc_mode_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t adc_mode;

   if (handle != NULL)
   {
      ret = moca_get_adc_mode(handle, &adc_mode);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_adc_mode_help();
            mocacli_adc_mode__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &adc_mode);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_adc_mode__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_adc_mode(handle, adc_mode);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_max_phy_rate_turbo__mbps_help(void)
{
   printf("mbps:\n");
   printf("=====\n");
   printf("\nValues:\n");
   printf("Units of Mbps\n");
   printf("Default:\n");
   printf("670 \n680 (7425)\n");
}

MOCALIB_CLI_HELP static void mocacli_get_max_phy_rate_turbo_help( void )
{
   printf("The maximum PHY rate supported in turbo mode.\n");

   printf("\nmocap get --max_phy_rate_turbo\n");
}

MOCALIB_CLI_GET static int mocacli_get_max_phy_rate_turbo_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t max_phy_rate_turbo;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_max_phy_rate_turbo_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&max_phy_rate_turbo, 0, sizeof(max_phy_rate_turbo));

      ret = moca_get_max_phy_rate_turbo(handle, &max_phy_rate_turbo);

      if (ret == 0) {
         mocacli_print_max_phy_rate_turbo(&max_phy_rate_turbo);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_max_phy_rate_turbo_help( void )
{
   printf("The maximum PHY rate supported in turbo mode.\n");

   printf("\nmocap set --max_phy_rate_turbo <uint32 mbps>\n");
}

MOCALIB_CLI_SET static int mocacli_set_max_phy_rate_turbo_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t max_phy_rate_turbo;

   if (handle != NULL)
   {
      ret = moca_get_max_phy_rate_turbo(handle, &max_phy_rate_turbo);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_max_phy_rate_turbo_help();
            mocacli_max_phy_rate_turbo__mbps_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &max_phy_rate_turbo);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_max_phy_rate_turbo__mbps_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_max_phy_rate_turbo(handle, max_phy_rate_turbo);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_cp_const__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("64 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_cp_const_help( void )
{
   printf("Used to set the CP value to a fixed value. Valid values are from 0-64\n");

   printf("\nmocap get --cp_const\n");
}

MOCALIB_CLI_GET static int mocacli_get_cp_const_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t cp_const;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_cp_const_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&cp_const, 0, sizeof(cp_const));

      ret = __moca_get_cp_const(handle, &cp_const);

      if (ret == 0) {
         mocacli_print_cp_const(&cp_const);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_cp_const_help( void )
{
   printf("Used to set the CP value to a fixed value. Valid values are from 0-64\n");

   printf("\nmocap set --cp_const <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_cp_const_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t cp_const;

   if (handle != NULL)
   {
      ret = __moca_get_cp_const(handle, &cp_const);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_cp_const_help();
            mocacli_cp_const__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &cp_const);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_cp_const__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_cp_const(handle, cp_const);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_preamble_uc_const__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_preamble_uc_const_help( void )
{
   printf("Used to set the UC preamble to a constant value if non-zero. Valid values are from 6-12.\n");

   printf("\nmocap get --preamble_uc_const\n");
}

MOCALIB_CLI_GET static int mocacli_get_preamble_uc_const_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t preamble_uc_const;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_preamble_uc_const_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&preamble_uc_const, 0, sizeof(preamble_uc_const));

      ret = __moca_get_preamble_uc_const(handle, &preamble_uc_const);

      if (ret == 0) {
         mocacli_print_preamble_uc_const(&preamble_uc_const);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_preamble_uc_const_help( void )
{
   printf("Used to set the UC preamble to a constant value if non-zero. Valid values are from 6-12.\n");

   printf("\nmocap set --preamble_uc_const <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_preamble_uc_const_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t preamble_uc_const;

   if (handle != NULL)
   {
      ret = __moca_get_preamble_uc_const(handle, &preamble_uc_const);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_preamble_uc_const_help();
            mocacli_preamble_uc_const__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &preamble_uc_const);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_preamble_uc_const__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_preamble_uc_const(handle, preamble_uc_const);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_cp_margin_increase__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_cp_margin_increase_help( void )
{
   printf("Used to increase the CP margin.\n");

   printf("\nmocap get --cp_margin_increase\n");
}

MOCALIB_CLI_GET static int mocacli_get_cp_margin_increase_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t cp_margin_increase;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_cp_margin_increase_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&cp_margin_increase, 0, sizeof(cp_margin_increase));

      ret = __moca_get_cp_margin_increase(handle, &cp_margin_increase);

      if (ret == 0) {
         mocacli_print_cp_margin_increase(&cp_margin_increase);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_cp_margin_increase_help( void )
{
   printf("Used to increase the CP margin.\n");

   printf("\nmocap set --cp_margin_increase <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_cp_margin_increase_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t cp_margin_increase;

   if (handle != NULL)
   {
      ret = __moca_get_cp_margin_increase(handle, &cp_margin_increase);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_cp_margin_increase_help();
            mocacli_cp_margin_increase__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &cp_margin_increase);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_cp_margin_increase__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_cp_margin_increase(handle, cp_margin_increase);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_ac_cc_shift__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_ac_cc_shift_help( void )
{
   printf("Shift the auto correlation and cross corellation values. The MSB value represent the auto correlation starting from 1000 and the LSB value respresent the cross correlation. Each value decrease by 100.\n");

   printf("\nmocap get --ac_cc_shift\n");
}

MOCALIB_CLI_GET static int mocacli_get_ac_cc_shift_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t ac_cc_shift;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_ac_cc_shift_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&ac_cc_shift, 0, sizeof(ac_cc_shift));

      ret = __moca_get_ac_cc_shift(handle, &ac_cc_shift);

      if (ret == 0) {
         mocacli_print_ac_cc_shift(&ac_cc_shift);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_ac_cc_shift_help( void )
{
   printf("Shift the auto correlation and cross corellation values. The MSB value represent the auto correlation starting from 1000 and the LSB value respresent the cross correlation. Each value decrease by 100.\n");

   printf("\nmocap set --ac_cc_shift <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_ac_cc_shift_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t ac_cc_shift;

   if (handle != NULL)
   {
      ret = __moca_get_ac_cc_shift(handle, &ac_cc_shift);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_ac_cc_shift_help();
            mocacli_ac_cc_shift__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &ac_cc_shift);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_ac_cc_shift__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_ac_cc_shift(handle, ac_cc_shift);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_mfc_th_increase__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_mfc_th_increase_help( void )
{
   printf("Increase the MFC threshold. Each value decrease by 100.\n");

   printf("\nmocap get --mfc_th_increase\n");
}

MOCALIB_CLI_GET static int mocacli_get_mfc_th_increase_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t mfc_th_increase;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_mfc_th_increase_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&mfc_th_increase, 0, sizeof(mfc_th_increase));

      ret = __moca_get_mfc_th_increase(handle, &mfc_th_increase);

      if (ret == 0) {
         mocacli_print_mfc_th_increase(&mfc_th_increase);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_mfc_th_increase_help( void )
{
   printf("Increase the MFC threshold. Each value decrease by 100.\n");

   printf("\nmocap set --mfc_th_increase <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_mfc_th_increase_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t mfc_th_increase;

   if (handle != NULL)
   {
      ret = __moca_get_mfc_th_increase(handle, &mfc_th_increase);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_mfc_th_increase_help();
            mocacli_mfc_th_increase__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &mfc_th_increase);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_mfc_th_increase__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_mfc_th_increase(handle, mfc_th_increase);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_agc_const_en__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_agc_const_en_help( void )
{
   printf("Enable agc constant value. Valid values: 0 - disable , 1- enable. User should disable tpc\n");

   printf("\nmocap get --agc_const_en\n");
}

MOCALIB_CLI_GET static int mocacli_get_agc_const_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t agc_const_en;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_agc_const_en_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&agc_const_en, 0, sizeof(agc_const_en));

      ret = __moca_get_agc_const_en(handle, &agc_const_en);

      if (ret == 0) {
         mocacli_print_agc_const_en(&agc_const_en);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_agc_const_en_help( void )
{
   printf("Enable agc constant value. Valid values: 0 - disable , 1- enable. User should disable tpc\n");

   printf("\nmocap set --agc_const_en <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_agc_const_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t agc_const_en;

   if (handle != NULL)
   {
      ret = __moca_get_agc_const_en(handle, &agc_const_en);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_agc_const_en_help();
            mocacli_agc_const_en__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &agc_const_en);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_agc_const_en__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_agc_const_en(handle, agc_const_en);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_agc_const_address__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_agc_const_address_help( void )
{
   printf("Set the constant AGC address\n");

   printf("\nmocap get --agc_const_address\n");
}

MOCALIB_CLI_GET static int mocacli_get_agc_const_address_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t agc_const_address;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_agc_const_address_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&agc_const_address, 0, sizeof(agc_const_address));

      ret = __moca_get_agc_const_address(handle, &agc_const_address);

      if (ret == 0) {
         mocacli_print_agc_const_address(&agc_const_address);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_agc_const_address_help( void )
{
   printf("Set the constant AGC address\n");

   printf("\nmocap set --agc_const_address <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_agc_const_address_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t agc_const_address;

   if (handle != NULL)
   {
      ret = __moca_get_agc_const_address(handle, &agc_const_address);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_agc_const_address_help();
            mocacli_agc_const_address__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &agc_const_address);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_agc_const_address__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_agc_const_address(handle, agc_const_address);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_min_bo_insert_2_bfm_lock__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_min_bo_insert_2_bfm_lock_help( void )
{
   printf("Min backoff to insert back off mechanisim to lock mode. Each unit is 1 dB\n");

   printf("\nmocap get --min_bo_insert_2_bfm_lock\n");
}

MOCALIB_CLI_GET static int mocacli_get_min_bo_insert_2_bfm_lock_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t min_bo_insert_2_bfm_lock;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_min_bo_insert_2_bfm_lock_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&min_bo_insert_2_bfm_lock, 0, sizeof(min_bo_insert_2_bfm_lock));

      ret = __moca_get_min_bo_insert_2_bfm_lock(handle, &min_bo_insert_2_bfm_lock);

      if (ret == 0) {
         mocacli_print_min_bo_insert_2_bfm_lock(&min_bo_insert_2_bfm_lock);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_min_bo_insert_2_bfm_lock_help( void )
{
   printf("Min backoff to insert back off mechanisim to lock mode. Each unit is 1 dB\n");

   printf("\nmocap set --min_bo_insert_2_bfm_lock <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_min_bo_insert_2_bfm_lock_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t min_bo_insert_2_bfm_lock;

   if (handle != NULL)
   {
      ret = __moca_get_min_bo_insert_2_bfm_lock(handle, &min_bo_insert_2_bfm_lock);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_min_bo_insert_2_bfm_lock_help();
            mocacli_min_bo_insert_2_bfm_lock__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &min_bo_insert_2_bfm_lock);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_min_bo_insert_2_bfm_lock__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_min_bo_insert_2_bfm_lock(handle, min_bo_insert_2_bfm_lock);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_min_snr_avg_db_2_bfm_lock__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_min_snr_avg_db_2_bfm_lock_help( void )
{
   printf("min snr average that should be increase when the power increase. Each unit is 1/256 dB\n");

   printf("\nmocap get --min_snr_avg_db_2_bfm_lock\n");
}

MOCALIB_CLI_GET static int mocacli_get_min_snr_avg_db_2_bfm_lock_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t min_snr_avg_db_2_bfm_lock;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_min_snr_avg_db_2_bfm_lock_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&min_snr_avg_db_2_bfm_lock, 0, sizeof(min_snr_avg_db_2_bfm_lock));

      ret = __moca_get_min_snr_avg_db_2_bfm_lock(handle, &min_snr_avg_db_2_bfm_lock);

      if (ret == 0) {
         mocacli_print_min_snr_avg_db_2_bfm_lock(&min_snr_avg_db_2_bfm_lock);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_min_snr_avg_db_2_bfm_lock_help( void )
{
   printf("min snr average that should be increase when the power increase. Each unit is 1/256 dB\n");

   printf("\nmocap set --min_snr_avg_db_2_bfm_lock <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_min_snr_avg_db_2_bfm_lock_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t min_snr_avg_db_2_bfm_lock;

   if (handle != NULL)
   {
      ret = __moca_get_min_snr_avg_db_2_bfm_lock(handle, &min_snr_avg_db_2_bfm_lock);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_min_snr_avg_db_2_bfm_lock_help();
            mocacli_min_snr_avg_db_2_bfm_lock__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &min_snr_avg_db_2_bfm_lock);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_min_snr_avg_db_2_bfm_lock__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_min_snr_avg_db_2_bfm_lock(handle, min_snr_avg_db_2_bfm_lock);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_max_phy_rate_50M__mbps_help(void)
{
   printf("mbps:\n");
   printf("=====\n");
   printf("\nValues:\n");
   printf("Units of Mbps\n");
   printf("Default:\n");
   printf("300 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_max_phy_rate_50M_help( void )
{
   printf("The maximum PHY rate supported in 50M.\n");

   printf("\nmocap get --max_phy_rate_50M\n");
}

MOCALIB_CLI_GET static int mocacli_get_max_phy_rate_50M_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t max_phy_rate_50M;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_max_phy_rate_50M_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&max_phy_rate_50M, 0, sizeof(max_phy_rate_50M));

      ret = moca_get_max_phy_rate_50M(handle, &max_phy_rate_50M);

      if (ret == 0) {
         mocacli_print_max_phy_rate_50M(&max_phy_rate_50M);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_max_phy_rate_50M_help( void )
{
   printf("The maximum PHY rate supported in 50M.\n");

   printf("\nmocap set --max_phy_rate_50M <uint32 mbps>\n");
}

MOCALIB_CLI_SET static int mocacli_set_max_phy_rate_50M_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t max_phy_rate_50M;

   if (handle != NULL)
   {
      ret = moca_get_max_phy_rate_50M(handle, &max_phy_rate_50M);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_max_phy_rate_50M_help();
            mocacli_max_phy_rate_50M__mbps_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &max_phy_rate_50M);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_max_phy_rate_50M__mbps_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_max_phy_rate_50M(handle, max_phy_rate_50M);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_max_constellation_all__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("Constellation: \n");
   printf("1 = BPSK \n");
   printf("2 = QPSK \n");
   printf("3 = QAM8 \n");
   printf("4 = QAM16 \n");
   printf("5 = QAM32 \n");
   printf("6 = QAM64 \n");
   printf("7 = QAM128 \n");
   printf("8 = QAM256 \n");
   printf("9 = QAM512 \n");
   printf("10 = QAM1024\n");
   printf("Default:\n");
   printf("10 \n");
   printf("Minimum:\n");
   printf("1 \n");
   printf("Maximum:\n");
   printf("10 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_max_constellation_all_help( void )
{
   printf("Force max constellation in all the profiles (RX GCD/ RX UC),bandwidth (50M/100M), and nodes. \n");
   printf("The max constellation is computed according to the minimum of max_constellation_all and max_constellation\n");

   printf("\nmocap get --max_constellation_all\n");
}

MOCALIB_CLI_GET static int mocacli_get_max_constellation_all_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t max_constellation_all;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_max_constellation_all_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&max_constellation_all, 0, sizeof(max_constellation_all));

      ret = moca_get_max_constellation_all(handle, &max_constellation_all);

      if (ret == 0) {
         mocacli_print_max_constellation_all(&max_constellation_all);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_max_constellation_all_help( void )
{
   printf("Force max constellation in all the profiles (RX GCD/ RX UC),bandwidth (50M/100M), and nodes. \n");
   printf("The max constellation is computed according to the minimum of max_constellation_all and max_constellation\n");

   printf("\nmocap set --max_constellation_all <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_max_constellation_all_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t max_constellation_all;

   if (handle != NULL)
   {
      ret = moca_get_max_constellation_all(handle, &max_constellation_all);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_max_constellation_all_help();
            mocacli_max_constellation_all__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &max_constellation_all);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_max_constellation_all__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_max_constellation_all(handle, max_constellation_all);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_max_constellation__node_id_help(void)
{
   printf("node_id:\n");
   printf("========\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("15 \n");
}

MOCALIB_CLI_HELP static void mocacli_max_constellation__p2p_limit_50_help(void)
{
   printf("p2p_limit_50:\n");
   printf("=============\n");
   printf("This is the point-to-point (unicast) constellation limit for 50 MHz profiles.\n");
   printf("\nValues:\n");
   printf("Constellation: \n");
   printf("1 = BPSK \n");
   printf("2 = QPSK \n");
   printf("3 = QAM8 \n");
   printf("4 = QAM16 \n");
   printf("5 = QAM32 \n");
   printf("6 = QAM64 \n");
   printf("7 = QAM128 \n");
   printf("8 = QAM256 \n");
   printf("9 = QAM512 \n");
   printf("10 = QAM1024\n");
   printf("Default:\n");
   printf("10 \n");
   printf("Minimum:\n");
   printf("1 \n");
   printf("Maximum:\n");
   printf("10 \n");
}

MOCALIB_CLI_HELP static void mocacli_max_constellation__gcd_limit_50_help(void)
{
   printf("gcd_limit_50:\n");
   printf("=============\n");
   printf("This is the GCD (broadcast) constellation limit for 50 MHz profiles.\n");
   printf("\nValues:\n");
   printf("Constellation: \n");
   printf("1 = BPSK \n");
   printf("2 = QPSK \n");
   printf("3 = QAM8 \n");
   printf("4 = QAM16 \n");
   printf("5 = QAM32 \n");
   printf("6 = QAM64 \n");
   printf("7 = QAM128 \n");
   printf("8 = QAM256 \n");
   printf("9 = QAM512 \n");
   printf("10 = QAM1024\n");
   printf("Default:\n");
   printf("10 \n");
   printf("Minimum:\n");
   printf("1 \n");
   printf("Maximum:\n");
   printf("10 \n");
}

MOCALIB_CLI_HELP static void mocacli_max_constellation__p2p_limit_100_help(void)
{
   printf("p2p_limit_100:\n");
   printf("==============\n");
   printf("This is the point-to-point (unicast) constellation limit for 100 MHz profiles.\n");
   printf("\nValues:\n");
   printf("Constellation: \n");
   printf("1 = BPSK \n");
   printf("2 = QPSK \n");
   printf("3 = QAM8 \n");
   printf("4 = QAM16 \n");
   printf("5 = QAM32 \n");
   printf("6 = QAM64 \n");
   printf("7 = QAM128 \n");
   printf("8 = QAM256 \n");
   printf("9 = QAM512 \n");
   printf("10 = QAM1024\n");
   printf("Default:\n");
   printf("10 \n");
   printf("Minimum:\n");
   printf("1 \n");
   printf("Maximum:\n");
   printf("10 \n");
}

MOCALIB_CLI_HELP static void mocacli_max_constellation__gcd_limit_100_help(void)
{
   printf("gcd_limit_100:\n");
   printf("==============\n");
   printf("This is the GCD (broadcast) constellation limit for 100 MHz profiles.\n");
   printf("\nValues:\n");
   printf("Constellation: \n");
   printf("1 = BPSK \n");
   printf("2 = QPSK \n");
   printf("3 = QAM8 \n");
   printf("4 = QAM16 \n");
   printf("5 = QAM32 \n");
   printf("6 = QAM64 \n");
   printf("7 = QAM128 \n");
   printf("8 = QAM256 \n");
   printf("9 = QAM512 \n");
   printf("10 = QAM1024\n");
   printf("Default:\n");
   printf("10 \n");
   printf("Minimum:\n");
   printf("1 \n");
   printf("Maximum:\n");
   printf("10 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_max_constellation_help( void )
{
   printf("Set/Get max constellation on all carriers in the receive from a specified node (GCAP.32).\n");

   printf("\nmocap get --max_constellation <uint32 node_id>\n");
}

MOCALIB_CLI_GET static int mocacli_get_max_constellation_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_max_constellation max_constellation;
   int found_node_id = 0;
   uint32_t node_id;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_max_constellation_help();
      mocacli_max_constellation__node_id_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_max_constellation__node_id_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &node_id);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_max_constellation__node_id_help();
               return(ret);
            }
            found_node_id = 1;
         }
   }

   if (!found_node_id)
   {
      printf("Missing node_id parameter.\n");
      return(0);
   }

   if (handle != NULL)
   {
      memset(&max_constellation, 0, sizeof(max_constellation));

      ret = moca_get_max_constellation(handle, node_id, &max_constellation);

      if (ret == 0) {
         mocacli_print_max_constellation(&max_constellation);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_max_constellation_help( void )
{
   printf("Set/Get max constellation on all carriers in the receive from a specified node (GCAP.32).\n");

   printf("\nmocap set --max_constellation <options>\n");
   printf("options:\n");
   printf("   gcd_limit_100   <uint32>\n");
   printf("   p2p_limit_100   <uint32>\n");
   printf("   node_id         <uint32>\n");
   printf("   gcd_limit_50    <uint32>\n");
   printf("   p2p_limit_50    <uint32>\n");
}

MOCALIB_CLI_SET static int mocacli_set_max_constellation_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_max_constellation max_constellation;
   uint32_t node_id = mocacli_find_uint32_t(pp_parms, num_parms, "node_id");

   if (handle != NULL)
   {
      ret = moca_get_max_constellation(handle, node_id, &max_constellation);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "gcd_limit_100"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_max_constellation__gcd_limit_100_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &max_constellation.gcd_limit_100);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_max_constellation__gcd_limit_100_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "p2p_limit_100"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_max_constellation__p2p_limit_100_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &max_constellation.p2p_limit_100);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_max_constellation__p2p_limit_100_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "node_id"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_max_constellation__node_id_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &max_constellation.node_id);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_max_constellation__node_id_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "gcd_limit_50"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_max_constellation__gcd_limit_50_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &max_constellation.gcd_limit_50);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_max_constellation__gcd_limit_50_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "p2p_limit_50"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_max_constellation__p2p_limit_50_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &max_constellation.p2p_limit_50);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_max_constellation__p2p_limit_50_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_max_constellation_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_max_constellation(handle, &max_constellation);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_snr_margin_table_rs__mgntable_help(void)
{
   printf("mgntable[22]:\n");
   printf("=============\n");
   printf("\nValues:\n");
   printf("Units are 1/256 dB \n");
   printf("Defaults:\n");
   printf("mgntable[0] = (int) (256 * 9.5)\n");
   printf("mgntable[1] = (int) (256 * 12.5)\n");
   printf("mgntable[2] = (int) (256 * 15.5)\n");
   printf("mgntable[3] = (int) (256 * 19)\n");
   printf("mgntable[4] = (int) (256 * 22.5)\n");
   printf("mgntable[5] = (int) (256 * 25.5)\n");
   printf("mgntable[6] = (int) (256 * 29.5)\n");
   printf("mgntable[7] = (int) (256 * 34)\n");
   printf("mgntable[8] = (int) (256 * 37)\n");
   printf("mgntable[9] = (int) (256 * 40)\n");
   printf("mgntable[10] = 0\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("12800 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_snr_margin_table_rs_help( void )
{
   printf("A table of 10 values representing the RS SNR Margin values in dB per constellation BPSK-1024QAM.The table is created in the driver from a UserSnrMargin user config parameter and the Snr Margin Offset values.The algorithm for creating the table is as following:\n");
   printf("The user inputs a SNR Margin value, -3 to +25dB in steps of 1/256 dB.\n");
   printf("<b>Default values are still under work. Basically 7xxx is 0dB.\n");
   printf("6816 is 2dB under debug and may also change to 0dB.\n");
   printf("Turbo is 4.5dB.</b>\n");
   printf("\n");
   printf("Lab user may also enter 10 values of offset. Default values are all zeros. This 'offset' feature is not meant for customers to play with, but for advanced lab users. Offset values range is -3 to +25dB in steps of 0.5dB.The driver uses a const reference table with the default values for this array.\n");
   printf("SNR_MARGIN_TABLE[n] = 2* (RefTable[n] + UserSnrMargin + offset[n]) ; n=0..9\n");
   printf("\n");
   printf("In CLI or application, user SNR margin value and SNR Margin Offset values shouldn't be connected as one command, i.e. the user will be able to update snr margin without the need to a new set for the SNR margin offset.\n");
   printf("\n");
   printf("The array has 12 entries and the 11th entry (index 10) will be the userSnrMargin as given in CLI, multiplied by 256. This value is used by the MoCA core in RLAPM calculation.\n");
   printf("\n");
   printf("Entries from index 11 to 20 will hold the offset values specified by the user in units of 1/256 dB.\n");

   printf("\nmocap get --snr_margin_table_rs\n");
}

MOCALIB_CLI_GET static int mocacli_get_snr_margin_table_rs_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_table_rs snr_margin_table_rs;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_snr_margin_table_rs_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&snr_margin_table_rs, 0, sizeof(snr_margin_table_rs));

      ret = __moca_get_snr_margin_table_rs(handle, &snr_margin_table_rs);

      if (ret == 0) {
         mocacli_print_snr_margin_table_rs(&snr_margin_table_rs);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_snr_margin_table_rs_help( void )
{
   printf("A table of 10 values representing the RS SNR Margin values in dB per constellation BPSK-1024QAM.The table is created in the driver from a UserSnrMargin user config parameter and the Snr Margin Offset values.The algorithm for creating the table is as following:\n");
   printf("The user inputs a SNR Margin value, -3 to +25dB in steps of 1/256 dB.\n");
   printf("<b>Default values are still under work. Basically 7xxx is 0dB.\n");
   printf("6816 is 2dB under debug and may also change to 0dB.\n");
   printf("Turbo is 4.5dB.</b>\n");
   printf("\n");
   printf("Lab user may also enter 10 values of offset. Default values are all zeros. This 'offset' feature is not meant for customers to play with, but for advanced lab users. Offset values range is -3 to +25dB in steps of 0.5dB.The driver uses a const reference table with the default values for this array.\n");
   printf("SNR_MARGIN_TABLE[n] = 2* (RefTable[n] + UserSnrMargin + offset[n]) ; n=0..9\n");
   printf("\n");
   printf("In CLI or application, user SNR margin value and SNR Margin Offset values shouldn't be connected as one command, i.e. the user will be able to update snr margin without the need to a new set for the SNR margin offset.\n");
   printf("\n");
   printf("The array has 12 entries and the 11th entry (index 10) will be the userSnrMargin as given in CLI, multiplied by 256. This value is used by the MoCA core in RLAPM calculation.\n");
   printf("\n");
   printf("Entries from index 11 to 20 will hold the offset values specified by the user in units of 1/256 dB.\n");

   printf("\nmocap set --snr_margin_table_rs <options>\n");
   printf("options:\n");
   printf("   mgntable   <uint16 value> <index> <end index (optional)>\n");
}

MOCALIB_CLI_SET static int mocacli_set_snr_margin_table_rs_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_table_rs snr_margin_table_rs;

   if (handle != NULL)
   {
      ret = __moca_get_snr_margin_table_rs(handle, &snr_margin_table_rs);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "mgntable"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_snr_margin_table_rs__mgntable_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint16_array(&pp_parms, &num_parms, &snr_margin_table_rs.mgntable[0], 1);
            if (ret != 0)
            {
               mocacli_snr_margin_table_rs__mgntable_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_snr_margin_table_rs_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = __moca_set_snr_margin_table_rs(handle, &snr_margin_table_rs);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_rlapm_table_50__rlapmtable_help(void)
{
   printf("rlapmtable[66]:\n");
   printf("===============\n");
   printf("\nValues:\n");
   printf("Units are 0.5 dB \n");
   printf("\n");
   printf("Default values: \n");
   printf("\n");
   printf("Table[26]= (unsigned char) (0.5 *2) \n");
   printf("Table[27]= (unsigned char) (0.5 *2) \n");
   printf("Table[28]= (unsigned char) (0.5 *2) \n");
   printf("Table[29]= (unsigned char) (0.5 *2) \n");
   printf("Table[30]= (unsigned char) (0.5 *2) \n");
   printf("Table[31]= (unsigned char) (1.0 *2) \n");
   printf("Table[32]= (unsigned char) (1.5 *2) \n");
   printf("Table[33]= (unsigned char) (1.0 *2) \n");
   printf("Table[34]= (unsigned char) (1.5 *2) \n");
   printf("Table[35]= (unsigned char) (1.5 *2) \n");
   printf("Table[36]= (unsigned char) (2.0 *2) \n");
   printf("Table[37]= (unsigned char) (2.5 *2) \n");
   printf("Table[38]= (unsigned char) (3.0 *2) \n");
   printf("Table[39]= (unsigned char) (3.5 *2) \n");
   printf("Table[40]= (unsigned char) (4.0 *2) \n");
   printf("Table[41]= (unsigned char) (4.5 *2) \n");
   printf("Table[42]= (unsigned char) (4.5 *2) \n");
   printf("Table[43]= (unsigned char) (6.5 *2) \n");
   printf("Table[44]= (unsigned char) (7.5 *2) \n");
   printf("Table[45]= (unsigned char) (9.5 *2) \n");
   printf("Table[46]= (unsigned char) (9.5 *2) \n");
   printf("Table[47]= (unsigned char) (10.5 *2) \n");
   printf("Table[48]= (unsigned char) (10.5 *2) \n");
   printf("Table[49]= (unsigned char) (11.0 *2) \n");
   printf("Table[50]= (unsigned char) (12.0 *2) \n");
   printf("Table[51]= (unsigned char) (12.0 *2) \n");
   printf("Table[52]= (unsigned char) (12.0 *2) \n");
   printf("Table[53]= (unsigned char) (12.0 *2) \n");
   printf("Table[54]= (unsigned char) (13.0 *2) \n");
   printf("Table[55]= (unsigned char) (13.5 *2) \n");
   printf("Table[56]= (unsigned char) (13.5 *2) \n");
   printf("Table[57]= (unsigned char) (13.5 *2) \n");
   printf("Table[58]= (unsigned char) (13.5 *2) \n");
   printf("Table[59]= (unsigned char) (13.5 *2) \n");
   printf("Table[60]= (unsigned char) (14.0 *2) \n");
   printf("Table[61]= (unsigned char) (15.0 *2) \n");
   printf("Table[62..65]= (unsigned char) (16.0 *2)\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("60 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_rlapm_table_50_help( void )
{
   printf("An array of Margin Adjustments per RX power for 50 MHz channel (MoCA 1.1) transmissions. \n");
   printf("First value is for 0dBm received power. \n");
   printf("Last value is for -65dBm received power. \n");
   printf(" \n");
   printf("The dB values for adjustments are multiplied by 2, in order to allow 1/2 dB resolution.\n");

   printf("\nmocap get --rlapm_table_50\n");
}

MOCALIB_CLI_GET static int mocacli_get_rlapm_table_50_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_rlapm_table_50 rlapm_table_50;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_rlapm_table_50_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&rlapm_table_50, 0, sizeof(rlapm_table_50));

      ret = moca_get_rlapm_table_50(handle, &rlapm_table_50);

      if (ret == 0) {
         mocacli_print_rlapm_table_50(&rlapm_table_50);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_rlapm_table_50_help( void )
{
   printf("An array of Margin Adjustments per RX power for 50 MHz channel (MoCA 1.1) transmissions. \n");
   printf("First value is for 0dBm received power. \n");
   printf("Last value is for -65dBm received power. \n");
   printf(" \n");
   printf("The dB values for adjustments are multiplied by 2, in order to allow 1/2 dB resolution.\n");

   printf("\nmocap set --rlapm_table_50 <options>\n");
   printf("options:\n");
   printf("   rlapmtable   <uint8 value> <index> <end index (optional)>\n");
}

MOCALIB_CLI_SET static int mocacli_set_rlapm_table_50_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_rlapm_table_50 rlapm_table_50;

   if (handle != NULL)
   {
      ret = moca_get_rlapm_table_50(handle, &rlapm_table_50);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "rlapmtable"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_rlapm_table_50__rlapmtable_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint8_array(&pp_parms, &num_parms, &rlapm_table_50.rlapmtable[0], 1);
            if (ret != 0)
            {
               mocacli_rlapm_table_50__rlapmtable_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_rlapm_table_50_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_rlapm_table_50(handle, &rlapm_table_50);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_get_phy_status_help( void )
{
   printf("Retrieve status information about the MoCA PHY layer.\n");

   printf("\nmocap get --phy_status\n");
}

MOCALIB_CLI_GET static int mocacli_get_phy_status_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t phy_status;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_phy_status_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&phy_status, 0, sizeof(phy_status));

      ret = moca_get_phy_status(handle, &phy_status);

      if (ret == 0) {
         mocacli_print_phy_status(&phy_status);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_snr_margin_table_ldpc__mgntable_help(void)
{
   printf("mgntable[22]:\n");
   printf("=============\n");
   printf("\nValues:\n");
   printf("Units are 1/256 dB \n");
   printf("Defaults:\n");
   printf("mgntable[0] = (int) (256 * (3.8 + 1.8 + 1))\n");
   printf("mgntable[1] = (int) (256 * (6.8 + 1.8 + 1))\n");
   printf("mgntable[2] = (int) (256 * (10.8 + 1.8 + 1))\n");
   printf("mgntable[3] = (int) (256 * (13.3 + 1.8 + 1))\n");
   printf("mgntable[4] = (int) (256 * (16.5 + 1.8 + 1))\n");
   printf("mgntable[5] = (int) (256 * (19.1 + 1.8 + 1))\n");
   printf("mgntable[6] = (int) (256 * (22 + 1.8 + 1))\n");
   printf("mgntable[7] = (int) (256 * (24.6 + 1.8 + 1))\n");
   printf("mgntable[8] = (int) (256 * (27.4 + 1.8 + 1 + 1))\n");
   printf("mgntable[9] = (int) (256 * (30.2 + 1.8 + 1 + 2))\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("12800 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_snr_margin_table_ldpc_help( void )
{
   printf("A table of 10 values representing the LDPC SNR Margin values in dB per constellation BPSK-1024QAM.The table is created in the driver from a UserSnrMargin user config parameter and the Snr Margin Offset values.The algorithm for creating the table is as following:\n");
   printf("The user inputs a SNR Margin value, -3 to +25dB in steps of 1/256 dB.\n");
   printf("<b>Default values are still under work. Basically 7xxx is 0dB.\n");
   printf("6816 is 2dB under debug and may also change to 0dB.\n");
   printf("Turbo is 4.5dB.</b>\n");
   printf("\n");
   printf("Lab user may also enter 10 values of offset. Default values are all zeros. This 'offset' feature is not meant for customers to play with, but for advanced lab users. Offset values range is -3 to +25dB in steps of 0.5dB.The driver uses a const reference table with the default values for this array.\n");
   printf("SNR_MARGIN_TABLE[n] = 2* (RefTable[n] + UserSnrMargin + offset[n]) ; n=0..9\n");
   printf("\n");
   printf("In CLI or application, user SNR margin value and SNR Margin Offset values shouldn't be connected as one command, i.e. the user will be able to update snr margin without the need to a new set for the SNR margin offset.\n");
   printf("\n");
   printf("The array has 12 entries and the 11th entry (index 10) will be the userSnrMargin as given in CLI, multiplied by 256. This value is used by the MoCA core in RLAPM calculation.\n");
   printf("\n");
   printf("Entries from index 11 to 20 will hold the offset values specified by the user in units of 1/256 dB.\n");

   printf("\nmocap get --snr_margin_table_ldpc\n");
}

MOCALIB_CLI_GET static int mocacli_get_snr_margin_table_ldpc_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_table_ldpc snr_margin_table_ldpc;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_snr_margin_table_ldpc_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&snr_margin_table_ldpc, 0, sizeof(snr_margin_table_ldpc));

      ret = __moca_get_snr_margin_table_ldpc(handle, &snr_margin_table_ldpc);

      if (ret == 0) {
         mocacli_print_snr_margin_table_ldpc(&snr_margin_table_ldpc);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_snr_margin_table_ldpc_help( void )
{
   printf("A table of 10 values representing the LDPC SNR Margin values in dB per constellation BPSK-1024QAM.The table is created in the driver from a UserSnrMargin user config parameter and the Snr Margin Offset values.The algorithm for creating the table is as following:\n");
   printf("The user inputs a SNR Margin value, -3 to +25dB in steps of 1/256 dB.\n");
   printf("<b>Default values are still under work. Basically 7xxx is 0dB.\n");
   printf("6816 is 2dB under debug and may also change to 0dB.\n");
   printf("Turbo is 4.5dB.</b>\n");
   printf("\n");
   printf("Lab user may also enter 10 values of offset. Default values are all zeros. This 'offset' feature is not meant for customers to play with, but for advanced lab users. Offset values range is -3 to +25dB in steps of 0.5dB.The driver uses a const reference table with the default values for this array.\n");
   printf("SNR_MARGIN_TABLE[n] = 2* (RefTable[n] + UserSnrMargin + offset[n]) ; n=0..9\n");
   printf("\n");
   printf("In CLI or application, user SNR margin value and SNR Margin Offset values shouldn't be connected as one command, i.e. the user will be able to update snr margin without the need to a new set for the SNR margin offset.\n");
   printf("\n");
   printf("The array has 12 entries and the 11th entry (index 10) will be the userSnrMargin as given in CLI, multiplied by 256. This value is used by the MoCA core in RLAPM calculation.\n");
   printf("\n");
   printf("Entries from index 11 to 20 will hold the offset values specified by the user in units of 1/256 dB.\n");

   printf("\nmocap set --snr_margin_table_ldpc <options>\n");
   printf("options:\n");
   printf("   mgntable   <uint16 value> <index> <end index (optional)>\n");
}

MOCALIB_CLI_SET static int mocacli_set_snr_margin_table_ldpc_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_table_ldpc snr_margin_table_ldpc;

   if (handle != NULL)
   {
      ret = __moca_get_snr_margin_table_ldpc(handle, &snr_margin_table_ldpc);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "mgntable"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_snr_margin_table_ldpc__mgntable_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint16_array(&pp_parms, &num_parms, &snr_margin_table_ldpc.mgntable[0], 1);
            if (ret != 0)
            {
               mocacli_snr_margin_table_ldpc__mgntable_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_snr_margin_table_ldpc_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = __moca_set_snr_margin_table_ldpc(handle, &snr_margin_table_ldpc);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_snr_margin_table_ldpc_sec_ch__mgntable_help(void)
{
   printf("mgntable[22]:\n");
   printf("=============\n");
   printf("\nValues:\n");
   printf("Units are 1/256 dB \n");
   printf("Defaults:\n");
   printf("mgntable[0] = (int) (256 * (3.8 + 1.8 + 1))\n");
   printf("mgntable[1] = (int) (256 * (6.8 + 1.8 + 1))\n");
   printf("mgntable[2] = (int) (256 * (10.8 + 1.8 + 1))\n");
   printf("mgntable[3] = (int) (256 * (13.3 + 1.8 + 1))\n");
   printf("mgntable[4] = (int) (256 * (16.5 + 1.8 + 1))\n");
   printf("mgntable[5] = (int) (256 * (19.1 + 1.8 + 1))\n");
   printf("mgntable[6] = (int) (256 * (22 + 1.8 + 1))\n");
   printf("mgntable[7] = (int) (256 * (24.6 + 1.8 + 1))\n");
   printf("mgntable[8] = (int) (256 * (27.4 + 1.8 + 1 + 1))\n");
   printf("mgntable[9] = (int) (256 * (30.2 + 1.8 + 1 + 2))\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("12800 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_snr_margin_table_ldpc_sec_ch_help( void )
{
   printf("A table of 10 values representing the LDPC SNR Margin values in dB per constellation BPSK-1024QAM for the secondary channel in bonded mode operation.The table is created in the driver from a UserSnrMargin user config parameter and the Snr Margin Offset values.The algorithm for creating the table is as following:\n");
   printf("The user inputs a SNR Margin value, -3 to +25dB in steps of 1/256 dB.\n");
   printf("<b>Default values are still under work. Basically 7xxx is 0dB.\n");
   printf("6816 is 2dB under debug and may also change to 0dB.\n");
   printf("Turbo is 4.5dB.</b>\n");
   printf("\n");
   printf("Lab user may also enter 10 values of offset. Default values are all zeros. This 'offset' feature is not meant for customers to play with, but for advanced lab users. Offset values range is -3 to +25dB in steps of 0.5dB.The driver uses a const reference table with the default values for this array.\n");
   printf("SNR_MARGIN_TABLE[n] = 2* (RefTable[n] + UserSnrMargin + offset[n]) ; n=0..9\n");
   printf("\n");
   printf("In CLI or application, user SNR margin value and SNR Margin Offset values shouldn't be connected as one command, i.e. the user will be able to update snr margin without the need to a new set for the SNR margin offset.\n");
   printf("\n");
   printf("The array has 12 entries and the 11th entry (index 10) will be the userSnrMargin as given in CLI, multiplied by 256. This value is used by the MoCA core in RLAPM calculation.\n");
   printf("\n");
   printf("Entries from index 11 to 20 will hold the offset values specified by the user in units of 1/256 dB.\n");

   printf("\nmocap get --snr_margin_table_ldpc_sec_ch\n");
}

MOCALIB_CLI_GET static int mocacli_get_snr_margin_table_ldpc_sec_ch_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_table_ldpc_sec_ch snr_margin_table_ldpc_sec_ch;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_snr_margin_table_ldpc_sec_ch_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&snr_margin_table_ldpc_sec_ch, 0, sizeof(snr_margin_table_ldpc_sec_ch));

      ret = __moca_get_snr_margin_table_ldpc_sec_ch(handle, &snr_margin_table_ldpc_sec_ch);

      if (ret == 0) {
         mocacli_print_snr_margin_table_ldpc_sec_ch(&snr_margin_table_ldpc_sec_ch);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_snr_margin_table_ldpc_sec_ch_help( void )
{
   printf("A table of 10 values representing the LDPC SNR Margin values in dB per constellation BPSK-1024QAM for the secondary channel in bonded mode operation.The table is created in the driver from a UserSnrMargin user config parameter and the Snr Margin Offset values.The algorithm for creating the table is as following:\n");
   printf("The user inputs a SNR Margin value, -3 to +25dB in steps of 1/256 dB.\n");
   printf("<b>Default values are still under work. Basically 7xxx is 0dB.\n");
   printf("6816 is 2dB under debug and may also change to 0dB.\n");
   printf("Turbo is 4.5dB.</b>\n");
   printf("\n");
   printf("Lab user may also enter 10 values of offset. Default values are all zeros. This 'offset' feature is not meant for customers to play with, but for advanced lab users. Offset values range is -3 to +25dB in steps of 0.5dB.The driver uses a const reference table with the default values for this array.\n");
   printf("SNR_MARGIN_TABLE[n] = 2* (RefTable[n] + UserSnrMargin + offset[n]) ; n=0..9\n");
   printf("\n");
   printf("In CLI or application, user SNR margin value and SNR Margin Offset values shouldn't be connected as one command, i.e. the user will be able to update snr margin without the need to a new set for the SNR margin offset.\n");
   printf("\n");
   printf("The array has 12 entries and the 11th entry (index 10) will be the userSnrMargin as given in CLI, multiplied by 256. This value is used by the MoCA core in RLAPM calculation.\n");
   printf("\n");
   printf("Entries from index 11 to 20 will hold the offset values specified by the user in units of 1/256 dB.\n");

   printf("\nmocap set --snr_margin_table_ldpc_sec_ch <options>\n");
   printf("options:\n");
   printf("   mgntable   <uint16 value> <index> <end index (optional)>\n");
}

MOCALIB_CLI_SET static int mocacli_set_snr_margin_table_ldpc_sec_ch_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_table_ldpc_sec_ch snr_margin_table_ldpc_sec_ch;

   if (handle != NULL)
   {
      ret = __moca_get_snr_margin_table_ldpc_sec_ch(handle, &snr_margin_table_ldpc_sec_ch);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "mgntable"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_snr_margin_table_ldpc_sec_ch__mgntable_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint16_array(&pp_parms, &num_parms, &snr_margin_table_ldpc_sec_ch.mgntable[0], 1);
            if (ret != 0)
            {
               mocacli_snr_margin_table_ldpc_sec_ch__mgntable_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_snr_margin_table_ldpc_sec_ch_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = __moca_set_snr_margin_table_ldpc_sec_ch(handle, &snr_margin_table_ldpc_sec_ch);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_snr_margin_table_ldpc_pre5__mgntable_help(void)
{
   printf("mgntable[22]:\n");
   printf("=============\n");
   printf("\nValues:\n");
   printf("Units are 1/256 dB \n");
   printf("Defaults:\n");
   printf("mgntable[0] = (int) (256 * (3.8 + 1.8 + 2.2))\n");
   printf("mgntable[1] = (int) (256 * (6.8 + 1.8 + 2.2))\n");
   printf("mgntable[2] = (int) (256 * (10.8 + 1.8 + 2.2))\n");
   printf("mgntable[3] = (int) (256 * (13.3 + 1.8 + 2.2))\n");
   printf("mgntable[4] = (int) (256 * (16.5 + 1.8 + 2.2))\n");
   printf("mgntable[5] = (int) (256 * (19.1 + 1.8 + 2.2))\n");
   printf("mgntable[6] = (int) (256 * (22 + 1.8 + 2.2))\n");
   printf("mgntable[7] = (int) (256 * (24.6 + 1.8 + 2.2))\n");
   printf("mgntable[8] = (int) (256 * (27.4 + 1.8 + 2.2 + 1))\n");
   printf("mgntable[9] = (int) (256 * (30.2 + 1.8 + 2.2 + 2))\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("12800 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_snr_margin_table_ldpc_pre5_help( void )
{
   printf("A table of 10 values representing the LDPC Preamble 5 SNR Margin values in dB per constellation BPSK-1024QAM.The table is created in the driver from a UserSnrMargin user config parameter and the Snr Margin Offset values.The algorithm for creating the table is as following:\n");
   printf("The user inputs a SNR Margin value, -3 to +25dB in steps of 1/256 dB.\n");
   printf("<b>Default values are still under work. Basically 7xxx is 0dB.\n");
   printf("6816 is 2dB under debug and may also change to 0dB.\n");
   printf("Turbo is 4.5dB.</b>\n");
   printf("\n");
   printf("Lab user may also enter 10 values of offset. Default values are all zeros. This 'offset' feature is not meant for customers to play with, but for advanced lab users. Offset values range is -3 to +25dB in steps of 0.5dB.The driver uses a const reference table with the default values for this array.\n");
   printf("SNR_MARGIN_TABLE[n] = 2* (RefTable[n] + UserSnrMargin + offset[n]) ; n=0..9\n");
   printf("\n");
   printf("In CLI or application, user SNR margin value and SNR Margin Offset values shouldn't be connected as one command, i.e. the user will be able to update snr margin without the need to a new set for the SNR margin offset.\n");
   printf("\n");
   printf("The array has 12 entries and the 11th entry (index 10) will be the userSnrMargin as given in CLI, multiplied by 256. This value is used by the MoCA core in RLAPM calculation.\n");
   printf("\n");
   printf("Entries from index 11 to 20 will hold the offset values specified by the user in units of 1/256 dB.\n");

   printf("\nmocap get --snr_margin_table_ldpc_pre5\n");
}

MOCALIB_CLI_GET static int mocacli_get_snr_margin_table_ldpc_pre5_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_table_ldpc_pre5 snr_margin_table_ldpc_pre5;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_snr_margin_table_ldpc_pre5_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&snr_margin_table_ldpc_pre5, 0, sizeof(snr_margin_table_ldpc_pre5));

      ret = __moca_get_snr_margin_table_ldpc_pre5(handle, &snr_margin_table_ldpc_pre5);

      if (ret == 0) {
         mocacli_print_snr_margin_table_ldpc_pre5(&snr_margin_table_ldpc_pre5);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_snr_margin_table_ldpc_pre5_help( void )
{
   printf("A table of 10 values representing the LDPC Preamble 5 SNR Margin values in dB per constellation BPSK-1024QAM.The table is created in the driver from a UserSnrMargin user config parameter and the Snr Margin Offset values.The algorithm for creating the table is as following:\n");
   printf("The user inputs a SNR Margin value, -3 to +25dB in steps of 1/256 dB.\n");
   printf("<b>Default values are still under work. Basically 7xxx is 0dB.\n");
   printf("6816 is 2dB under debug and may also change to 0dB.\n");
   printf("Turbo is 4.5dB.</b>\n");
   printf("\n");
   printf("Lab user may also enter 10 values of offset. Default values are all zeros. This 'offset' feature is not meant for customers to play with, but for advanced lab users. Offset values range is -3 to +25dB in steps of 0.5dB.The driver uses a const reference table with the default values for this array.\n");
   printf("SNR_MARGIN_TABLE[n] = 2* (RefTable[n] + UserSnrMargin + offset[n]) ; n=0..9\n");
   printf("\n");
   printf("In CLI or application, user SNR margin value and SNR Margin Offset values shouldn't be connected as one command, i.e. the user will be able to update snr margin without the need to a new set for the SNR margin offset.\n");
   printf("\n");
   printf("The array has 12 entries and the 11th entry (index 10) will be the userSnrMargin as given in CLI, multiplied by 256. This value is used by the MoCA core in RLAPM calculation.\n");
   printf("\n");
   printf("Entries from index 11 to 20 will hold the offset values specified by the user in units of 1/256 dB.\n");

   printf("\nmocap set --snr_margin_table_ldpc_pre5 <options>\n");
   printf("options:\n");
   printf("   mgntable   <uint16 value> <index> <end index (optional)>\n");
}

MOCALIB_CLI_SET static int mocacli_set_snr_margin_table_ldpc_pre5_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_table_ldpc_pre5 snr_margin_table_ldpc_pre5;

   if (handle != NULL)
   {
      ret = __moca_get_snr_margin_table_ldpc_pre5(handle, &snr_margin_table_ldpc_pre5);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "mgntable"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_snr_margin_table_ldpc_pre5__mgntable_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint16_array(&pp_parms, &num_parms, &snr_margin_table_ldpc_pre5.mgntable[0], 1);
            if (ret != 0)
            {
               mocacli_snr_margin_table_ldpc_pre5__mgntable_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_snr_margin_table_ldpc_pre5_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = __moca_set_snr_margin_table_ldpc_pre5(handle, &snr_margin_table_ldpc_pre5);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_snr_margin_table_ofdma__mgntable_help(void)
{
   printf("mgntable[22]:\n");
   printf("=============\n");
   printf("\nValues:\n");
   printf("Units are 1/256 dB \n");
   printf("Defaults:\n");
   printf("mgntable[0] = (int) (256 * (4.2 + 1.8))\n");
   printf("mgntable[1] = (int) (256 * (7 + 1.8))\n");
   printf("mgntable[2] = (int) (256 * (11.8 + 1.8))\n");
   printf("mgntable[3] = (int) (256 * (13.8 + 1.8))\n");
   printf("mgntable[4] = (int) (256 * (16.8 + 1.8))\n");
   printf("mgntable[5] = (int) (256 * (19.8 + 1.8))\n");
   printf("mgntable[6] = (int) (256 * (22.6 + 1.8))\n");
   printf("mgntable[7] = (int) (256 * (25.4 + 1.8))\n");
   printf("mgntable[8] = (int) (256 * (28 + 1.8))\n");
   printf("mgntable[9] = (int) (256 * (31 + 1.8))\n");
   printf("mgntable[10] = 0\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("12800 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_snr_margin_table_ofdma_help( void )
{
   printf("A table of 10 values representing the OFDMA SNR Margin values in dB per constellation BPSK-1024QAM.The table is created in the driver from a UserSnrMargin user config parameter and the Snr Margin Offset values.The algorithm for creating the table is as following:\n");
   printf("The user inputs a SNR Margin value, -3 to +25dB in steps of 1/256 dB.\n");
   printf("<b>Default values are still under work. Basically 7xxx is 0dB.\n");
   printf("6816 is 2dB under debug and may also change to 0dB.\n");
   printf("Turbo is 4.5dB.</b>\n");
   printf("\n");
   printf("Lab user may also enter 10 values of offset. Default values are all zeros. This 'offset' feature is not meant for customers to play with, but for advanced lab users. Offset values range is -3 to +25dB in steps of 0.5dB.The driver uses a const reference table with the default values for this array.\n");
   printf("SNR_MARGIN_TABLE[n] = 2* (RefTable[n] + UserSnrMargin + offset[n]) ; n=0..9\n");
   printf("\n");
   printf("In CLI or application, user SNR margin value and SNR Margin Offset values shouldn't be connected as one command, i.e. the user will be able to update snr margin without the need to a new set for the SNR margin offset.\n");
   printf("\n");
   printf("The array has 12 entries and the 11th entry (index 10) will be the userSnrMargin as given in CLI, multiplied by 256. This value is used by the MoCA core in RLAPM calculation.\n");
   printf("\n");
   printf("Entries from index 11 to 20 will hold the offset values specified by the user in units of 1/256 dB.\n");

   printf("\nmocap get --snr_margin_table_ofdma\n");
}

MOCALIB_CLI_GET static int mocacli_get_snr_margin_table_ofdma_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_table_ofdma snr_margin_table_ofdma;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_snr_margin_table_ofdma_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&snr_margin_table_ofdma, 0, sizeof(snr_margin_table_ofdma));

      ret = __moca_get_snr_margin_table_ofdma(handle, &snr_margin_table_ofdma);

      if (ret == 0) {
         mocacli_print_snr_margin_table_ofdma(&snr_margin_table_ofdma);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_snr_margin_table_ofdma_help( void )
{
   printf("A table of 10 values representing the OFDMA SNR Margin values in dB per constellation BPSK-1024QAM.The table is created in the driver from a UserSnrMargin user config parameter and the Snr Margin Offset values.The algorithm for creating the table is as following:\n");
   printf("The user inputs a SNR Margin value, -3 to +25dB in steps of 1/256 dB.\n");
   printf("<b>Default values are still under work. Basically 7xxx is 0dB.\n");
   printf("6816 is 2dB under debug and may also change to 0dB.\n");
   printf("Turbo is 4.5dB.</b>\n");
   printf("\n");
   printf("Lab user may also enter 10 values of offset. Default values are all zeros. This 'offset' feature is not meant for customers to play with, but for advanced lab users. Offset values range is -3 to +25dB in steps of 0.5dB.The driver uses a const reference table with the default values for this array.\n");
   printf("SNR_MARGIN_TABLE[n] = 2* (RefTable[n] + UserSnrMargin + offset[n]) ; n=0..9\n");
   printf("\n");
   printf("In CLI or application, user SNR margin value and SNR Margin Offset values shouldn't be connected as one command, i.e. the user will be able to update snr margin without the need to a new set for the SNR margin offset.\n");
   printf("\n");
   printf("The array has 12 entries and the 11th entry (index 10) will be the userSnrMargin as given in CLI, multiplied by 256. This value is used by the MoCA core in RLAPM calculation.\n");
   printf("\n");
   printf("Entries from index 11 to 20 will hold the offset values specified by the user in units of 1/256 dB.\n");

   printf("\nmocap set --snr_margin_table_ofdma <options>\n");
   printf("options:\n");
   printf("   mgntable   <uint16 value> <index> <end index (optional)>\n");
}

MOCALIB_CLI_SET static int mocacli_set_snr_margin_table_ofdma_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_table_ofdma snr_margin_table_ofdma;

   if (handle != NULL)
   {
      ret = __moca_get_snr_margin_table_ofdma(handle, &snr_margin_table_ofdma);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "mgntable"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_snr_margin_table_ofdma__mgntable_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint16_array(&pp_parms, &num_parms, &snr_margin_table_ofdma.mgntable[0], 1);
            if (ret != 0)
            {
               mocacli_snr_margin_table_ofdma__mgntable_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_snr_margin_table_ofdma_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = __moca_set_snr_margin_table_ofdma(handle, &snr_margin_table_ofdma);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_rlapm_table_100__rlapmtable_help(void)
{
   printf("rlapmtable[66]:\n");
   printf("===============\n");
   printf("\nValues:\n");
   printf("Units are 0.5 dB \n");
   printf("\n");
   printf("Default values: \n");
   printf("\n");
   printf("Table[21]= (unsigned char) (0.5 *2) \n");
   printf("Table[22]= (unsigned char) (0.5 *2) \n");
   printf("Table[23]= (unsigned char) (0.5 *2) \n");
   printf("Table[24]= (unsigned char) (0.5 *2) \n");
   printf("Table[25]= (unsigned char) (0.5 *2) \n");
   printf("Table[26]= (unsigned char) (1.0 *2) \n");
   printf("Table[27]= (unsigned char) (1.0 *2) \n");
   printf("Table[28]= (unsigned char) (1.0 *2) \n");
   printf("Table[29]= (unsigned char) (1.5 *2) \n");
   printf("Table[30]= (unsigned char) (1.5 *2) \n");
   printf("Table[31]= (unsigned char) (2.0 *2) \n");
   printf("Table[32]= (unsigned char) (2.5 *2) \n");
   printf("Table[33]= (unsigned char) (3.0 *2) \n");
   printf("Table[34]= (unsigned char) (3.5 *2) \n");
   printf("Table[35]= (unsigned char) (4.0 *2) \n");
   printf("Table[36]= (unsigned char) (4.5 *2) \n");
   printf("Table[37]= (unsigned char) (5.5 *2) \n");
   printf("Table[38]= (unsigned char) (6.5 *2) \n");
   printf("Table[39]= (unsigned char) (7.5 *2) \n");
   printf("Table[40]= (unsigned char) (8.5 *2) \n");
   printf("Table[41]= (unsigned char) (9.5 *2) \n");
   printf("Table[42]= (unsigned char) (10.5 *2) \n");
   printf("Table[43]= (unsigned char) (10.5 *2) \n");
   printf("Table[44]= (unsigned char) (11.5 *2) \n");
   printf("Table[45]= (unsigned char) (12.5 *2) \n");
   printf("Table[46]= (unsigned char) (13.5 *2) \n");
   printf("Table[47]= (unsigned char) (14.5 *2) \n");
   printf("Table[48]= (unsigned char) (14.5 *2) \n");
   printf("Table[49]= (unsigned char) (15.0 *2) \n");
   printf("Table[50]= (unsigned char) (15.0 *2) \n");
   printf("Table[51]= (unsigned char) (15.0 *2) \n");
   printf("Table[52..65]= (unsigned char) (16.0 *2)\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("60 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_rlapm_table_100_help( void )
{
   printf("An array of Margin Adjustments per RX power for 100 MHz channel (MoCA 2.0) transmissions. \n");
   printf("First value is for 0dBm received power. \n");
   printf("Last value is for -65dBm received power. \n");
   printf(" \n");
   printf("The dB values for adjustments are multiplied by 2, in order to allow 1/2 dB resolution.\n");

   printf("\nmocap get --rlapm_table_100\n");
}

MOCALIB_CLI_GET static int mocacli_get_rlapm_table_100_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_rlapm_table_100 rlapm_table_100;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_rlapm_table_100_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&rlapm_table_100, 0, sizeof(rlapm_table_100));

      ret = moca_get_rlapm_table_100(handle, &rlapm_table_100);

      if (ret == 0) {
         mocacli_print_rlapm_table_100(&rlapm_table_100);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_rlapm_table_100_help( void )
{
   printf("An array of Margin Adjustments per RX power for 100 MHz channel (MoCA 2.0) transmissions. \n");
   printf("First value is for 0dBm received power. \n");
   printf("Last value is for -65dBm received power. \n");
   printf(" \n");
   printf("The dB values for adjustments are multiplied by 2, in order to allow 1/2 dB resolution.\n");

   printf("\nmocap set --rlapm_table_100 <options>\n");
   printf("options:\n");
   printf("   rlapmtable   <uint8 value> <index> <end index (optional)>\n");
}

MOCALIB_CLI_SET static int mocacli_set_rlapm_table_100_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_rlapm_table_100 rlapm_table_100;

   if (handle != NULL)
   {
      ret = moca_get_rlapm_table_100(handle, &rlapm_table_100);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "rlapmtable"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_rlapm_table_100__rlapmtable_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint8_array(&pp_parms, &num_parms, &rlapm_table_100.rlapmtable[0], 1);
            if (ret != 0)
            {
               mocacli_rlapm_table_100__rlapmtable_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_rlapm_table_100_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_rlapm_table_100(handle, &rlapm_table_100);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_cplength__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("64 to 255. 0 will disable\n");
   printf("Maximum:\n");
   printf("255 \n");
}

MOCALIB_CLI_HELP static void mocacli_set_cplength_help( void )
{
   printf("Force the CP Length to requested value.\n");

   printf("\nmocap set --cplength <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_cplength_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t cplength;

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_cplength_help();
            mocacli_cplength__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &cplength);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_cplength__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_cplength(handle, cplength);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_rx_gain_params__table_index_help(void)
{
   printf("table_index:\n");
   printf("============\n");
}

MOCALIB_CLI_HELP static void mocacli_get_rx_gain_params_help( void )
{
   printf("This function returns the RX gain general parameters \n");

   printf("\nmocap get --rx_gain_params <uint32 table_index>\n");
}

MOCALIB_CLI_HELP static void mocacli_rx_gain_agc_table__table_index_help(void)
{
   printf("table_index:\n");
   printf("============\n");
}

MOCALIB_CLI_HELP static void mocacli_get_rx_gain_agc_table_help( void )
{
   printf("This function returns the agc table\n");

   printf("\nmocap get --rx_gain_agc_table <uint32 table_index>\n");
}

MOCALIB_CLI_HELP static void mocacli_tx_power_params__channelMode_help(void)
{
   printf("channelMode:\n");
   printf("============\n");
}

MOCALIB_CLI_HELP static void mocacli_tx_power_params__txTableIndex_help(void)
{
   printf("txTableIndex:\n");
   printf("=============\n");
}

MOCALIB_CLI_HELP static void mocacli_get_tx_power_params_help( void )
{
   printf("This function returns the TX power parameters for the specified channel.\n channel mode <0-beacon, 1-primary, 2- secondary>\n txTableIndex <0x0-Single index 0, 0x10-Bonded index 0, 0x11-Bonded index 1,0x12-Bonded index 2,0x13- Bonded index 3,0x14-Bonded index 4>\n");

   printf("\nmocap get --tx_power_params <options>\n");
   printf("options:\n");
   printf("   channelMode    <uint32>\n");
   printf("   txTableIndex   <uint32>\n");
}

MOCALIB_CLI_HELP static void mocacli_snr_margin_table_ldpc_pri_ch__mgntable_help(void)
{
   printf("mgntable[22]:\n");
   printf("=============\n");
   printf("\nValues:\n");
   printf("Units are 1/256 dB \n");
   printf("Defaults:\n");
   printf("mgntable[0] = (int) (256 * (3.8 + 1.8 + 1))\n");
   printf("mgntable[1] = (int) (256 * (6.8 + 1.8 + 1))\n");
   printf("mgntable[2] = (int) (256 * (10.8 + 1.8 + 1))\n");
   printf("mgntable[3] = (int) (256 * (13.3 + 1.8 + 1))\n");
   printf("mgntable[4] = (int) (256 * (16.5 + 1.8 + 1))\n");
   printf("mgntable[5] = (int) (256 * (19.1 + 1.8 + 1))\n");
   printf("mgntable[6] = (int) (256 * (22 + 1.8 + 1))\n");
   printf("mgntable[7] = (int) (256 * (24.6 + 1.8 + 1))\n");
   printf("mgntable[8] = (int) (256 * (27.4 + 1.8 + 1 + 1))\n");
   printf("mgntable[9] = (int) (256 * (30.2 + 1.8 + 1 + 2))\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("12800 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_snr_margin_table_ldpc_pri_ch_help( void )
{
   printf("A table of 10 values representing the LDPC SNR Margin values in dB per constellation BPSK-1024QAM for the primary channel in bonded mode operation.The table is created in the driver from a UserSnrMargin user config parameter and the Snr Margin Offset values.The algorithm for creating the table is as following:\n");
   printf("The user inputs a SNR Margin value, -3 to +25dB in steps of 1/256 dB.\n");
   printf("\n");
   printf("Lab user may also enter 10 values of offset. Default values are all zeros. This 'offset' feature is not meant for customers to play with, but for advanced lab users. Offset values range is -3 to +25dB in steps of 0.5dB.The driver uses a const reference table with the default values for this array.\n");
   printf("SNR_MARGIN_TABLE[n] = 2* (RefTable[n] + UserSnrMargin + offset[n]) ; n=0..9\n");
   printf("\n");
   printf("In CLI or application, user SNR margin value and SNR Margin Offset values shouldn't be connected as one command, i.e. the user will be able to update snr margin without the need to a new set for the SNR margin offset.\n");
   printf("\n");
   printf("The array has 12 entries and the 11th entry (index 10) will be the userSnrMargin as given in CLI, multiplied by 256. This value is used by the MoCA core in RLAPM calculation.\n");
   printf("\n");
   printf("Entries from index 11 to 20 will hold the offset values specified by the user in units of 1/256 dB.\n");

   printf("\nmocap get --snr_margin_table_ldpc_pri_ch\n");
}

MOCALIB_CLI_GET static int mocacli_get_snr_margin_table_ldpc_pri_ch_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_table_ldpc_pri_ch snr_margin_table_ldpc_pri_ch;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_snr_margin_table_ldpc_pri_ch_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&snr_margin_table_ldpc_pri_ch, 0, sizeof(snr_margin_table_ldpc_pri_ch));

      ret = __moca_get_snr_margin_table_ldpc_pri_ch(handle, &snr_margin_table_ldpc_pri_ch);

      if (ret == 0) {
         mocacli_print_snr_margin_table_ldpc_pri_ch(&snr_margin_table_ldpc_pri_ch);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_snr_margin_table_ldpc_pri_ch_help( void )
{
   printf("A table of 10 values representing the LDPC SNR Margin values in dB per constellation BPSK-1024QAM for the primary channel in bonded mode operation.The table is created in the driver from a UserSnrMargin user config parameter and the Snr Margin Offset values.The algorithm for creating the table is as following:\n");
   printf("The user inputs a SNR Margin value, -3 to +25dB in steps of 1/256 dB.\n");
   printf("\n");
   printf("Lab user may also enter 10 values of offset. Default values are all zeros. This 'offset' feature is not meant for customers to play with, but for advanced lab users. Offset values range is -3 to +25dB in steps of 0.5dB.The driver uses a const reference table with the default values for this array.\n");
   printf("SNR_MARGIN_TABLE[n] = 2* (RefTable[n] + UserSnrMargin + offset[n]) ; n=0..9\n");
   printf("\n");
   printf("In CLI or application, user SNR margin value and SNR Margin Offset values shouldn't be connected as one command, i.e. the user will be able to update snr margin without the need to a new set for the SNR margin offset.\n");
   printf("\n");
   printf("The array has 12 entries and the 11th entry (index 10) will be the userSnrMargin as given in CLI, multiplied by 256. This value is used by the MoCA core in RLAPM calculation.\n");
   printf("\n");
   printf("Entries from index 11 to 20 will hold the offset values specified by the user in units of 1/256 dB.\n");

   printf("\nmocap set --snr_margin_table_ldpc_pri_ch <options>\n");
   printf("options:\n");
   printf("   mgntable   <uint16 value> <index> <end index (optional)>\n");
}

MOCALIB_CLI_SET static int mocacli_set_snr_margin_table_ldpc_pri_ch_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_table_ldpc_pri_ch snr_margin_table_ldpc_pri_ch;

   if (handle != NULL)
   {
      ret = __moca_get_snr_margin_table_ldpc_pri_ch(handle, &snr_margin_table_ldpc_pri_ch);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "mgntable"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_snr_margin_table_ldpc_pri_ch__mgntable_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint16_array(&pp_parms, &num_parms, &snr_margin_table_ldpc_pri_ch.mgntable[0], 1);
            if (ret != 0)
            {
               mocacli_snr_margin_table_ldpc_pri_ch__mgntable_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_snr_margin_table_ldpc_pri_ch_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = __moca_set_snr_margin_table_ldpc_pri_ch(handle, &snr_margin_table_ldpc_pri_ch);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_snr_margin_table_pre5_pri_ch__mgntable_help(void)
{
   printf("mgntable[22]:\n");
   printf("=============\n");
   printf("\nValues:\n");
   printf("Units are 1/256 dB \n");
   printf("Defaults:\n");
   printf("mgntable[0] = (int) (256 * (3.8 + 1.8 + 2.2))\n");
   printf("mgntable[1] = (int) (256 * (6.8 + 1.8 + 2.2))\n");
   printf("mgntable[2] = (int) (256 * (10.8 + 1.8 + 2.2))\n");
   printf("mgntable[3] = (int) (256 * (13.3 + 1.8 + 2.2))\n");
   printf("mgntable[4] = (int) (256 * (16.5 + 1.8 + 2.2))\n");
   printf("mgntable[5] = (int) (256 * (19.1 + 1.8 + 2.2))\n");
   printf("mgntable[6] = (int) (256 * (22 + 1.8 + 2.2))\n");
   printf("mgntable[7] = (int) (256 * (24.6 + 1.8 + 2.2))\n");
   printf("mgntable[8] = (int) (256 * (27.4 + 1.8 + 2.2 + 1))\n");
   printf("mgntable[9] = (int) (256 * (30.2 + 1.8 + 2.2 + 2))\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("12800 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_snr_margin_table_pre5_pri_ch_help( void )
{
   printf("A table of 10 values representing the LDPC SNR Margin values in dB per constellation BPSK-1024QAM for the primary channel in bonded mode operation.The table is created in the driver from a UserSnrMargin user config parameter and the Snr Margin Offset values.The algorithm for creating the table is as following:\n");
   printf("The user inputs a SNR Margin value, -3 to +25dB in steps of 1/256 dB.\n");
   printf("\n");
   printf("Lab user may also enter 10 values of offset. Default values are all zeros. This 'offset' feature is not meant for customers to play with, but for advanced lab users. Offset values range is -3 to +25dB in steps of 0.5dB.The driver uses a const reference table with the default values for this array.\n");
   printf("SNR_MARGIN_TABLE[n] = 2* (RefTable[n] + UserSnrMargin + offset[n]) ; n=0..9\n");
   printf("\n");
   printf("In CLI or application, user SNR margin value and SNR Margin Offset values shouldn't be connected as one command, i.e. the user will be able to update snr margin without the need to a new set for the SNR margin offset.\n");
   printf("\n");
   printf("The array has 12 entries and the 11th entry (index 10) will be the userSnrMargin as given in CLI, multiplied by 256. This value is used by the MoCA core in RLAPM calculation.\n");
   printf("\n");
   printf("Entries from index 11 to 20 will hold the offset values specified by the user in units of 1/256 dB.\n");

   printf("\nmocap get --snr_margin_table_pre5_pri_ch\n");
}

MOCALIB_CLI_GET static int mocacli_get_snr_margin_table_pre5_pri_ch_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_table_pre5_pri_ch snr_margin_table_pre5_pri_ch;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_snr_margin_table_pre5_pri_ch_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&snr_margin_table_pre5_pri_ch, 0, sizeof(snr_margin_table_pre5_pri_ch));

      ret = __moca_get_snr_margin_table_pre5_pri_ch(handle, &snr_margin_table_pre5_pri_ch);

      if (ret == 0) {
         mocacli_print_snr_margin_table_pre5_pri_ch(&snr_margin_table_pre5_pri_ch);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_snr_margin_table_pre5_pri_ch_help( void )
{
   printf("A table of 10 values representing the LDPC SNR Margin values in dB per constellation BPSK-1024QAM for the primary channel in bonded mode operation.The table is created in the driver from a UserSnrMargin user config parameter and the Snr Margin Offset values.The algorithm for creating the table is as following:\n");
   printf("The user inputs a SNR Margin value, -3 to +25dB in steps of 1/256 dB.\n");
   printf("\n");
   printf("Lab user may also enter 10 values of offset. Default values are all zeros. This 'offset' feature is not meant for customers to play with, but for advanced lab users. Offset values range is -3 to +25dB in steps of 0.5dB.The driver uses a const reference table with the default values for this array.\n");
   printf("SNR_MARGIN_TABLE[n] = 2* (RefTable[n] + UserSnrMargin + offset[n]) ; n=0..9\n");
   printf("\n");
   printf("In CLI or application, user SNR margin value and SNR Margin Offset values shouldn't be connected as one command, i.e. the user will be able to update snr margin without the need to a new set for the SNR margin offset.\n");
   printf("\n");
   printf("The array has 12 entries and the 11th entry (index 10) will be the userSnrMargin as given in CLI, multiplied by 256. This value is used by the MoCA core in RLAPM calculation.\n");
   printf("\n");
   printf("Entries from index 11 to 20 will hold the offset values specified by the user in units of 1/256 dB.\n");

   printf("\nmocap set --snr_margin_table_pre5_pri_ch <options>\n");
   printf("options:\n");
   printf("   mgntable   <uint16 value> <index> <end index (optional)>\n");
}

MOCALIB_CLI_SET static int mocacli_set_snr_margin_table_pre5_pri_ch_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_table_pre5_pri_ch snr_margin_table_pre5_pri_ch;

   if (handle != NULL)
   {
      ret = __moca_get_snr_margin_table_pre5_pri_ch(handle, &snr_margin_table_pre5_pri_ch);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "mgntable"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_snr_margin_table_pre5_pri_ch__mgntable_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint16_array(&pp_parms, &num_parms, &snr_margin_table_pre5_pri_ch.mgntable[0], 1);
            if (ret != 0)
            {
               mocacli_snr_margin_table_pre5_pri_ch__mgntable_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_snr_margin_table_pre5_pri_ch_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = __moca_set_snr_margin_table_pre5_pri_ch(handle, &snr_margin_table_pre5_pri_ch);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_snr_margin_table_pre5_sec_ch__mgntable_help(void)
{
   printf("mgntable[22]:\n");
   printf("=============\n");
   printf("\nValues:\n");
   printf("Units are 1/256 dB \n");
   printf("Defaults:\n");
   printf("mgntable[0] = (int) (256 * (3.8 + 1.8 + 2.2))\n");
   printf("mgntable[1] = (int) (256 * (6.8 + 1.8 + 2.2))\n");
   printf("mgntable[2] = (int) (256 * (10.8 + 1.8 + 2.2))\n");
   printf("mgntable[3] = (int) (256 * (13.3 + 1.8 + 2.2))\n");
   printf("mgntable[4] = (int) (256 * (16.5 + 1.8 + 2.2))\n");
   printf("mgntable[5] = (int) (256 * (19.1 + 1.8 + 2.2))\n");
   printf("mgntable[6] = (int) (256 * (22 + 1.8 + 2.2))\n");
   printf("mgntable[7] = (int) (256 * (24.6 + 1.8 + 2.2))\n");
   printf("mgntable[8] = (int) (256 * (27.4 + 1.8 + 2.2 + 1))\n");
   printf("mgntable[9] = (int) (256 * (30.2 + 1.8 + 2.2 + 2))\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("12800 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_snr_margin_table_pre5_sec_ch_help( void )
{
   printf("A table of 10 values representing the LDPC SNR Margin values in dB per constellation BPSK-1024QAM for the secondary channel in bonded mode operation.The table is created in the driver from a UserSnrMargin user config parameter and the Snr Margin Offset values.The algorithm for creating the table is as following:\n");
   printf("The user inputs a SNR Margin value, -3 to +25dB in steps of 1/256 dB.\n");
   printf("<b>Default values are still under work. Basically 7xxx is 0dB.\n");
   printf("6816 is 2dB under debug and may also change to 0dB.\n");
   printf("Turbo is 4.5dB.</b>\n");
   printf("\n");
   printf("Lab user may also enter 10 values of offset. Default values are all zeros. This 'offset' feature is not meant for customers to play with, but for advanced lab users. Offset values range is -3 to +25dB in steps of 0.5dB.The driver uses a const reference table with the default values for this array.\n");
   printf("SNR_MARGIN_TABLE[n] = 2* (RefTable[n] + UserSnrMargin + offset[n]) ; n=0..9\n");
   printf("\n");
   printf("In CLI or application, user SNR margin value and SNR Margin Offset values shouldn't be connected as one command, i.e. the user will be able to update snr margin without the need to a new set for the SNR margin offset.\n");
   printf("\n");
   printf("The array has 12 entries and the 11th entry (index 10) will be the userSnrMargin as given in CLI, multiplied by 256. This value is used by the MoCA core in RLAPM calculation.\n");
   printf("\n");
   printf("Entries from index 11 to 20 will hold the offset values specified by the user in units of 1/256 dB.\n");

   printf("\nmocap get --snr_margin_table_pre5_sec_ch\n");
}

MOCALIB_CLI_GET static int mocacli_get_snr_margin_table_pre5_sec_ch_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_table_pre5_sec_ch snr_margin_table_pre5_sec_ch;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_snr_margin_table_pre5_sec_ch_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&snr_margin_table_pre5_sec_ch, 0, sizeof(snr_margin_table_pre5_sec_ch));

      ret = __moca_get_snr_margin_table_pre5_sec_ch(handle, &snr_margin_table_pre5_sec_ch);

      if (ret == 0) {
         mocacli_print_snr_margin_table_pre5_sec_ch(&snr_margin_table_pre5_sec_ch);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_snr_margin_table_pre5_sec_ch_help( void )
{
   printf("A table of 10 values representing the LDPC SNR Margin values in dB per constellation BPSK-1024QAM for the secondary channel in bonded mode operation.The table is created in the driver from a UserSnrMargin user config parameter and the Snr Margin Offset values.The algorithm for creating the table is as following:\n");
   printf("The user inputs a SNR Margin value, -3 to +25dB in steps of 1/256 dB.\n");
   printf("<b>Default values are still under work. Basically 7xxx is 0dB.\n");
   printf("6816 is 2dB under debug and may also change to 0dB.\n");
   printf("Turbo is 4.5dB.</b>\n");
   printf("\n");
   printf("Lab user may also enter 10 values of offset. Default values are all zeros. This 'offset' feature is not meant for customers to play with, but for advanced lab users. Offset values range is -3 to +25dB in steps of 0.5dB.The driver uses a const reference table with the default values for this array.\n");
   printf("SNR_MARGIN_TABLE[n] = 2* (RefTable[n] + UserSnrMargin + offset[n]) ; n=0..9\n");
   printf("\n");
   printf("In CLI or application, user SNR margin value and SNR Margin Offset values shouldn't be connected as one command, i.e. the user will be able to update snr margin without the need to a new set for the SNR margin offset.\n");
   printf("\n");
   printf("The array has 12 entries and the 11th entry (index 10) will be the userSnrMargin as given in CLI, multiplied by 256. This value is used by the MoCA core in RLAPM calculation.\n");
   printf("\n");
   printf("Entries from index 11 to 20 will hold the offset values specified by the user in units of 1/256 dB.\n");

   printf("\nmocap set --snr_margin_table_pre5_sec_ch <options>\n");
   printf("options:\n");
   printf("   mgntable   <uint16 value> <index> <end index (optional)>\n");
}

MOCALIB_CLI_SET static int mocacli_set_snr_margin_table_pre5_sec_ch_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_table_pre5_sec_ch snr_margin_table_pre5_sec_ch;

   if (handle != NULL)
   {
      ret = __moca_get_snr_margin_table_pre5_sec_ch(handle, &snr_margin_table_pre5_sec_ch);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "mgntable"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_snr_margin_table_pre5_sec_ch__mgntable_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint16_array(&pp_parms, &num_parms, &snr_margin_table_pre5_sec_ch.mgntable[0], 1);
            if (ret != 0)
            {
               mocacli_snr_margin_table_pre5_sec_ch__mgntable_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_snr_margin_table_pre5_sec_ch_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = __moca_set_snr_margin_table_pre5_sec_ch(handle, &snr_margin_table_pre5_sec_ch);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_nv_cal_enable__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = Disable \n");
   printf("1 = Enable\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_nv_cal_enable_help( void )
{
   printf("Enable the mechanism whereby the MoCA firmware will reuse RF calibration data and Probe II results from previous boots. The data is stored by the host for use on subsequent MoCA core boots. This mechanism decreases the MoCA firmware boot time.\n");

   printf("\nmocap get --nv_cal_enable\n");
}

MOCALIB_CLI_GET static int mocacli_get_nv_cal_enable_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t nv_cal_enable;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_nv_cal_enable_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&nv_cal_enable, 0, sizeof(nv_cal_enable));

      ret = moca_get_nv_cal_enable(handle, &nv_cal_enable);

      if (ret == 0) {
         mocacli_print_nv_cal_enable(&nv_cal_enable);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_nv_cal_enable_help( void )
{
   printf("Enable the mechanism whereby the MoCA firmware will reuse RF calibration data and Probe II results from previous boots. The data is stored by the host for use on subsequent MoCA core boots. This mechanism decreases the MoCA firmware boot time.\n");

   printf("\nmocap set --nv_cal_enable <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_nv_cal_enable_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t nv_cal_enable;

   if (handle != NULL)
   {
      ret = moca_get_nv_cal_enable(handle, &nv_cal_enable);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_nv_cal_enable_help();
            mocacli_nv_cal_enable__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &nv_cal_enable);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_nv_cal_enable__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_nv_cal_enable(handle, nv_cal_enable);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_rlapm_cap_50__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("In units of 1/2 dB. I.e. A value of 6 = 3dB.\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_rlapm_cap_50_help( void )
{

   printf("\nmocap get --rlapm_cap_50\n");
}

MOCALIB_CLI_GET static int mocacli_get_rlapm_cap_50_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t rlapm_cap_50;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_rlapm_cap_50_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&rlapm_cap_50, 0, sizeof(rlapm_cap_50));

      ret = moca_get_rlapm_cap_50(handle, &rlapm_cap_50);

      if (ret == 0) {
         mocacli_print_rlapm_cap_50(&rlapm_cap_50);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_rlapm_cap_50_help( void )
{

   printf("\nmocap set --rlapm_cap_50 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_rlapm_cap_50_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t rlapm_cap_50;

   if (handle != NULL)
   {
      ret = moca_get_rlapm_cap_50(handle, &rlapm_cap_50);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_rlapm_cap_50_help();
            mocacli_rlapm_cap_50__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &rlapm_cap_50);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_rlapm_cap_50__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_rlapm_cap_50(handle, rlapm_cap_50);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_snr_margin_rs__base_margin_help(void)
{
   printf("base_margin:\n");
   printf("============\n");
   printf("A base SNR Margin value adjustment in dB which applies to all constellationsfrom BPSK (index 0) to 1024QAM (index 9).SNR base margin value ranges from -3 to +25dB in steps of 1/256 dB.\n");
   printf("\nValues:\n");
   printf("Units are in 1/256 dB\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("-768 \n");
   printf("Maximum:\n");
   printf("6400 \n");
}

MOCALIB_CLI_HELP static void mocacli_snr_margin_rs__offsets_help(void)
{
   printf("offsets[10]:\n");
   printf("============\n");
   printf("A table of 10 values representing the SNR Margin value adjustments in dB per constellation from BPSK (index 0) to 1024QAM (index 9).Offset values range from -3 to +25dB in steps of 1/256 dB.\n");
   printf("\nValues:\n");
   printf("Units are in 1/256 dB\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("-768 \n");
   printf("Maximum:\n");
   printf("6400 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_snr_margin_rs_help( void )
{
   printf("This parameter is used to configure the RS SNR margin on the MoCA interface.The snr_margin feature is intended for use only by advanced lab users. Values range from -3 to +25dB in steps of 1/256 dB. The resulting table entries must have similar or increasing values as the constellation increases.\n");

   printf("\nmocap get --snr_margin_rs\n");
}

MOCALIB_CLI_GET static int mocacli_get_snr_margin_rs_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_rs snr_margin_rs;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_snr_margin_rs_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&snr_margin_rs, 0, sizeof(snr_margin_rs));

      ret = moca_get_snr_margin_rs(handle, &snr_margin_rs);

      if (ret == 0) {
         mocacli_print_snr_margin_rs(&snr_margin_rs);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_snr_margin_rs_help( void )
{
   printf("This parameter is used to configure the RS SNR margin on the MoCA interface.The snr_margin feature is intended for use only by advanced lab users. Values range from -3 to +25dB in steps of 1/256 dB. The resulting table entries must have similar or increasing values as the constellation increases.\n");

   printf("\nmocap set --snr_margin_rs <options>\n");
   printf("options:\n");
   printf("   offsets       <int16 value> <index> <end index (optional)>\n");
   printf("   base_margin   <int32>\n");
}

MOCALIB_CLI_SET static int mocacli_set_snr_margin_rs_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_rs snr_margin_rs;

   if (handle != NULL)
   {
      ret = moca_get_snr_margin_rs(handle, &snr_margin_rs);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "offsets"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_snr_margin_rs__offsets_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_int16_array(&pp_parms, &num_parms, &snr_margin_rs.offsets[0], 1);
            if (ret != 0)
            {
               mocacli_snr_margin_rs__offsets_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "base_margin"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_snr_margin_rs__base_margin_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_int32(*pp_parms, &snr_margin_rs.base_margin);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_snr_margin_rs__base_margin_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_snr_margin_rs_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_snr_margin_rs(handle, &snr_margin_rs);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_snr_margin_ldpc__base_margin_help(void)
{
   printf("base_margin:\n");
   printf("============\n");
   printf("A base SNR Margin value adjustment in dB which applies to all constellationsfrom BPSK (index 0) to 1024QAM (index 9).SNR base margin value ranges from -3 to +25dB in steps of 1/256 dB.\n");
   printf("\nValues:\n");
   printf("Units are in 1/256 dB\n");
   printf("Default:\n");
   printf("0x0 \n");
   printf("Minimum:\n");
   printf("-768 \n");
   printf("Maximum:\n");
   printf("6400 \n");
}

MOCALIB_CLI_HELP static void mocacli_snr_margin_ldpc__offsets_help(void)
{
   printf("offsets[10]:\n");
   printf("============\n");
   printf("A table of 10 values representing the SNR Margin value adjustments in dB per constellation from BPSK (index 0) to 1024QAM (index 9).Offset values range from -3 to +25dB in steps of 1/256 dB.\n");
   printf("\nValues:\n");
   printf("Units are in 1/256 dB\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("-768 \n");
   printf("Maximum:\n");
   printf("6400 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_snr_margin_ldpc_help( void )
{
   printf("This parameter is used to configure the LDPC SNR margin on the MoCA interface.The snr_margin feature is intended for use only by advanced lab users. Values range from -3 to +25dB in steps of 1/256 dB. The resulting table entries must have similar or increasing values as the constellation increases.\n");

   printf("\nmocap get --snr_margin_ldpc\n");
}

MOCALIB_CLI_GET static int mocacli_get_snr_margin_ldpc_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_ldpc snr_margin_ldpc;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_snr_margin_ldpc_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&snr_margin_ldpc, 0, sizeof(snr_margin_ldpc));

      ret = moca_get_snr_margin_ldpc(handle, &snr_margin_ldpc);

      if (ret == 0) {
         mocacli_print_snr_margin_ldpc(&snr_margin_ldpc);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_snr_margin_ldpc_help( void )
{
   printf("This parameter is used to configure the LDPC SNR margin on the MoCA interface.The snr_margin feature is intended for use only by advanced lab users. Values range from -3 to +25dB in steps of 1/256 dB. The resulting table entries must have similar or increasing values as the constellation increases.\n");

   printf("\nmocap set --snr_margin_ldpc <options>\n");
   printf("options:\n");
   printf("   offsets       <int16 value> <index> <end index (optional)>\n");
   printf("   base_margin   <int32>\n");
}

MOCALIB_CLI_SET static int mocacli_set_snr_margin_ldpc_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_ldpc snr_margin_ldpc;

   if (handle != NULL)
   {
      ret = moca_get_snr_margin_ldpc(handle, &snr_margin_ldpc);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "offsets"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_snr_margin_ldpc__offsets_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_int16_array(&pp_parms, &num_parms, &snr_margin_ldpc.offsets[0], 1);
            if (ret != 0)
            {
               mocacli_snr_margin_ldpc__offsets_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "base_margin"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_snr_margin_ldpc__base_margin_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_int32(*pp_parms, &snr_margin_ldpc.base_margin);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_snr_margin_ldpc__base_margin_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_snr_margin_ldpc_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_snr_margin_ldpc(handle, &snr_margin_ldpc);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_snr_margin_ldpc_sec_ch__base_margin_help(void)
{
   printf("base_margin:\n");
   printf("============\n");
   printf("A base SNR Margin value adjustment in dB which applies to all constellationsfrom BPSK (index 0) to 1024QAM (index 9).SNR base margin value ranges from -3 to +25dB in steps of 1/256 dB.\n");
   printf("\nValues:\n");
   printf("Units are in 1/256 dB\n");
   printf("Default:\n");
   printf("0x100 \n");
   printf("Minimum:\n");
   printf("-768 \n");
   printf("Maximum:\n");
   printf("6400 \n");
}

MOCALIB_CLI_HELP static void mocacli_snr_margin_ldpc_sec_ch__offsets_help(void)
{
   printf("offsets[10]:\n");
   printf("============\n");
   printf("A table of 10 values representing the SNR Margin value adjustments in dB per constellation from BPSK (index 0) to 1024QAM (index 9).Offset values range from -3 to +25dB in steps of 1/256 dB.\n");
   printf("\nValues:\n");
   printf("Units are in 1/256 dB\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("-768 \n");
   printf("Maximum:\n");
   printf("6400 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_snr_margin_ldpc_sec_ch_help( void )
{
   printf("This parameter is used to configure the LDPC SNR margin on the secondary channel of the MoCA interface when bonded operation is in effect.The snr_margin feature is intended for use only by advanced lab users. Values range from -3 to +25dB in steps of 1/256 dB. The resulting table entries must have similar or increasing values as the constellation increases.\n");

   printf("\nmocap get --snr_margin_ldpc_sec_ch\n");
}

MOCALIB_CLI_GET static int mocacli_get_snr_margin_ldpc_sec_ch_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_ldpc_sec_ch snr_margin_ldpc_sec_ch;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_snr_margin_ldpc_sec_ch_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&snr_margin_ldpc_sec_ch, 0, sizeof(snr_margin_ldpc_sec_ch));

      ret = moca_get_snr_margin_ldpc_sec_ch(handle, &snr_margin_ldpc_sec_ch);

      if (ret == 0) {
         mocacli_print_snr_margin_ldpc_sec_ch(&snr_margin_ldpc_sec_ch);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_snr_margin_ldpc_sec_ch_help( void )
{
   printf("This parameter is used to configure the LDPC SNR margin on the secondary channel of the MoCA interface when bonded operation is in effect.The snr_margin feature is intended for use only by advanced lab users. Values range from -3 to +25dB in steps of 1/256 dB. The resulting table entries must have similar or increasing values as the constellation increases.\n");

   printf("\nmocap set --snr_margin_ldpc_sec_ch <options>\n");
   printf("options:\n");
   printf("   offsets       <int16 value> <index> <end index (optional)>\n");
   printf("   base_margin   <int32>\n");
}

MOCALIB_CLI_SET static int mocacli_set_snr_margin_ldpc_sec_ch_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_ldpc_sec_ch snr_margin_ldpc_sec_ch;

   if (handle != NULL)
   {
      ret = moca_get_snr_margin_ldpc_sec_ch(handle, &snr_margin_ldpc_sec_ch);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "offsets"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_snr_margin_ldpc_sec_ch__offsets_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_int16_array(&pp_parms, &num_parms, &snr_margin_ldpc_sec_ch.offsets[0], 1);
            if (ret != 0)
            {
               mocacli_snr_margin_ldpc_sec_ch__offsets_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "base_margin"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_snr_margin_ldpc_sec_ch__base_margin_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_int32(*pp_parms, &snr_margin_ldpc_sec_ch.base_margin);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_snr_margin_ldpc_sec_ch__base_margin_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_snr_margin_ldpc_sec_ch_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_snr_margin_ldpc_sec_ch(handle, &snr_margin_ldpc_sec_ch);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_snr_margin_ldpc_pre5__base_margin_help(void)
{
   printf("base_margin:\n");
   printf("============\n");
   printf("A base SNR Margin value adjustment in dB which applies to all constellationsfrom BPSK (index 0) to 1024QAM (index 9).SNR base margin value ranges from -3 to +25dB in steps of 1/256 dB.\n");
   printf("\nValues:\n");
   printf("Units are in 1/256 dB\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("-768 \n");
   printf("Maximum:\n");
   printf("6400 \n");
}

MOCALIB_CLI_HELP static void mocacli_snr_margin_ldpc_pre5__offsets_help(void)
{
   printf("offsets[10]:\n");
   printf("============\n");
   printf("A table of 10 values representing the SNR Margin value adjustments in dB per constellation from BPSK (index 0) to 1024QAM (index 9).Offset values range from -3 to +25dB in steps of 1/256 dB.\n");
   printf("\nValues:\n");
   printf("Units are in 1/256 dB\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("-768 \n");
   printf("Maximum:\n");
   printf("6400 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_snr_margin_ldpc_pre5_help( void )
{
   printf("This parameter is used to configure the LDPC Preamble 5 SNR margin on the MoCA interface.The snr_margin feature is intended for use only by advanced lab users. Values range from -3 to +25dB in steps of 1/256 dB. The resulting table entries must have similar or increasing values as the constellation increases.\n");

   printf("\nmocap get --snr_margin_ldpc_pre5\n");
}

MOCALIB_CLI_GET static int mocacli_get_snr_margin_ldpc_pre5_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_ldpc_pre5 snr_margin_ldpc_pre5;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_snr_margin_ldpc_pre5_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&snr_margin_ldpc_pre5, 0, sizeof(snr_margin_ldpc_pre5));

      ret = moca_get_snr_margin_ldpc_pre5(handle, &snr_margin_ldpc_pre5);

      if (ret == 0) {
         mocacli_print_snr_margin_ldpc_pre5(&snr_margin_ldpc_pre5);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_snr_margin_ldpc_pre5_help( void )
{
   printf("This parameter is used to configure the LDPC Preamble 5 SNR margin on the MoCA interface.The snr_margin feature is intended for use only by advanced lab users. Values range from -3 to +25dB in steps of 1/256 dB. The resulting table entries must have similar or increasing values as the constellation increases.\n");

   printf("\nmocap set --snr_margin_ldpc_pre5 <options>\n");
   printf("options:\n");
   printf("   offsets       <int16 value> <index> <end index (optional)>\n");
   printf("   base_margin   <int32>\n");
}

MOCALIB_CLI_SET static int mocacli_set_snr_margin_ldpc_pre5_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_ldpc_pre5 snr_margin_ldpc_pre5;

   if (handle != NULL)
   {
      ret = moca_get_snr_margin_ldpc_pre5(handle, &snr_margin_ldpc_pre5);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "offsets"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_snr_margin_ldpc_pre5__offsets_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_int16_array(&pp_parms, &num_parms, &snr_margin_ldpc_pre5.offsets[0], 1);
            if (ret != 0)
            {
               mocacli_snr_margin_ldpc_pre5__offsets_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "base_margin"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_snr_margin_ldpc_pre5__base_margin_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_int32(*pp_parms, &snr_margin_ldpc_pre5.base_margin);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_snr_margin_ldpc_pre5__base_margin_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_snr_margin_ldpc_pre5_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_snr_margin_ldpc_pre5(handle, &snr_margin_ldpc_pre5);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_snr_margin_ofdma__base_margin_help(void)
{
   printf("base_margin:\n");
   printf("============\n");
   printf("A base SNR Margin value adjustment in dB which applies to all constellationsfrom BPSK (index 0) to 1024QAM (index 9).SNR base margin value ranges from -3 to +25dB in steps of 1/256 dB.\n");
   printf("\nValues:\n");
   printf("Units are in 1/256 dB\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("-768 \n");
   printf("Maximum:\n");
   printf("6400 \n");
}

MOCALIB_CLI_HELP static void mocacli_snr_margin_ofdma__offsets_help(void)
{
   printf("offsets[10]:\n");
   printf("============\n");
   printf("A table of 10 values representing the SNR Margin value adjustments in dB per constellation from BPSK (index 0) to 1024QAM (index 9).Offset values range from -3 to +25dB in steps of 1/256 dB.\n");
   printf("\nValues:\n");
   printf("Units are in 1/256 dB\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("-768 \n");
   printf("Maximum:\n");
   printf("6400 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_snr_margin_ofdma_help( void )
{
   printf("This parameter is used to configure the OFDMA SNR margin on the MoCA interface.The snr_margin feature is intended for use only by advanced lab users. Values range from -3 to +25dB in steps of 1/256 dB. The resulting table entries must have similar or increasing values as the constellation increases.\n");

   printf("\nmocap get --snr_margin_ofdma\n");
}

MOCALIB_CLI_GET static int mocacli_get_snr_margin_ofdma_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_ofdma snr_margin_ofdma;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_snr_margin_ofdma_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&snr_margin_ofdma, 0, sizeof(snr_margin_ofdma));

      ret = moca_get_snr_margin_ofdma(handle, &snr_margin_ofdma);

      if (ret == 0) {
         mocacli_print_snr_margin_ofdma(&snr_margin_ofdma);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_snr_margin_ofdma_help( void )
{
   printf("This parameter is used to configure the OFDMA SNR margin on the MoCA interface.The snr_margin feature is intended for use only by advanced lab users. Values range from -3 to +25dB in steps of 1/256 dB. The resulting table entries must have similar or increasing values as the constellation increases.\n");

   printf("\nmocap set --snr_margin_ofdma <options>\n");
   printf("options:\n");
   printf("   offsets       <int16 value> <index> <end index (optional)>\n");
   printf("   base_margin   <int32>\n");
}

MOCALIB_CLI_SET static int mocacli_set_snr_margin_ofdma_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_ofdma snr_margin_ofdma;

   if (handle != NULL)
   {
      ret = moca_get_snr_margin_ofdma(handle, &snr_margin_ofdma);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "offsets"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_snr_margin_ofdma__offsets_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_int16_array(&pp_parms, &num_parms, &snr_margin_ofdma.offsets[0], 1);
            if (ret != 0)
            {
               mocacli_snr_margin_ofdma__offsets_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "base_margin"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_snr_margin_ofdma__base_margin_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_int32(*pp_parms, &snr_margin_ofdma.base_margin);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_snr_margin_ofdma__base_margin_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_snr_margin_ofdma_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_snr_margin_ofdma(handle, &snr_margin_ofdma);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_rlapm_cap_100__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("In units of 1/2 dB. I.e. A value of 6 = 3dB.\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_rlapm_cap_100_help( void )
{

   printf("\nmocap get --rlapm_cap_100\n");
}

MOCALIB_CLI_GET static int mocacli_get_rlapm_cap_100_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t rlapm_cap_100;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_rlapm_cap_100_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&rlapm_cap_100, 0, sizeof(rlapm_cap_100));

      ret = moca_get_rlapm_cap_100(handle, &rlapm_cap_100);

      if (ret == 0) {
         mocacli_print_rlapm_cap_100(&rlapm_cap_100);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_rlapm_cap_100_help( void )
{

   printf("\nmocap set --rlapm_cap_100 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_rlapm_cap_100_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t rlapm_cap_100;

   if (handle != NULL)
   {
      ret = moca_get_rlapm_cap_100(handle, &rlapm_cap_100);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_rlapm_cap_100_help();
            mocacli_rlapm_cap_100__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &rlapm_cap_100);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_rlapm_cap_100__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_rlapm_cap_100(handle, rlapm_cap_100);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_sapm_table_50__val_help(void)
{
   printf("val[256]:\n");
   printf("=========\n");
   printf("Array of values indexed by sub-carrier number.\n");
   printf("\nValues:\n");
   printf("Units are 0.5 dB \n");
   printf("\n");
   printf("Default by index for CTP: \n");
   printf("41 = 4 *2 \n");
   printf("42 = 4 *2 \n");
   printf("43 = 4 *2 \n");
   printf("44 = 4 *2 \n");
   printf("45 = 4 *2 \n");
   printf("46 = 4 *2 \n");
   printf("47 = 4 *2 \n");
   printf("48 = 4 *2 \n");
   printf("49 = 7 *2 \n");
   printf("50 = 7 *2 \n");
   printf("51 = 7 *2 \n");
   printf("52 = 7 *2 \n");
   printf("53 = 7 *2 \n");
   printf("54 = 7 *2 \n");
   printf("55 = 7 *2 \n");
   printf("56 = 7 *2 \n");
   printf("57 = 60 *2 \n");
   printf("58 = 60 *2 \n");
   printf("59 = 60 *2 \n");
   printf("60 = 60 *2 \n");
   printf("Other = 0\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("120 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_sapm_table_50_help( void )
{
   printf("Sub-carrier Added PHY Margin table for 50 MHz (MoCA 1.1) transmission profiles.These arrays allows differentiation in SNR margin values per sub carrier. \n");
   printf("\n");
   printf("The values will be passed multiplied by 2, for allowing 0.5dB values.\n");

   printf("\nmocap get --sapm_table_50\n");
}

MOCALIB_CLI_GET static int mocacli_get_sapm_table_50_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_sapm_table_50 sapm_table_50;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_sapm_table_50_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&sapm_table_50, 0, sizeof(sapm_table_50));

      ret = moca_get_sapm_table_50(handle, &sapm_table_50);

      if (ret == 0) {
         mocacli_print_sapm_table_50(&sapm_table_50);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_sapm_table_50_help( void )
{
   printf("Sub-carrier Added PHY Margin table for 50 MHz (MoCA 1.1) transmission profiles.These arrays allows differentiation in SNR margin values per sub carrier. \n");
   printf("\n");
   printf("The values will be passed multiplied by 2, for allowing 0.5dB values.\n");

   printf("\nmocap set --sapm_table_50 <options>\n");
   printf("options:\n");
   printf("   val   <uint8 value> <index> <end index (optional)>\n");
}

MOCALIB_CLI_SET static int mocacli_set_sapm_table_50_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_sapm_table_50 sapm_table_50;

   if (handle != NULL)
   {
      ret = moca_get_sapm_table_50(handle, &sapm_table_50);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "val"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_sapm_table_50__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint8_array(&pp_parms, &num_parms, &sapm_table_50.val[0], 1);
            if (ret != 0)
            {
               mocacli_sapm_table_50__val_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_sapm_table_50_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_sapm_table_50(handle, &sapm_table_50);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_sapm_table_100__val_help(void)
{
   printf("val[512]:\n");
   printf("=========\n");
   printf("Array of values indexed by sub-carrier number.\n");
   printf("\nValues:\n");
   printf("Units are 0.5 dB\n");
   printf("Default by index for CTP: \n");
   printf("41 = 4 *2 \n");
   printf("42 = 4 *2 \n");
   printf("43 = 4 *2 \n");
   printf("44 = 4 *2 \n");
   printf("45 = 4 *2 \n");
   printf("46 = 4 *2 \n");
   printf("47 = 4 *2 \n");
   printf("48 = 4 *2 \n");
   printf("49 = 7 *2 \n");
   printf("50 = 7 *2 \n");
   printf("51 = 7 *2 \n");
   printf("52 = 7 *2 \n");
   printf("53 = 7 *2 \n");
   printf("54 = 7 *2 \n");
   printf("55 = 7 *2 \n");
   printf("56 = 7 *2 \n");
   printf("57 = 60 *2 \n");
   printf("58 = 60 *2 \n");
   printf("59 = 60 *2 \n");
   printf("60 = 60 *2 \n");
   printf("Other = 0\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("120 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_sapm_table_100_help( void )
{
   printf("Sub-carrier Added PHY Margin table for 100 MHz (MoCA 2.0) transmission profiles.These arrays allows differentiation in SNR margin values per sub carrier. \n");
   printf("\n");
   printf("The values will be passed multiplied by 2, for allowing 0.5dB values.\n");

   printf("\nmocap get --sapm_table_100\n");
}

MOCALIB_CLI_GET static int mocacli_get_sapm_table_100_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_sapm_table_100 sapm_table_100;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_sapm_table_100_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&sapm_table_100, 0, sizeof(sapm_table_100));

      ret = moca_get_sapm_table_100(handle, &sapm_table_100);

      if (ret == 0) {
         mocacli_print_sapm_table_100(&sapm_table_100);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_sapm_table_100_help( void )
{
   printf("Sub-carrier Added PHY Margin table for 100 MHz (MoCA 2.0) transmission profiles.These arrays allows differentiation in SNR margin values per sub carrier. \n");
   printf("\n");
   printf("The values will be passed multiplied by 2, for allowing 0.5dB values.\n");

   printf("\nmocap set --sapm_table_100 <options>\n");
   printf("options:\n");
   printf("   val   <uint8 value> <index> <end index (optional)>\n");
}

MOCALIB_CLI_SET static int mocacli_set_sapm_table_100_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_sapm_table_100 sapm_table_100;

   if (handle != NULL)
   {
      ret = moca_get_sapm_table_100(handle, &sapm_table_100);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "val"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_sapm_table_100__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint8_array(&pp_parms, &num_parms, &sapm_table_100.val[0], 1);
            if (ret != 0)
            {
               mocacli_sapm_table_100__val_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_sapm_table_100_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_sapm_table_100(handle, &sapm_table_100);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_nv_cal_clear_help( void )
{
   printf("Clear the NVRAM RF Calibration data. This will force the MoCA core to perform calibration upon the next initialization if NV Calibration is enabled (see nv_cal_enable).\n");

   printf("\nmocap set --nv_cal_clear\n");
}

MOCALIB_CLI_SET static int mocacli_set_nv_cal_clear_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;


   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_set_nv_cal_clear_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   if (handle != NULL)
   {
      ret = moca_set_nv_cal_clear(handle);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_sapm_table_sec__val_help(void)
{
   printf("val[512]:\n");
   printf("=========\n");
   printf("Array of values indexed by sub-carrier number.\n");
   printf("\nValues:\n");
   printf("Units are 0.5 dB\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("120 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_sapm_table_sec_help( void )
{
   printf("Sub-carrier Added PHY Margin table for 100 MHz (MoCA 2.0) secondary channel transmission profiles.These arrays allows differentiation in SNR margin values per sub carrier. \n");
   printf("\n");
   printf("The values will be passed multiplied by 2, for allowing 0.5dB values.\n");

   printf("\nmocap get --sapm_table_sec\n");
}

MOCALIB_CLI_GET static int mocacli_get_sapm_table_sec_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_sapm_table_sec sapm_table_sec;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_sapm_table_sec_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&sapm_table_sec, 0, sizeof(sapm_table_sec));

      ret = moca_get_sapm_table_sec(handle, &sapm_table_sec);

      if (ret == 0) {
         mocacli_print_sapm_table_sec(&sapm_table_sec);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_sapm_table_sec_help( void )
{
   printf("Sub-carrier Added PHY Margin table for 100 MHz (MoCA 2.0) secondary channel transmission profiles.These arrays allows differentiation in SNR margin values per sub carrier. \n");
   printf("\n");
   printf("The values will be passed multiplied by 2, for allowing 0.5dB values.\n");

   printf("\nmocap set --sapm_table_sec <options>\n");
   printf("options:\n");
   printf("   val   <uint8 value> <index> <end index (optional)>\n");
}

MOCALIB_CLI_SET static int mocacli_set_sapm_table_sec_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_sapm_table_sec sapm_table_sec;

   if (handle != NULL)
   {
      ret = moca_get_sapm_table_sec(handle, &sapm_table_sec);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "val"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_sapm_table_sec__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint8_array(&pp_parms, &num_parms, &sapm_table_sec.val[0], 1);
            if (ret != 0)
            {
               mocacli_sapm_table_sec__val_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_sapm_table_sec_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_sapm_table_sec(handle, &sapm_table_sec);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_amp_reg__addr_help(void)
{
   printf("addr:\n");
   printf("=====\n");
   printf("The address of the register to get or set. This function will only succeed when used with kernels that support register access to the PA/LNA chip.\n");
}

MOCALIB_CLI_HELP static void mocacli_amp_reg__value_help(void)
{
   printf("value:\n");
   printf("======\n");
   printf("For set operations, this the value to set the register to.\nFor get operations, this is the value of specified register.\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_amp_reg_help( void )
{
   printf("Read and write registers in the PA/LNA 345x chip.\n");

   printf("\nmocap get --amp_reg <uint32 addr>\n");
}

MOCALIB_CLI_GET static int mocacli_get_amp_reg_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_amp_reg amp_reg;
   int found_addr = 0;
   uint32_t addr;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_amp_reg_help();
      mocacli_amp_reg__addr_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_amp_reg__addr_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &addr);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_amp_reg__addr_help();
               return(ret);
            }
            found_addr = 1;
         }
   }

   if (!found_addr)
   {
      printf("Missing addr parameter.\n");
      return(0);
   }

   if (handle != NULL)
   {
      memset(&amp_reg, 0, sizeof(amp_reg));

      ret = moca_get_amp_reg(handle, addr, &amp_reg);

      if (ret == 0) {
         mocacli_print_amp_reg(&amp_reg);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_amp_reg_help( void )
{
   printf("Read and write registers in the PA/LNA 345x chip.\n");

   printf("\nmocap set --amp_reg <options>\n");
   printf("options:\n");
   printf("   value   <uint32>\n");
   printf("   addr    <uint32>\n");
}

MOCALIB_CLI_SET static int mocacli_set_amp_reg_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_amp_reg amp_reg;
   uint32_t addr = mocacli_find_uint32_t(pp_parms, num_parms, "addr");

   if (handle != NULL)
   {
      ret = moca_get_amp_reg(handle, addr, &amp_reg);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "value"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_amp_reg__value_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &amp_reg.value);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_amp_reg__value_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "addr"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_amp_reg__addr_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &amp_reg.addr);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_amp_reg__addr_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_amp_reg_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_amp_reg(handle, &amp_reg);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_snr_margin_ldpc_pri_ch__base_margin_help(void)
{
   printf("base_margin:\n");
   printf("============\n");
   printf("A base SNR Margin value adjustment in dB which applies to all constellationsfrom BPSK (index 0) to 1024QAM (index 9).SNR base margin value ranges from -3 to +25dB in steps of 1/256 dB.\n");
   printf("\nValues:\n");
   printf("Units are in 1/256 dB\n");
   printf("Default:\n");
   printf("0x100 \n");
   printf("Minimum:\n");
   printf("-768 \n");
   printf("Maximum:\n");
   printf("6400 \n");
}

MOCALIB_CLI_HELP static void mocacli_snr_margin_ldpc_pri_ch__offsets_help(void)
{
   printf("offsets[10]:\n");
   printf("============\n");
   printf("A table of 10 values representing the SNR Margin value adjustments in dB per constellation from BPSK (index 0) to 1024QAM (index 9).Offset values range from -3 to +25dB in steps of 1/256 dB.\n");
   printf("\nValues:\n");
   printf("Units are in 1/256 dB\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("-768 \n");
   printf("Maximum:\n");
   printf("6400 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_snr_margin_ldpc_pri_ch_help( void )
{
   printf("This parameter is used to configure the LDPC SNR margin on the primary channel of the MoCA interface when bonded operation is in effect.The snr_margin feature is intended for use only by advanced lab users. Values range from -3 to +25dB in steps of 1/256 dB. The resulting table entries must have similar or increasing values as the constellation increases.\n");

   printf("\nmocap get --snr_margin_ldpc_pri_ch\n");
}

MOCALIB_CLI_GET static int mocacli_get_snr_margin_ldpc_pri_ch_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_ldpc_pri_ch snr_margin_ldpc_pri_ch;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_snr_margin_ldpc_pri_ch_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&snr_margin_ldpc_pri_ch, 0, sizeof(snr_margin_ldpc_pri_ch));

      ret = moca_get_snr_margin_ldpc_pri_ch(handle, &snr_margin_ldpc_pri_ch);

      if (ret == 0) {
         mocacli_print_snr_margin_ldpc_pri_ch(&snr_margin_ldpc_pri_ch);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_snr_margin_ldpc_pri_ch_help( void )
{
   printf("This parameter is used to configure the LDPC SNR margin on the primary channel of the MoCA interface when bonded operation is in effect.The snr_margin feature is intended for use only by advanced lab users. Values range from -3 to +25dB in steps of 1/256 dB. The resulting table entries must have similar or increasing values as the constellation increases.\n");

   printf("\nmocap set --snr_margin_ldpc_pri_ch <options>\n");
   printf("options:\n");
   printf("   offsets       <int16 value> <index> <end index (optional)>\n");
   printf("   base_margin   <int32>\n");
}

MOCALIB_CLI_SET static int mocacli_set_snr_margin_ldpc_pri_ch_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_ldpc_pri_ch snr_margin_ldpc_pri_ch;

   if (handle != NULL)
   {
      ret = moca_get_snr_margin_ldpc_pri_ch(handle, &snr_margin_ldpc_pri_ch);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "offsets"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_snr_margin_ldpc_pri_ch__offsets_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_int16_array(&pp_parms, &num_parms, &snr_margin_ldpc_pri_ch.offsets[0], 1);
            if (ret != 0)
            {
               mocacli_snr_margin_ldpc_pri_ch__offsets_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "base_margin"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_snr_margin_ldpc_pri_ch__base_margin_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_int32(*pp_parms, &snr_margin_ldpc_pri_ch.base_margin);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_snr_margin_ldpc_pri_ch__base_margin_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_snr_margin_ldpc_pri_ch_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_snr_margin_ldpc_pri_ch(handle, &snr_margin_ldpc_pri_ch);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_snr_margin_pre5_pri_ch__base_margin_help(void)
{
   printf("base_margin:\n");
   printf("============\n");
   printf("A base SNR Margin value adjustment in dB which applies to all constellationsfrom BPSK (index 0) to 1024QAM (index 9).SNR base margin value ranges from -3 to +25dB in steps of 1/256 dB.\n");
   printf("\nValues:\n");
   printf("Units are in 1/256 dB\n");
   printf("Default:\n");
   printf("0x100 \n");
   printf("Minimum:\n");
   printf("-768 \n");
   printf("Maximum:\n");
   printf("6400 \n");
}

MOCALIB_CLI_HELP static void mocacli_snr_margin_pre5_pri_ch__offsets_help(void)
{
   printf("offsets[10]:\n");
   printf("============\n");
   printf("A table of 10 values representing the SNR Margin value adjustments in dB per constellation from BPSK (index 0) to 1024QAM (index 9).Offset values range from -3 to +25dB in steps of 1/256 dB.\n");
   printf("\nValues:\n");
   printf("Units are in 1/256 dB\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("-768 \n");
   printf("Maximum:\n");
   printf("6400 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_snr_margin_pre5_pri_ch_help( void )
{
   printf("This parameter is used to configure the LDPC SNR margin on the primary channel of the MoCA interface when bonded operation is in effect.The snr_margin feature is intended for use only by advanced lab users. Values range from -3 to +25dB in steps of 1/256 dB. The resulting table entries must have similar or increasing values as the constellation increases.\n");

   printf("\nmocap get --snr_margin_pre5_pri_ch\n");
}

MOCALIB_CLI_GET static int mocacli_get_snr_margin_pre5_pri_ch_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_pre5_pri_ch snr_margin_pre5_pri_ch;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_snr_margin_pre5_pri_ch_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&snr_margin_pre5_pri_ch, 0, sizeof(snr_margin_pre5_pri_ch));

      ret = moca_get_snr_margin_pre5_pri_ch(handle, &snr_margin_pre5_pri_ch);

      if (ret == 0) {
         mocacli_print_snr_margin_pre5_pri_ch(&snr_margin_pre5_pri_ch);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_snr_margin_pre5_pri_ch_help( void )
{
   printf("This parameter is used to configure the LDPC SNR margin on the primary channel of the MoCA interface when bonded operation is in effect.The snr_margin feature is intended for use only by advanced lab users. Values range from -3 to +25dB in steps of 1/256 dB. The resulting table entries must have similar or increasing values as the constellation increases.\n");

   printf("\nmocap set --snr_margin_pre5_pri_ch <options>\n");
   printf("options:\n");
   printf("   offsets       <int16 value> <index> <end index (optional)>\n");
   printf("   base_margin   <int32>\n");
}

MOCALIB_CLI_SET static int mocacli_set_snr_margin_pre5_pri_ch_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_pre5_pri_ch snr_margin_pre5_pri_ch;

   if (handle != NULL)
   {
      ret = moca_get_snr_margin_pre5_pri_ch(handle, &snr_margin_pre5_pri_ch);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "offsets"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_snr_margin_pre5_pri_ch__offsets_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_int16_array(&pp_parms, &num_parms, &snr_margin_pre5_pri_ch.offsets[0], 1);
            if (ret != 0)
            {
               mocacli_snr_margin_pre5_pri_ch__offsets_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "base_margin"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_snr_margin_pre5_pri_ch__base_margin_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_int32(*pp_parms, &snr_margin_pre5_pri_ch.base_margin);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_snr_margin_pre5_pri_ch__base_margin_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_snr_margin_pre5_pri_ch_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_snr_margin_pre5_pri_ch(handle, &snr_margin_pre5_pri_ch);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_snr_margin_pre5_sec_ch__base_margin_help(void)
{
   printf("base_margin:\n");
   printf("============\n");
   printf("A base SNR Margin value adjustment in dB which applies to all constellationsfrom BPSK (index 0) to 1024QAM (index 9).SNR base margin value ranges from -3 to +25dB in steps of 1/256 dB.\n");
   printf("\nValues:\n");
   printf("Units are in 1/256 dB\n");
   printf("Default:\n");
   printf("0x100 \n");
   printf("Minimum:\n");
   printf("-768 \n");
   printf("Maximum:\n");
   printf("6400 \n");
}

MOCALIB_CLI_HELP static void mocacli_snr_margin_pre5_sec_ch__offsets_help(void)
{
   printf("offsets[10]:\n");
   printf("============\n");
   printf("A table of 10 values representing the SNR Margin value adjustments in dB per constellation from BPSK (index 0) to 1024QAM (index 9).Offset values range from -3 to +25dB in steps of 1/256 dB.\n");
   printf("\nValues:\n");
   printf("Units are in 1/256 dB\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("-768 \n");
   printf("Maximum:\n");
   printf("6400 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_snr_margin_pre5_sec_ch_help( void )
{
   printf("This parameter is used to configure the LDPC SNR margin on the primary channel of the MoCA interface when bonded operation is in effect.The snr_margin feature is intended for use only by advanced lab users. Values range from -3 to +25dB in steps of 1/256 dB. The resulting table entries must have similar or increasing values as the constellation increases.\n");

   printf("\nmocap get --snr_margin_pre5_sec_ch\n");
}

MOCALIB_CLI_GET static int mocacli_get_snr_margin_pre5_sec_ch_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_pre5_sec_ch snr_margin_pre5_sec_ch;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_snr_margin_pre5_sec_ch_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&snr_margin_pre5_sec_ch, 0, sizeof(snr_margin_pre5_sec_ch));

      ret = moca_get_snr_margin_pre5_sec_ch(handle, &snr_margin_pre5_sec_ch);

      if (ret == 0) {
         mocacli_print_snr_margin_pre5_sec_ch(&snr_margin_pre5_sec_ch);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_snr_margin_pre5_sec_ch_help( void )
{
   printf("This parameter is used to configure the LDPC SNR margin on the primary channel of the MoCA interface when bonded operation is in effect.The snr_margin feature is intended for use only by advanced lab users. Values range from -3 to +25dB in steps of 1/256 dB. The resulting table entries must have similar or increasing values as the constellation increases.\n");

   printf("\nmocap set --snr_margin_pre5_sec_ch <options>\n");
   printf("options:\n");
   printf("   offsets       <int16 value> <index> <end index (optional)>\n");
   printf("   base_margin   <int32>\n");
}

MOCALIB_CLI_SET static int mocacli_set_snr_margin_pre5_sec_ch_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_snr_margin_pre5_sec_ch snr_margin_pre5_sec_ch;

   if (handle != NULL)
   {
      ret = moca_get_snr_margin_pre5_sec_ch(handle, &snr_margin_pre5_sec_ch);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "offsets"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_snr_margin_pre5_sec_ch__offsets_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_int16_array(&pp_parms, &num_parms, &snr_margin_pre5_sec_ch.offsets[0], 1);
            if (ret != 0)
            {
               mocacli_snr_margin_pre5_sec_ch__offsets_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "base_margin"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_snr_margin_pre5_sec_ch__base_margin_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_int32(*pp_parms, &snr_margin_pre5_sec_ch.base_margin);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_snr_margin_pre5_sec_ch__base_margin_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_snr_margin_pre5_sec_ch_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_snr_margin_pre5_sec_ch(handle, &snr_margin_pre5_sec_ch);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_GET static int mocacli_get_phy_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   char **tmpPtr = pp_parms; 
   int nump = num_parms; 
   int i0; 
   char pstr[1][MAX_STRING_LENGTH]; 
   char *gOptmp[1]; 


   while (nump > 0)
   {
      if ((nump != 0) && !strcmp(*tmpPtr, "help"))
      {
         printf("The PHY group of parameters control the physical layer of the MoCA interface.\n");
         printf("IE list for this group: \n"); 
         printf("======================= \n"); 
         printf("tpc_en\n"); 
         printf("max_tx_power\n"); 
         printf("beacon_pwr_reduction\n"); 
         printf("beacon_pwr_reduction_en\n"); 
         printf("bo_mode\n"); 
         printf("qam256_capability\n"); 
         printf("otf_en\n"); 
         printf("star_topology_en\n"); 
         printf("ofdma_en\n"); 
         printf("min_bw_alarm_threshold\n"); 
         printf("target_phy_rate_qam128\n"); 
         printf("target_phy_rate_qam256\n"); 
         printf("sapm_en\n"); 
         printf("arpl_th_50\n"); 
         printf("rlapm_en\n"); 
         printf("freq_shift\n"); 
         printf("max_phy_rate\n"); 
         printf("bandwidth\n"); 
         printf("arpl_th_100\n"); 
         printf("adc_mode\n"); 
         printf("max_phy_rate_turbo\n"); 
         printf("cp_const\n"); 
         printf("preamble_uc_const\n"); 
         printf("cp_margin_increase\n"); 
         printf("ac_cc_shift\n"); 
         printf("mfc_th_increase\n"); 
         printf("agc_const_en\n"); 
         printf("agc_const_address\n"); 
         printf("min_bo_insert_2_bfm_lock\n"); 
         printf("min_snr_avg_db_2_bfm_lock\n"); 
         printf("max_phy_rate_50M\n"); 
         printf("max_constellation_all\n"); 
         printf("max_constellation\n"); 
         printf("snr_margin_table_rs\n"); 
         printf("rlapm_table_50\n"); 
         printf("phy_status\n"); 
         printf("snr_margin_table_ldpc\n"); 
         printf("snr_margin_table_ldpc_sec_ch\n"); 
         printf("snr_margin_table_ldpc_pre5\n"); 
         printf("snr_margin_table_ofdma\n"); 
         printf("rlapm_table_100\n"); 
         printf("rx_gain_params\n"); 
         printf("rx_gain_agc_table\n"); 
         printf("tx_power_params\n"); 
         printf("snr_margin_table_ldpc_pri_ch\n"); 
         printf("snr_margin_table_pre5_pri_ch\n"); 
         printf("snr_margin_table_pre5_sec_ch\n"); 
         printf("nv_cal_enable\n"); 
         printf("rlapm_cap_50\n"); 
         printf("snr_margin_rs\n"); 
         printf("snr_margin_ldpc\n"); 
         printf("snr_margin_ldpc_sec_ch\n"); 
         printf("snr_margin_ldpc_pre5\n"); 
         printf("snr_margin_ofdma\n"); 
         printf("rlapm_cap_100\n"); 
         printf("sapm_table_50\n"); 
         printf("sapm_table_100\n"); 
         printf("sapm_table_sec\n"); 
         printf("amp_reg\n"); 
         printf("snr_margin_ldpc_pri_ch\n"); 
         printf("snr_margin_pre5_pri_ch\n"); 
         printf("snr_margin_pre5_sec_ch\n"); 
         return(0); 
      }
      tmpPtr++;
      nump--;
  }

   for( i0 = 0 ; i0 < 1; i0++ )
   {
       gOptmp[i0]=&pstr[i0][0];
   }

   if (handle != NULL)
   {
      ret = mocacli_get_tpc_en_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_max_tx_power_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_beacon_pwr_reduction_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_beacon_pwr_reduction_en_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_bo_mode_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_qam256_capability_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_otf_en_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_star_topology_en_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_ofdma_en_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_min_bw_alarm_threshold_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_target_phy_rate_qam128_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_target_phy_rate_qam256_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_sapm_en_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_arpl_th_50_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_rlapm_en_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_freq_shift_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_max_phy_rate_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_bandwidth_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_arpl_th_100_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_adc_mode_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_max_phy_rate_turbo_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_cp_const_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_preamble_uc_const_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_cp_margin_increase_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_ac_cc_shift_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_mfc_th_increase_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_agc_const_en_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_agc_const_address_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_min_bo_insert_2_bfm_lock_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_min_snr_avg_db_2_bfm_lock_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_max_phy_rate_50M_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_max_constellation_all_handler(handle, pp_parms, num_parms );

      for ( i0 = 0; i0 <= 15; i0++ )
      {
         ret = mocacli_is_node_connected(handle,i0); 
         if (ret != 0)   
         { 
            printf("\nnode_id: %d \n",i0); 
            printf("============\n");
            sprintf(gOptmp[0],"%d", i0);
            ret = mocacli_get_max_constellation_handler(handle, gOptmp, 1);

         }
      }

      ret = mocacli_get_snr_margin_table_rs_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_rlapm_table_50_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_phy_status_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_snr_margin_table_ldpc_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_snr_margin_table_ldpc_sec_ch_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_snr_margin_table_ldpc_pre5_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_snr_margin_table_ofdma_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_rlapm_table_100_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_snr_margin_table_ldpc_pri_ch_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_snr_margin_table_pre5_pri_ch_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_snr_margin_table_pre5_sec_ch_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_nv_cal_enable_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_rlapm_cap_50_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_snr_margin_rs_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_snr_margin_ldpc_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_snr_margin_ldpc_sec_ch_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_snr_margin_ldpc_pre5_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_snr_margin_ofdma_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_rlapm_cap_100_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_sapm_table_50_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_sapm_table_100_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_sapm_table_sec_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_snr_margin_ldpc_pri_ch_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_snr_margin_pre5_pri_ch_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_snr_margin_pre5_sec_ch_handler(handle, pp_parms, num_parms );

   }
   return(ret);
}

MOCALIB_CLI_PRINT void mocacli_print_max_frame_size (uint32_t * in)
{
   printf("max_frame_size: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_selective_rr (uint32_t * in)
{
   printf("selective_rr: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_fragmentation (uint32_t * in)
{
   printf("fragmentation: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_ifg_moca20 (uint32_t * in)
{
   printf("ifg_moca20: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_map_seed (uint32_t * in)
{
   printf("map_seed: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_max_transmit_time (uint32_t * in)
{
   printf("max_transmit_time: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_max_pkt_aggr (uint32_t * in)
{
   printf("max_pkt_aggr: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_rtr_config (struct moca_rtr_config * in)
{
   printf("== rtr_config ");
   printf(" ======================================== \n");
   printf("low : %u\n", in->low);
   printf("med : %u\n", in->med);
   printf("high: %u\n", in->high);
   printf("bg  : %u\n", in->bg);
   printf("== end rtr_config ");
   printf(" ==================================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_tlp_mode (uint32_t * in)
{
   printf("tlp_mode: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_max_pkt_aggr_bonding (uint32_t * in)
{
   printf("max_pkt_aggr_bonding: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_HELP static void mocacli_max_frame_size__bytes_help(void)
{
   printf("bytes:\n");
   printf("======\n");
   printf("Default:\n");
   printf("32768 \n");
   printf("Minimum:\n");
   printf("2048 \n");
   printf("Maximum:\n");
   printf("32768 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_max_frame_size_help( void )
{
   printf("Maximum frame size allowed to be transmitted through the MoCA physical interface. Used for limiting aggregation.Note: the frame size includes payloads headers and CRC's.\n");

   printf("\nmocap get --max_frame_size\n");
}

MOCALIB_CLI_GET static int mocacli_get_max_frame_size_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t max_frame_size;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_max_frame_size_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&max_frame_size, 0, sizeof(max_frame_size));

      ret = moca_get_max_frame_size(handle, &max_frame_size);

      if (ret == 0) {
         mocacli_print_max_frame_size(&max_frame_size);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_max_frame_size_help( void )
{
   printf("Maximum frame size allowed to be transmitted through the MoCA physical interface. Used for limiting aggregation.Note: the frame size includes payloads headers and CRC's.\n");

   printf("\nmocap set --max_frame_size <uint32 bytes>\n");
}

MOCALIB_CLI_SET static int mocacli_set_max_frame_size_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t max_frame_size;

   if (handle != NULL)
   {
      ret = moca_get_max_frame_size(handle, &max_frame_size);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_max_frame_size_help();
            mocacli_max_frame_size__bytes_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &max_frame_size);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_max_frame_size__bytes_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_max_frame_size(handle, max_frame_size);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_selective_rr__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("3 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_selective_rr_help( void )
{

   printf("\nmocap get --selective_rr\n");
}

MOCALIB_CLI_GET static int mocacli_get_selective_rr_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t selective_rr;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_selective_rr_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&selective_rr, 0, sizeof(selective_rr));

      ret = moca_get_selective_rr(handle, &selective_rr);

      if (ret == 0) {
         mocacli_print_selective_rr(&selective_rr);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_selective_rr_help( void )
{

   printf("\nmocap set --selective_rr <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_selective_rr_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t selective_rr;

   if (handle != NULL)
   {
      ret = moca_get_selective_rr(handle, &selective_rr);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_selective_rr_help();
            mocacli_selective_rr__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &selective_rr);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_selective_rr__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_selective_rr(handle, selective_rr);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_fragmentation__bool_val_help(void)
{
   printf("bool_val:\n");
   printf("=========\n");
   printf("\nValues:\n");
   printf("0 = Off \n");
   printf("1 = On\n");
   printf("Default:\n");
   printf("1 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_fragmentation_help( void )
{
   printf("Enable or disable fragmentation.\n");

   printf("\nmocap get --fragmentation\n");
}

MOCALIB_CLI_GET static int mocacli_get_fragmentation_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t fragmentation;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_fragmentation_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&fragmentation, 0, sizeof(fragmentation));

      ret = __moca_get_fragmentation(handle, &fragmentation);

      if (ret == 0) {
         mocacli_print_fragmentation(&fragmentation);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_fragmentation_help( void )
{
   printf("Enable or disable fragmentation.\n");

   printf("\nmocap set --fragmentation <uint32 bool_val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_fragmentation_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t fragmentation;

   if (handle != NULL)
   {
      ret = __moca_get_fragmentation(handle, &fragmentation);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_fragmentation_help();
            mocacli_fragmentation__bool_val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &fragmentation);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_fragmentation__bool_val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_fragmentation(handle, fragmentation);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_ifg_moca20__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("Units of uSec.\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_ifg_moca20_help( void )
{
   printf("Set constant ifg_moca20. Valid values (otherwise ignored) are 2 or higher. Each unit is 1 uSec.\n");

   printf("\nmocap get --ifg_moca20\n");
}

MOCALIB_CLI_GET static int mocacli_get_ifg_moca20_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t ifg_moca20;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_ifg_moca20_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&ifg_moca20, 0, sizeof(ifg_moca20));

      ret = __moca_get_ifg_moca20(handle, &ifg_moca20);

      if (ret == 0) {
         mocacli_print_ifg_moca20(&ifg_moca20);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_ifg_moca20_help( void )
{
   printf("Set constant ifg_moca20. Valid values (otherwise ignored) are 2 or higher. Each unit is 1 uSec.\n");

   printf("\nmocap set --ifg_moca20 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_ifg_moca20_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t ifg_moca20;

   if (handle != NULL)
   {
      ret = __moca_get_ifg_moca20(handle, &ifg_moca20);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_ifg_moca20_help();
            mocacli_ifg_moca20__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &ifg_moca20);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_ifg_moca20__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_ifg_moca20(handle, ifg_moca20);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_map_seed__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_map_seed_help( void )
{
   printf("Set constant seed for map.\n");

   printf("\nmocap get --map_seed\n");
}

MOCALIB_CLI_GET static int mocacli_get_map_seed_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t map_seed;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_map_seed_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&map_seed, 0, sizeof(map_seed));

      ret = __moca_get_map_seed(handle, &map_seed);

      if (ret == 0) {
         mocacli_print_map_seed(&map_seed);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_map_seed_help( void )
{
   printf("Set constant seed for map.\n");

   printf("\nmocap set --map_seed <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_map_seed_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t map_seed;

   if (handle != NULL)
   {
      ret = __moca_get_map_seed(handle, &map_seed);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_map_seed_help();
            mocacli_map_seed__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &map_seed);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_map_seed__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_map_seed(handle, map_seed);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_max_transmit_time__usec_help(void)
{
   printf("usec:\n");
   printf("=====\n");
   printf("\nValues:\n");
   printf("Value in uSec\n");
   printf("Default:\n");
   printf("400 \n");
   printf("Minimum:\n");
   printf("300 \n");
   printf("Maximum:\n");
   printf("1000 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_max_transmit_time_help( void )
{
   printf("Maximum transmission time allowed to transmit a frame through the MoCA physical interface. Used for limiting aggregation\n");

   printf("\nmocap get --max_transmit_time\n");
}

MOCALIB_CLI_GET static int mocacli_get_max_transmit_time_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t max_transmit_time;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_max_transmit_time_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&max_transmit_time, 0, sizeof(max_transmit_time));

      ret = moca_get_max_transmit_time(handle, &max_transmit_time);

      if (ret == 0) {
         mocacli_print_max_transmit_time(&max_transmit_time);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_max_transmit_time_help( void )
{
   printf("Maximum transmission time allowed to transmit a frame through the MoCA physical interface. Used for limiting aggregation\n");

   printf("\nmocap set --max_transmit_time <uint32 usec>\n");
}

MOCALIB_CLI_SET static int mocacli_set_max_transmit_time_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t max_transmit_time;

   if (handle != NULL)
   {
      ret = moca_get_max_transmit_time(handle, &max_transmit_time);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_max_transmit_time_help();
            mocacli_max_transmit_time__usec_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &max_transmit_time);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_max_transmit_time__usec_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_max_transmit_time(handle, max_transmit_time);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_max_pkt_aggr__pkts_help(void)
{
   printf("pkts:\n");
   printf("=====\n");
   printf("Default:\n");
   printf("20 \n");
   printf("Minimum:\n");
   printf("1 \n");
   printf("Maximum:\n");
   printf("20 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_max_pkt_aggr_help( void )
{
   printf("Max allowed packets for aggregated transmissions (enhanced GCAP.34)\n");

   printf("\nmocap get --max_pkt_aggr\n");
}

MOCALIB_CLI_GET static int mocacli_get_max_pkt_aggr_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t max_pkt_aggr;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_max_pkt_aggr_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&max_pkt_aggr, 0, sizeof(max_pkt_aggr));

      ret = moca_get_max_pkt_aggr(handle, &max_pkt_aggr);

      if (ret == 0) {
         mocacli_print_max_pkt_aggr(&max_pkt_aggr);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_max_pkt_aggr_help( void )
{
   printf("Max allowed packets for aggregated transmissions (enhanced GCAP.34)\n");

   printf("\nmocap set --max_pkt_aggr <uint32 pkts>\n");
}

MOCALIB_CLI_SET static int mocacli_set_max_pkt_aggr_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t max_pkt_aggr;

   if (handle != NULL)
   {
      ret = moca_get_max_pkt_aggr(handle, &max_pkt_aggr);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_max_pkt_aggr_help();
            mocacli_max_pkt_aggr__pkts_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &max_pkt_aggr);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_max_pkt_aggr__pkts_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_max_pkt_aggr(handle, max_pkt_aggr);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_probe_request__probe_type_help(void)
{
   printf("probe_type:\n");
   printf("===========\n");
   printf("\nValues:\n");
   printf("0 = Loopback probe request \n");
   printf("1 = Silent probe request\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_probe_request__timeslots_help(void)
{
   printf("timeslots:\n");
   printf("==========\n");
   printf("\nValues:\n");
   printf("The duration of the probe in timeslots.\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("20000 \n");
}

MOCALIB_CLI_HELP static void mocacli_set_probe_request_help( void )
{
   printf("Request a specific probe type from the NC.\n");

   printf("\nmocap set --probe_request <options>\n");
   printf("options:\n");
   printf("   probe_type   <uint16>\n");
   printf("   timeslots    <uint16>\n");
}

MOCALIB_CLI_SET static int mocacli_set_probe_request_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_probe_request probe_request;

   memset(&probe_request, 0, sizeof(probe_request));

   probe_request.probe_type = MOCA_PROBE_REQUEST_PROBE_TYPE_DEF;

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "probe_type"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_probe_request__probe_type_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint16(*pp_parms, &probe_request.probe_type);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_probe_request__probe_type_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "timeslots"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_probe_request__timeslots_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint16(*pp_parms, &probe_request.timeslots);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_probe_request__timeslots_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_probe_request_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = __moca_set_probe_request(handle, &probe_request);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_rtr_config__low_help(void)
{
   printf("low:\n");
   printf("====\n");
   printf("The number of retries allowed for low priority flows.\n");
   printf("\nValues:\n");
   printf("Setting the value to 0 disables retransmission for this priority level.\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("3 \n");
}

MOCALIB_CLI_HELP static void mocacli_rtr_config__med_help(void)
{
   printf("med:\n");
   printf("====\n");
   printf("The number of retries allowed for medium priority flows.\n");
   printf("\nValues:\n");
   printf("Setting the value to 0 disables retransmission for this priority level.\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("3 \n");
}

MOCALIB_CLI_HELP static void mocacli_rtr_config__high_help(void)
{
   printf("high:\n");
   printf("=====\n");
   printf("The number of retries allowed for high priority flows.\n");
   printf("\nValues:\n");
   printf("Setting the value to 0 disables retransmission for this priority level.\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("3 \n");
}

MOCALIB_CLI_HELP static void mocacli_rtr_config__bg_help(void)
{
   printf("bg:\n");
   printf("===\n");
   printf("The number of retries allowed for background priority flows.\n");
   printf("\nValues:\n");
   printf("Setting the value to 0 disables retransmission for this priority level.\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("3 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_rtr_config_help( void )
{
   printf("Configure retransmission behavior in the node for non-PQOS flows.\n");

   printf("\nmocap get --rtr_config\n");
}

MOCALIB_CLI_GET static int mocacli_get_rtr_config_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_rtr_config rtr_config;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_rtr_config_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&rtr_config, 0, sizeof(rtr_config));

      ret = moca_get_rtr_config(handle, &rtr_config);

      if (ret == 0) {
         mocacli_print_rtr_config(&rtr_config);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_rtr_config_help( void )
{
   printf("Configure retransmission behavior in the node for non-PQOS flows.\n");

   printf("\nmocap set --rtr_config <options>\n");
   printf("options:\n");
   printf("   high   <uint8>\n");
   printf("   low    <uint8>\n");
   printf("   bg     <uint8>\n");
   printf("   med    <uint8>\n");
}

MOCALIB_CLI_SET static int mocacli_set_rtr_config_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_rtr_config rtr_config;

   if (handle != NULL)
   {
      ret = moca_get_rtr_config(handle, &rtr_config);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "high"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_rtr_config__high_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint8(*pp_parms, &rtr_config.high);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_rtr_config__high_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "low"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_rtr_config__low_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint8(*pp_parms, &rtr_config.low);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_rtr_config__low_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "bg"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_rtr_config__bg_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint8(*pp_parms, &rtr_config.bg);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_rtr_config__bg_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "med"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_rtr_config__med_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint8(*pp_parms, &rtr_config.med);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_rtr_config__med_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_rtr_config_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_rtr_config(handle, &rtr_config);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_tlp_mode__mode_help(void)
{
   printf("mode:\n");
   printf("=====\n");
   printf("\nValues:\n");
   printf("1 = TLP_MIN1 and TLP_MAX1 \n");
   printf(" 2 = TLP_MIN2 and TLP_MAX2\n");
   printf("Default:\n");
   printf("1 \n");
   printf("Minimum:\n");
   printf("1 \n");
   printf("Maximum:\n");
   printf("2 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_tlp_mode_help( void )
{
   printf("TLP mode (GCAP.107)\n");

   printf("\nmocap get --tlp_mode\n");
}

MOCALIB_CLI_GET static int mocacli_get_tlp_mode_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t tlp_mode;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_tlp_mode_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&tlp_mode, 0, sizeof(tlp_mode));

      ret = moca_get_tlp_mode(handle, &tlp_mode);

      if (ret == 0) {
         mocacli_print_tlp_mode(&tlp_mode);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_tlp_mode_help( void )
{
   printf("TLP mode (GCAP.107)\n");

   printf("\nmocap set --tlp_mode <uint32 mode>\n");
}

MOCALIB_CLI_SET static int mocacli_set_tlp_mode_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t tlp_mode;

   if (handle != NULL)
   {
      ret = moca_get_tlp_mode(handle, &tlp_mode);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_tlp_mode_help();
            mocacli_tlp_mode__mode_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &tlp_mode);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_tlp_mode__mode_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_tlp_mode(handle, tlp_mode);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_max_pkt_aggr_bonding__pkts_help(void)
{
   printf("pkts:\n");
   printf("=====\n");
   printf("Default:\n");
   printf("27 \n");
   printf("Minimum:\n");
   printf("1 \n");
   printf("Maximum:\n");
   printf("30 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_max_pkt_aggr_bonding_help( void )
{
   printf("Max allowed packets for aggregated transmissions for bonding\n");

   printf("\nmocap get --max_pkt_aggr_bonding\n");
}

MOCALIB_CLI_GET static int mocacli_get_max_pkt_aggr_bonding_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t max_pkt_aggr_bonding;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_max_pkt_aggr_bonding_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&max_pkt_aggr_bonding, 0, sizeof(max_pkt_aggr_bonding));

      ret = moca_get_max_pkt_aggr_bonding(handle, &max_pkt_aggr_bonding);

      if (ret == 0) {
         mocacli_print_max_pkt_aggr_bonding(&max_pkt_aggr_bonding);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_max_pkt_aggr_bonding_help( void )
{
   printf("Max allowed packets for aggregated transmissions for bonding\n");

   printf("\nmocap set --max_pkt_aggr_bonding <uint32 pkts>\n");
}

MOCALIB_CLI_SET static int mocacli_set_max_pkt_aggr_bonding_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t max_pkt_aggr_bonding;

   if (handle != NULL)
   {
      ret = moca_get_max_pkt_aggr_bonding(handle, &max_pkt_aggr_bonding);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_max_pkt_aggr_bonding_help();
            mocacli_max_pkt_aggr_bonding__pkts_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &max_pkt_aggr_bonding);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_max_pkt_aggr_bonding__pkts_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_max_pkt_aggr_bonding(handle, max_pkt_aggr_bonding);
   }

   return(ret);
}

MOCALIB_CLI_GET static int mocacli_get_mac_layer_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   char **tmpPtr = pp_parms; 
   int nump = num_parms; 

   while (nump > 0)
   {
      if ((nump != 0) && !strcmp(*tmpPtr, "help"))
      {
         printf("The MAC group of parameters control the Media Access Control layer of the MoCA interface.\n");
         printf("IE list for this group: \n"); 
         printf("======================= \n"); 
         printf("max_frame_size\n"); 
         printf("selective_rr\n"); 
         printf("fragmentation\n"); 
         printf("ifg_moca20\n"); 
         printf("map_seed\n"); 
         printf("max_transmit_time\n"); 
         printf("max_pkt_aggr\n"); 
         printf("rtr_config\n"); 
         printf("tlp_mode\n"); 
         printf("max_pkt_aggr_bonding\n"); 
         return(0); 
      }
      tmpPtr++;
      nump--;
  }

   if (handle != NULL)
   {
      ret = mocacli_get_max_frame_size_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_selective_rr_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_fragmentation_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_ifg_moca20_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_map_seed_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_max_transmit_time_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_max_pkt_aggr_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_rtr_config_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_tlp_mode_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_max_pkt_aggr_bonding_handler(handle, pp_parms, num_parms );

   }
   return(ret);
}

MOCALIB_CLI_PRINT void mocacli_print_multicast_mode (uint32_t * in)
{
   printf("multicast_mode: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_low_pri_q_num (uint32_t * in)
{
   printf("low_pri_q_num: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_egr_mc_filter_en (uint32_t * in)
{
   printf("egr_mc_filter_en: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_fc_mode (uint32_t * in)
{
   printf("fc_mode: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_pqos_max_packet_size (uint32_t * in)
{
   printf("pqos_max_packet_size: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_per_mode (uint32_t * in)
{
   printf("per_mode: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_policing_en (uint32_t * in)
{
   printf("policing_en: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_pqos_egress_numflows (uint32_t * in)
{
   printf("pqos_egress_numflows: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_orr_en (uint32_t * in)
{
   printf("orr_en: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_brcmtag_enable (uint32_t * in)
{
   printf("brcmtag_enable: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_priority_allocations (struct moca_priority_allocations * in)
{
   printf("== priority_allocations ");
   printf(" ============================== \n");
   printf("reservation_pqos: %u  ( 0x%x )\n", in->reservation_pqos, in->reservation_pqos);
   printf("reservation_high: %u  ( 0x%x )\n", in->reservation_high, in->reservation_high);
   printf("reservation_med : %u  ( 0x%x )\n", in->reservation_med, in->reservation_med);
   printf("reservation_low : %u  ( 0x%x )\n", in->reservation_low, in->reservation_low);
   printf("limitation_pqos : %u  ( 0x%x )\n", in->limitation_pqos, in->limitation_pqos);
   printf("limitation_high : %u  ( 0x%x )\n", in->limitation_high, in->limitation_high);
   printf("limitation_med  : %u  ( 0x%x )\n", in->limitation_med, in->limitation_med);
   printf("limitation_low  : %u  ( 0x%x )\n", in->limitation_low, in->limitation_low);
   printf("== end priority_allocations ");
   printf(" ========================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_uc_fwd (struct moca_uc_fwd * in, uint32_t num_entries)
{
   uint32_t i;

   printf("== uc_fwd ================================\n");
   printf(" No.  mac_addr          moca_dest_node_id \n");
   printf("==========================================\n");
   for (i = 0; i < num_entries; i++)
   {
      printf("%4d: %02x:%02x:%02x:%02x:%02x:%02x %d        \n",
         i, MOCA_DISPLAY_MAC(in->mac_addr), in->moca_dest_node_id);
      in++;
   }
   printf("== end uc_fwd ============================\n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_src_addr (struct moca_src_addr * in, uint32_t num_entries)
{
   uint32_t i;

   printf("== src_addr =========================\n");
   printf(" No.  mac_addr          moca_node_id \n");
   printf("=====================================\n");
   for (i = 0; i < num_entries; i++)
   {
      printf("%4d: %02x:%02x:%02x:%02x:%02x:%02x %d   \n",
         i, MOCA_DISPLAY_MAC(in->mac_addr), in->moca_node_id);
      in++;
   }
   printf("== end src_addr =====================\n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_mac_aging (struct moca_mac_aging * in)
{
   printf("== mac_aging ");
   printf(" ========================================= \n");
   printf("uc_fwd_age  : %u  ( 0x%04x )\n", in->uc_fwd_age, in->uc_fwd_age);
   printf("mc_fwd_age  : %u  ( 0x%04x )\n", in->mc_fwd_age, in->mc_fwd_age);
   printf("src_addr_age: %u  ( 0x%04x )\n", in->src_addr_age, in->src_addr_age);
   printf("== end mac_aging ");
   printf(" ===================================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_loopback_en (uint32_t * in)
{
   printf("loopback_en: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_mcfilter_enable (uint32_t * in)
{
   printf("mcfilter_enable: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_pause_fc_en (uint32_t * in)
{
   printf("pause_fc_en: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_stag_priority (struct moca_stag_priority * in)
{
   printf("== stag_priority ");
   printf(" ===================================== \n");
   printf("enable         : %u  ( 0x%x )\n", in->enable, in->enable);
   printf("tag_mask       : %u  ( 0x%x )\n", in->tag_mask, in->tag_mask);
   printf("moca_priority_0: %u  ( 0x%x )\n", in->moca_priority_0, in->moca_priority_0);
   printf("tag_priority_0 : %u  ( 0x%x )\n", in->tag_priority_0, in->tag_priority_0);
   printf("moca_priority_1: %u  ( 0x%x )\n", in->moca_priority_1, in->moca_priority_1);
   printf("tag_priority_1 : %u  ( 0x%x )\n", in->tag_priority_1, in->tag_priority_1);
   printf("moca_priority_2: %u  ( 0x%x )\n", in->moca_priority_2, in->moca_priority_2);
   printf("tag_priority_2 : %u  ( 0x%x )\n", in->tag_priority_2, in->tag_priority_2);
   printf("moca_priority_3: %u  ( 0x%x )\n", in->moca_priority_3, in->moca_priority_3);
   printf("tag_priority_3 : %u  ( 0x%x )\n", in->tag_priority_3, in->tag_priority_3);
   printf("moca_priority_4: %u  ( 0x%x )\n", in->moca_priority_4, in->moca_priority_4);
   printf("tag_priority_4 : %u  ( 0x%x )\n", in->tag_priority_4, in->tag_priority_4);
   printf("moca_priority_5: %u  ( 0x%x )\n", in->moca_priority_5, in->moca_priority_5);
   printf("tag_priority_5 : %u  ( 0x%x )\n", in->tag_priority_5, in->tag_priority_5);
   printf("moca_priority_6: %u  ( 0x%x )\n", in->moca_priority_6, in->moca_priority_6);
   printf("tag_priority_6 : %u  ( 0x%x )\n", in->tag_priority_6, in->tag_priority_6);
   printf("moca_priority_7: %u  ( 0x%x )\n", in->moca_priority_7, in->moca_priority_7);
   printf("tag_priority_7 : %u  ( 0x%x )\n", in->tag_priority_7, in->tag_priority_7);
   printf("== end stag_priority ");
   printf(" ================================= \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_stag_removal (struct moca_stag_removal * in)
{
   printf("== stag_removal ");
   printf(" ====================================== \n");
   printf("enable : %u  ( 0x%x )\n", in->enable, in->enable);
   printf("valid_0: %u  ( 0x%x )\n", in->valid_0, in->valid_0);
   printf("value_0: %u  ( 0x%x )\n", in->value_0, in->value_0);
   printf("mask_0 : %u  ( 0x%x )\n", in->mask_0, in->mask_0);
   printf("valid_1: %u  ( 0x%x )\n", in->valid_1, in->valid_1);
   printf("value_1: %u  ( 0x%x )\n", in->value_1, in->value_1);
   printf("mask_1 : %u  ( 0x%x )\n", in->mask_1, in->mask_1);
   printf("valid_2: %u  ( 0x%x )\n", in->valid_2, in->valid_2);
   printf("value_2: %u  ( 0x%x )\n", in->value_2, in->value_2);
   printf("mask_2 : %u  ( 0x%x )\n", in->mask_2, in->mask_2);
   printf("valid_3: %u  ( 0x%x )\n", in->valid_3, in->valid_3);
   printf("value_3: %u  ( 0x%x )\n", in->value_3, in->value_3);
   printf("mask_3 : %u  ( 0x%x )\n", in->mask_3, in->mask_3);
   printf("== end stag_removal ");
   printf(" ================================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_pqos_create_flow (struct moca_pqos_create_flow_out * in)
{
   printf("== pqos_create_flow ");
   printf(" ================================== \n");
   printf("flow_id                 : %02x:%02x:%02x:%02x:%02x:%02x \n", MOCA_DISPLAY_MAC(in->flow_id));
   printf("flowda                  : %02x:%02x:%02x:%02x:%02x:%02x \n", MOCA_DISPLAY_MAC(in->flowda));
   printf("response_code           : %s (%d)\n", moca_l2_error_name(in->response_code), in->response_code);
   printf("decision                : %s (%d)\n", moca_decision_string(in->decision), in->decision);
   printf("flow_tag                : %u  ( 0x%x )\n", in->flow_tag, in->flow_tag);
   printf("peak_data_rate          : %u  ( 0x%x )\n", in->peak_data_rate, in->peak_data_rate);
   printf("packet_size             : %u  ( 0x%x )\n", in->packet_size, in->packet_size);
   printf("burst_size              : %u  ( 0x%x )\n", in->burst_size, in->burst_size);
   printf("lease_time              : %u  ( 0x%x )\n", in->lease_time, in->lease_time);
   printf("total_stps              : %u  ( 0x%x )\n", in->total_stps, in->total_stps);
   printf("total_txps              : %u  ( 0x%x )\n", in->total_txps, in->total_txps);
   printf("flow_stps               : %u  ( 0x%x )\n", in->flow_stps, in->flow_stps);
   printf("flow_txps               : %u  ( 0x%x )\n", in->flow_txps, in->flow_txps);
   printf("dest_flow_id            : %u  ( 0x%x )\n", in->dest_flow_id, in->dest_flow_id);
   printf("maximum_latency         : %u  ( 0x%x )\n", in->maximum_latency, in->maximum_latency);
   printf("short_term_avg_ratio    : %u  ( 0x%x )\n", in->short_term_avg_ratio, in->short_term_avg_ratio);
   printf("max_number_retry        : %u  ( 0x%x )\n", in->max_number_retry, in->max_number_retry);
   printf("flow_per                : %u  ( 0x%x )\n", in->flow_per, in->flow_per);
   printf("in_order_delivery       : %u  ( 0x%x )\n", in->in_order_delivery, in->in_order_delivery);
   printf("ingr_class_rule         : %u  ( 0x%x )\n", in->ingr_class_rule, in->ingr_class_rule);
   printf("traffic_protocol        : %u  ( 0x%x )\n", in->traffic_protocol, in->traffic_protocol);
   printf("vlan_tag                : %u  ( 0x%x )\n", in->vlan_tag, in->vlan_tag);
   printf("dscp_moca               : %u  ( 0x%x )\n", in->dscp_moca, in->dscp_moca);
   printf("max_short_term_avg_ratio: %u  ( 0x%x )\n", in->max_short_term_avg_ratio, in->max_short_term_avg_ratio);
   printf("bw_limit_info           : %u  ( 0x%x )\n", in->bw_limit_info, in->bw_limit_info);
   printf("== end pqos_create_flow ");
   printf(" ============================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_pqos_update_flow (struct moca_pqos_update_flow_out * in)
{
   printf("== pqos_update_flow ");
   printf(" ================================== \n");
   printf("flowid                  : %02x:%02x:%02x:%02x:%02x:%02x \n", MOCA_DISPLAY_MAC(in->flowid));
   printf("flowda                  : %02x:%02x:%02x:%02x:%02x:%02x \n", MOCA_DISPLAY_MAC(in->flowda));
   printf("response_code           : %s (%d)\n", moca_l2_error_name(in->response_code), in->response_code);
   printf("decision                : %s (%d)\n", moca_decision_string(in->decision), in->decision);
   printf("flow_tag                : %u  ( 0x%x )\n", in->flow_tag, in->flow_tag);
   printf("peak_data_rate          : %u  ( 0x%x )\n", in->peak_data_rate, in->peak_data_rate);
   printf("packet_size             : %u  ( 0x%x )\n", in->packet_size, in->packet_size);
   printf("burst_size              : %u  ( 0x%x )\n", in->burst_size, in->burst_size);
   printf("lease_time              : %u  ( 0x%x )\n", in->lease_time, in->lease_time);
   printf("total_stps              : %u  ( 0x%x )\n", in->total_stps, in->total_stps);
   printf("total_txps              : %u  ( 0x%x )\n", in->total_txps, in->total_txps);
   printf("flow_stps               : %u  ( 0x%x )\n", in->flow_stps, in->flow_stps);
   printf("flow_txps               : %u  ( 0x%x )\n", in->flow_txps, in->flow_txps);
   printf("maximum_latency         : %u  ( 0x%x )\n", in->maximum_latency, in->maximum_latency);
   printf("short_term_avg_ratio    : %u  ( 0x%x )\n", in->short_term_avg_ratio, in->short_term_avg_ratio);
   printf("max_number_retry        : %u  ( 0x%x )\n", in->max_number_retry, in->max_number_retry);
   printf("flow_per                : %u  ( 0x%x )\n", in->flow_per, in->flow_per);
   printf("in_order_delivery       : %u  ( 0x%x )\n", in->in_order_delivery, in->in_order_delivery);
   printf("ingr_class_rule         : %u  ( 0x%x )\n", in->ingr_class_rule, in->ingr_class_rule);
   printf("traffic_protocol        : %u  ( 0x%x )\n", in->traffic_protocol, in->traffic_protocol);
   printf("vlan_tag                : %u  ( 0x%x )\n", in->vlan_tag, in->vlan_tag);
   printf("dscp_moca               : %u  ( 0x%x )\n", in->dscp_moca, in->dscp_moca);
   printf("max_short_term_avg_ratio: %u  ( 0x%x )\n", in->max_short_term_avg_ratio, in->max_short_term_avg_ratio);
   printf("bw_limit_info           : %u  ( 0x%x )\n", in->bw_limit_info, in->bw_limit_info);
   printf("== end pqos_update_flow ");
   printf(" ============================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_pqos_delete_flow (struct moca_pqos_delete_flow_out * in)
{
   printf("== pqos_delete_flow ");
   printf(" ================================== \n");
   printf("flowid       : %02x:%02x:%02x:%02x:%02x:%02x \n", MOCA_DISPLAY_MAC(in->flowid));
   printf("response_code: %s (%d)\n", moca_l2_error_name(in->response_code), in->response_code);
   printf("== end pqos_delete_flow ");
   printf(" ============================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_pqos_list (struct moca_pqos_list_out * in)
{
   uint32_t i;

   printf("== pqos_list ");
   printf(" ========================================= \n");
   printf("response_code      : %s (%d)\n", moca_l2_error_name(in->response_code), in->response_code);
   printf("flow_update_count  : %d\n", in->flow_update_count);
   printf("total_flow_id_count: %d\n", in->total_flow_id_count);
   printf("num_ret_flow_ids   : %d\n", in->num_ret_flow_ids);
   printf("flowid[32]         : ");
   for (i = 0; i < 32; i++) {
      printf("%02x:%02x:%02x:%02x:%02x:%02x \n", MOCA_DISPLAY_MAC(in->flowid[i]));
      if (i < (32 - 1))
         printf("                     ");
   }
   printf("\n");
   printf("== end pqos_list ");
   printf(" ===================================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_pqos_query (struct moca_pqos_query_out * in)
{
   printf("== pqos_query ");
   printf(" ======================================== \n");
   printf("response_code       : %s (%d)\n", moca_l2_error_name(in->response_code), in->response_code);
   printf("flow_id             : %02x:%02x:%02x:%02x:%02x:%02x \n", MOCA_DISPLAY_MAC(in->flow_id));
   printf("packet_da           : %02x:%02x:%02x:%02x:%02x:%02x \n", MOCA_DISPLAY_MAC(in->packet_da));
   printf("ingress_node        : %02x:%02x:%02x:%02x:%02x:%02x \n", MOCA_DISPLAY_MAC(in->ingress_node));
   printf("egress_node         : %02x:%02x:%02x:%02x:%02x:%02x \n", MOCA_DISPLAY_MAC(in->egress_node));
   printf("packet_size         : %u  ( 0x%x )\n", in->packet_size, in->packet_size);
   printf("flow_tag            : %u  ( 0x%x )\n", in->flow_tag, in->flow_tag);
   printf("peak_data_rate      : %u  ( 0x%x )\n", in->peak_data_rate, in->peak_data_rate);
   printf("burst_size          : %u  ( 0x%x )\n", in->burst_size, in->burst_size);
   printf("lease_time          : %u  ( 0x%x )\n", in->lease_time, in->lease_time);
   printf("lease_time_left     : %u  ( 0x%x )\n", in->lease_time_left, in->lease_time_left);
   printf("max_latency         : %u  ( 0x%x )\n", in->max_latency, in->max_latency);
   printf("short_term_avg_ratio: %u  ( 0x%x )\n", in->short_term_avg_ratio, in->short_term_avg_ratio);
   printf("ingr_class_rule     : %u  ( 0x%x )\n", in->ingr_class_rule, in->ingr_class_rule);
   printf("vlan_tag            : %u  ( 0x%x )\n", in->vlan_tag, in->vlan_tag);
   printf("dscp_moca           : %u  ( 0x%x )\n", in->dscp_moca, in->dscp_moca);
   printf("dest_flow_id        : %u  ( 0x%x )\n", in->dest_flow_id, in->dest_flow_id);
   printf("max_retry           : %u  ( 0x%x )\n", in->max_retry, in->max_retry);
   printf("flow_per            : %u  ( 0x%x )\n", in->flow_per, in->flow_per);
   printf("in_order_delivery   : %u  ( 0x%x )\n", in->in_order_delivery, in->in_order_delivery);
   printf("traffic_protocol    : %u  ( 0x%x )\n", in->traffic_protocol, in->traffic_protocol);
   printf("== end pqos_query ");
   printf(" ==================================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_pqos_status (struct moca_pqos_status_out * in)
{
   printf("== pqos_status ");
   printf(" ======================================= \n");
   printf("total_stps: %u  ( 0x%x )\n", in->total_stps, in->total_stps);
   printf("total_txps: %u  ( 0x%x )\n", in->total_txps, in->total_txps);
   printf("flow_stps : %u  ( 0x%x )\n", in->flow_stps, in->flow_stps);
   printf("flow_txps : %u  ( 0x%x )\n", in->flow_txps, in->flow_txps);
   printf("== end pqos_status ");
   printf(" =================================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_mcfilter_table (struct moca_mcfilter_table * in)
{
   uint32_t i;

   printf("mcfilter_table: ");
   for (i = 0; i < 48; i++) {
      printf("%02x:%02x:%02x:%02x:%02x:%02x \n", MOCA_DISPLAY_MAC(in->addr[i]));
      if (i < (48 - 1))
         printf("          ");
   }
   printf("\n");
}

MOCALIB_CLI_PRINT void mocacli_print_host_qos (uint32_t * in)
{
   printf("host_qos: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_HELP static void mocacli_multicast_mode__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 - Normal mode. Host updates the MC table according to IGMP snooping. Unknown MC will be limited to 15pps.\n");
   printf("\n");
   printf("Note for lab: Pay attention to set the MC table when working in this mode.\n");
   printf("\n");
   printf("1 - Broadcast mode. All MC are always transmitted as BC. No limitation of BW.\n");
   printf("Default:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_multicast_mode_help( void )
{
   printf("Selecting a Mode of operation for MC. Normal mode is when the host has IGMP snooping ability. In CTP testing, the BC mode should be used.\n");

   printf("\nmocap get --multicast_mode\n");
}

MOCALIB_CLI_GET static int mocacli_get_multicast_mode_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t multicast_mode;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_multicast_mode_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&multicast_mode, 0, sizeof(multicast_mode));

      ret = moca_get_multicast_mode(handle, &multicast_mode);

      if (ret == 0) {
         mocacli_print_multicast_mode(&multicast_mode);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_multicast_mode_help( void )
{
   printf("Selecting a Mode of operation for MC. Normal mode is when the host has IGMP snooping ability. In CTP testing, the BC mode should be used.\n");

   printf("\nmocap set --multicast_mode <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_multicast_mode_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t multicast_mode;

   if (handle != NULL)
   {
      ret = moca_get_multicast_mode(handle, &multicast_mode);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_multicast_mode_help();
            mocacli_multicast_mode__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &multicast_mode);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_multicast_mode__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_multicast_mode(handle, multicast_mode);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_low_pri_q_num__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("2 (6816)\n0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_low_pri_q_num_help( void )
{
   printf("A RoboSwitch queue number of the low priority queue.\n");
   printf("Higher priorities queues will be adjacent.\n");
   printf("E.g.\n");
   printf("For LOW_PRI_Q_NUM = 2, MoCA will use queues 5,4,3,2\n");

   printf("\nmocap get --low_pri_q_num\n");
}

MOCALIB_CLI_GET static int mocacli_get_low_pri_q_num_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t low_pri_q_num;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_low_pri_q_num_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&low_pri_q_num, 0, sizeof(low_pri_q_num));

      ret = __moca_get_low_pri_q_num(handle, &low_pri_q_num);

      if (ret == 0) {
         mocacli_print_low_pri_q_num(&low_pri_q_num);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_low_pri_q_num_help( void )
{
   printf("A RoboSwitch queue number of the low priority queue.\n");
   printf("Higher priorities queues will be adjacent.\n");
   printf("E.g.\n");
   printf("For LOW_PRI_Q_NUM = 2, MoCA will use queues 5,4,3,2\n");

   printf("\nmocap set --low_pri_q_num <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_low_pri_q_num_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t low_pri_q_num;

   if (handle != NULL)
   {
      ret = __moca_get_low_pri_q_num(handle, &low_pri_q_num);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_low_pri_q_num_help();
            mocacli_low_pri_q_num__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &low_pri_q_num);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_low_pri_q_num__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_low_pri_q_num(handle, low_pri_q_num);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_egr_mc_filter_en__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = Disable \n");
   printf("1 = Enable\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_egr_mc_filter_en_help( void )
{
   printf("Enables/Disables Egress Eth MC Packet Filtering mode. \n");
   printf("When enabled, only the Eth MC packets with MAC Address that are match to an entry in the MC filter table are delivered through the GMII interface.\n");

   printf("\nmocap get --egr_mc_filter_en\n");
}

MOCALIB_CLI_GET static int mocacli_get_egr_mc_filter_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t egr_mc_filter_en;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_egr_mc_filter_en_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&egr_mc_filter_en, 0, sizeof(egr_mc_filter_en));

      ret = moca_get_egr_mc_filter_en(handle, &egr_mc_filter_en);

      if (ret == 0) {
         mocacli_print_egr_mc_filter_en(&egr_mc_filter_en);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_egr_mc_filter_en_help( void )
{
   printf("Enables/Disables Egress Eth MC Packet Filtering mode. \n");
   printf("When enabled, only the Eth MC packets with MAC Address that are match to an entry in the MC filter table are delivered through the GMII interface.\n");

   printf("\nmocap set --egr_mc_filter_en <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_egr_mc_filter_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t egr_mc_filter_en;

   if (handle != NULL)
   {
      ret = moca_get_egr_mc_filter_en(handle, &egr_mc_filter_en);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_egr_mc_filter_en_help();
            mocacli_egr_mc_filter_en__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &egr_mc_filter_en);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_egr_mc_filter_en__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_egr_mc_filter_en(handle, egr_mc_filter_en);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_fc_mode__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 - Normal mode. The MoCA core will assert the external flow control lines only.\n");
   printf("1 - Internal flow control mode. In addition to asserting the external flow control lines, the MoCA core will also limit the number of packets accepted into its queues on a per priority basis.\n");
   printf("Default:\n");
   printf("0 (FC_CAPABLE_CHIP)\n1 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_fc_mode_help( void )
{
   printf("Set or get the flow control mode.\n");

   printf("\nmocap get --fc_mode\n");
}

MOCALIB_CLI_GET static int mocacli_get_fc_mode_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t fc_mode;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_fc_mode_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&fc_mode, 0, sizeof(fc_mode));

      ret = moca_get_fc_mode(handle, &fc_mode);

      if (ret == 0) {
         mocacli_print_fc_mode(&fc_mode);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_fc_mode_help( void )
{
   printf("Set or get the flow control mode.\n");

   printf("\nmocap set --fc_mode <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_fc_mode_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t fc_mode;

   if (handle != NULL)
   {
      ret = moca_get_fc_mode(handle, &fc_mode);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_fc_mode_help();
            mocacli_fc_mode__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &fc_mode);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_fc_mode__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_fc_mode(handle, fc_mode);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_pqos_max_packet_size__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("The packet size is in bytes and includes the 4-byte VLAN header but does not include the 4-byte packet CRC.\n");
   printf("Default:\n");
   printf("1518 \n");
   printf("Minimum:\n");
   printf("64 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_pqos_max_packet_size_help( void )
{
   printf("Controls the maximum packet size supported by a PQOS flow. The default should be used unless jumbo packets are desired for PQOS flows.\n");

   printf("\nmocap get --pqos_max_packet_size\n");
}

MOCALIB_CLI_GET static int mocacli_get_pqos_max_packet_size_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t pqos_max_packet_size;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_pqos_max_packet_size_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&pqos_max_packet_size, 0, sizeof(pqos_max_packet_size));

      ret = moca_get_pqos_max_packet_size(handle, &pqos_max_packet_size);

      if (ret == 0) {
         mocacli_print_pqos_max_packet_size(&pqos_max_packet_size);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_pqos_max_packet_size_help( void )
{
   printf("Controls the maximum packet size supported by a PQOS flow. The default should be used unless jumbo packets are desired for PQOS flows.\n");

   printf("\nmocap set --pqos_max_packet_size <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_pqos_max_packet_size_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t pqos_max_packet_size;

   if (handle != NULL)
   {
      ret = moca_get_pqos_max_packet_size(handle, &pqos_max_packet_size);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_pqos_max_packet_size_help();
            mocacli_pqos_max_packet_size__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &pqos_max_packet_size);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_pqos_max_packet_size__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_pqos_max_packet_size(handle, pqos_max_packet_size);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_per_mode__mode_help(void)
{
   printf("mode:\n");
   printf("=====\n");
   printf("\nValues:\n");
   printf("0 = Nominal PER (1e-6) \n");
   printf("1 = Very Low PER (1e-8)\n");
   printf("Default:\n");
   printf("0 \n1 (BAND_E)\n1 (BAND_H)\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_per_mode_help( void )
{
   printf("Controls which transmission PER mode the Node uses for MPDUs not belonging to PQoS Flows\n");

   printf("\nmocap get --per_mode\n");
}

MOCALIB_CLI_GET static int mocacli_get_per_mode_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t per_mode;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_per_mode_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&per_mode, 0, sizeof(per_mode));

      ret = moca_get_per_mode(handle, &per_mode);

      if (ret == 0) {
         mocacli_print_per_mode(&per_mode);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_per_mode_help( void )
{
   printf("Controls which transmission PER mode the Node uses for MPDUs not belonging to PQoS Flows\n");

   printf("\nmocap set --per_mode <uint32 mode>\n");
}

MOCALIB_CLI_SET static int mocacli_set_per_mode_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t per_mode;

   if (handle != NULL)
   {
      ret = moca_get_per_mode(handle, &per_mode);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_per_mode_help();
            mocacli_per_mode__mode_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &per_mode);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_per_mode__mode_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_per_mode(handle, per_mode);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_policing_en__enable_help(void)
{
   printf("enable:\n");
   printf("=======\n");
   printf("\nValues:\n");
   printf("0 = disabled \n");
   printf("1 = enabled\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_policing_en_help( void )
{
   printf("Controls whether policing of PQoS Flows is enabled or disabled\n");

   printf("\nmocap get --policing_en\n");
}

MOCALIB_CLI_GET static int mocacli_get_policing_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t policing_en;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_policing_en_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&policing_en, 0, sizeof(policing_en));

      ret = moca_get_policing_en(handle, &policing_en);

      if (ret == 0) {
         mocacli_print_policing_en(&policing_en);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_policing_en_help( void )
{
   printf("Controls whether policing of PQoS Flows is enabled or disabled\n");

   printf("\nmocap set --policing_en <uint32 enable>\n");
}

MOCALIB_CLI_SET static int mocacli_set_policing_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t policing_en;

   if (handle != NULL)
   {
      ret = moca_get_policing_en(handle, &policing_en);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_policing_en_help();
            mocacli_policing_en__enable_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &policing_en);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_policing_en__enable_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_policing_en(handle, policing_en);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_get_pqos_egress_numflows_help( void )
{
   printf("Retrieve the number of PQoS Flows in which this node is an Egress node.\n");

   printf("\nmocap get --pqos_egress_numflows\n");
}

MOCALIB_CLI_GET static int mocacli_get_pqos_egress_numflows_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t pqos_egress_numflows;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_pqos_egress_numflows_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&pqos_egress_numflows, 0, sizeof(pqos_egress_numflows));

      ret = moca_get_pqos_egress_numflows(handle, &pqos_egress_numflows);

      if (ret == 0) {
         mocacli_print_pqos_egress_numflows(&pqos_egress_numflows);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_orr_en__enable_help(void)
{
   printf("enable:\n");
   printf("=======\n");
   printf("\nValues:\n");
   printf("0 = disabled \n");
   printf("1 = enabled\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_orr_en_help( void )
{
   printf("Controls whether or not Opportunistic Reservation Requests are to be used for MoCA 2.0 PQoS flows.\n");

   printf("\nmocap get --orr_en\n");
}

MOCALIB_CLI_GET static int mocacli_get_orr_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t orr_en;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_orr_en_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&orr_en, 0, sizeof(orr_en));

      ret = moca_get_orr_en(handle, &orr_en);

      if (ret == 0) {
         mocacli_print_orr_en(&orr_en);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_orr_en_help( void )
{
   printf("Controls whether or not Opportunistic Reservation Requests are to be used for MoCA 2.0 PQoS flows.\n");

   printf("\nmocap set --orr_en <uint32 enable>\n");
}

MOCALIB_CLI_SET static int mocacli_set_orr_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t orr_en;

   if (handle != NULL)
   {
      ret = moca_get_orr_en(handle, &orr_en);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_orr_en_help();
            mocacli_orr_en__enable_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &orr_en);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_orr_en__enable_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_orr_en(handle, orr_en);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_brcmtag_enable__enable_help(void)
{
   printf("enable:\n");
   printf("=======\n");
   printf("\nValues:\n");
   printf("Enable or Disable BRCM tag processing on packets from switch\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_brcmtag_enable_help( void )
{
   printf("Enable BRCM tag usage on packets from switch\n");

   printf("\nmocap get --brcmtag_enable\n");
}

MOCALIB_CLI_GET static int mocacli_get_brcmtag_enable_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t brcmtag_enable;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_brcmtag_enable_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&brcmtag_enable, 0, sizeof(brcmtag_enable));

      ret = moca_get_brcmtag_enable(handle, &brcmtag_enable);

      if (ret == 0) {
         mocacli_print_brcmtag_enable(&brcmtag_enable);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_brcmtag_enable_help( void )
{
   printf("Enable BRCM tag usage on packets from switch\n");

   printf("\nmocap set --brcmtag_enable <uint32 enable>\n");
}

MOCALIB_CLI_SET static int mocacli_set_brcmtag_enable_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t brcmtag_enable;

   if (handle != NULL)
   {
      ret = moca_get_brcmtag_enable(handle, &brcmtag_enable);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_brcmtag_enable_help();
            mocacli_brcmtag_enable__enable_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &brcmtag_enable);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_brcmtag_enable__enable_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_brcmtag_enable(handle, brcmtag_enable);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_priority_allocations__reservation_pqos_help(void)
{
   printf("reservation_pqos:\n");
   printf("=================\n");
   printf("Default:\n");
   printf("9 \n1 (7408)\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("300 \n");
}

MOCALIB_CLI_HELP static void mocacli_priority_allocations__reservation_high_help(void)
{
   printf("reservation_high:\n");
   printf("=================\n");
   printf("Default:\n");
   printf("9 \n1 (7408)\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("300 \n");
}

MOCALIB_CLI_HELP static void mocacli_priority_allocations__reservation_med_help(void)
{
   printf("reservation_med:\n");
   printf("================\n");
   printf("Default:\n");
   printf("64 \n1 (7408)\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("300 \n");
}

MOCALIB_CLI_HELP static void mocacli_priority_allocations__reservation_low_help(void)
{
   printf("reservation_low:\n");
   printf("================\n");
   printf("Default:\n");
   printf("64 \n10 (7408)\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("300 \n");
}

MOCALIB_CLI_HELP static void mocacli_priority_allocations__limitation_pqos_help(void)
{
   printf("limitation_pqos:\n");
   printf("================\n");
   printf("Default:\n");
   printf("300 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("300 \n");
}

MOCALIB_CLI_HELP static void mocacli_priority_allocations__limitation_high_help(void)
{
   printf("limitation_high:\n");
   printf("================\n");
   printf("Default:\n");
   printf("300 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("300 \n");
}

MOCALIB_CLI_HELP static void mocacli_priority_allocations__limitation_med_help(void)
{
   printf("limitation_med:\n");
   printf("===============\n");
   printf("Default:\n");
   printf("300 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("300 \n");
}

MOCALIB_CLI_HELP static void mocacli_priority_allocations__limitation_low_help(void)
{
   printf("limitation_low:\n");
   printf("===============\n");
   printf("Default:\n");
   printf("300 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("300 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_priority_allocations_help( void )
{
   printf("Configuration of the system's three priority pools. \n");
   printf("Each pool has a reservation and limitation value, in Mbps. \n");
   printf("These values will be translated to buffer allocations. \n");
   printf("Per priority: limit >= reserve\n");

   printf("\nmocap get --priority_allocations\n");
}

MOCALIB_CLI_GET static int mocacli_get_priority_allocations_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_priority_allocations priority_allocations;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_priority_allocations_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&priority_allocations, 0, sizeof(priority_allocations));

      ret = __moca_get_priority_allocations(handle, &priority_allocations);

      if (ret == 0) {
         mocacli_print_priority_allocations(&priority_allocations);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_priority_allocations_help( void )
{
   printf("Configuration of the system's three priority pools. \n");
   printf("Each pool has a reservation and limitation value, in Mbps. \n");
   printf("These values will be translated to buffer allocations. \n");
   printf("Per priority: limit >= reserve\n");

   printf("\nmocap set --priority_allocations <options>\n");
   printf("options:\n");
   printf("   limitation_med     <uint32>\n");
   printf("   reservation_high   <uint32>\n");
   printf("   reservation_pqos   <uint32>\n");
   printf("   limitation_pqos    <uint32>\n");
   printf("   limitation_low     <uint32>\n");
   printf("   limitation_high    <uint32>\n");
   printf("   reservation_low    <uint32>\n");
   printf("   reservation_med    <uint32>\n");
}

MOCALIB_CLI_SET static int mocacli_set_priority_allocations_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_priority_allocations priority_allocations;

   if (handle != NULL)
   {
      ret = __moca_get_priority_allocations(handle, &priority_allocations);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "limitation_med"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_priority_allocations__limitation_med_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &priority_allocations.limitation_med);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_priority_allocations__limitation_med_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "reservation_high"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_priority_allocations__reservation_high_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &priority_allocations.reservation_high);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_priority_allocations__reservation_high_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "reservation_pqos"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_priority_allocations__reservation_pqos_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &priority_allocations.reservation_pqos);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_priority_allocations__reservation_pqos_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "limitation_pqos"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_priority_allocations__limitation_pqos_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &priority_allocations.limitation_pqos);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_priority_allocations__limitation_pqos_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "limitation_low"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_priority_allocations__limitation_low_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &priority_allocations.limitation_low);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_priority_allocations__limitation_low_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "limitation_high"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_priority_allocations__limitation_high_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &priority_allocations.limitation_high);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_priority_allocations__limitation_high_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "reservation_low"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_priority_allocations__reservation_low_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &priority_allocations.reservation_low);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_priority_allocations__reservation_low_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "reservation_med"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_priority_allocations__reservation_med_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &priority_allocations.reservation_med);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_priority_allocations__reservation_med_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_priority_allocations_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = __moca_set_priority_allocations(handle, &priority_allocations);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_egr_mc_addr_filter__entryid_help(void)
{
   printf("entryid:\n");
   printf("========\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("31 \n");
}

MOCALIB_CLI_HELP static void mocacli_egr_mc_addr_filter__valid_help(void)
{
   printf("valid:\n");
   printf("======\n");
   printf("\nValues:\n");
   printf("0 - invalid \n");
   printf("1 - valid\n");
}

MOCALIB_CLI_HELP static void mocacli_egr_mc_addr_filter__addr_help(void)
{
   printf("addr:\n");
   printf("=====\n");
   printf("\nValues:\n");
   printf("Multicast MAC Address to be filtered\n");
}

MOCALIB_CLI_HELP static void mocacli_set_egr_mc_addr_filter_help( void )
{
   printf("Set Multicast MAC Address filtering entry.\n");

   printf("\nmocap set --egr_mc_addr_filter <options>\n");
   printf("options:\n");
   printf("   entryid   <uint32>\n");
   printf("   valid     <uint32>\n");
   printf("   addr      <macaddr, format xx:xx:xx:xx:xx:xx>\n");
}

MOCALIB_CLI_SET static int mocacli_set_egr_mc_addr_filter_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_egr_mc_addr_filter_set egr_mc_addr_filter;

   memset(&egr_mc_addr_filter, 0, sizeof(egr_mc_addr_filter));

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "entryid"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_egr_mc_addr_filter__entryid_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &egr_mc_addr_filter.entryid);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_egr_mc_addr_filter__entryid_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "valid"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_egr_mc_addr_filter__valid_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &egr_mc_addr_filter.valid);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_egr_mc_addr_filter__valid_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "addr"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_egr_mc_addr_filter__addr_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_macaddr(*pp_parms, &egr_mc_addr_filter.addr);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_egr_mc_addr_filter__addr_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_egr_mc_addr_filter_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_egr_mc_addr_filter(handle, &egr_mc_addr_filter);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_get_uc_fwd_help( void )
{
   printf("UC Forwarding Table \n");
   printf("Note: The UC Forwarding Table is a Read-only table from the host.\n");

   printf("\nmocap get --uc_fwd\n");
}

MOCALIB_CLI_GET static int mocacli_get_uc_fwd_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_uc_fwd uc_fwd[128];

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_uc_fwd_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&uc_fwd, 0, sizeof(uc_fwd));

      ret = moca_get_uc_fwd(handle, &uc_fwd[0], sizeof(uc_fwd));

      if (ret >= 0) {
         mocacli_print_uc_fwd(&uc_fwd[0], ret);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_get_src_addr_help( void )
{
   printf("SRC Addresses Table \n");
   printf("Note: The SRS Addresses Table is a Read-only table from the host\n");

   printf("\nmocap get --src_addr\n");
}

MOCALIB_CLI_GET static int mocacli_get_src_addr_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_src_addr src_addr[128];

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_src_addr_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&src_addr, 0, sizeof(src_addr));

      ret = moca_get_src_addr(handle, &src_addr[0], sizeof(src_addr));

      if (ret >= 0) {
         mocacli_print_src_addr(&src_addr[0], ret);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_mac_aging__uc_fwd_age_help(void)
{
   printf("uc_fwd_age:\n");
   printf("===========\n");
   printf("Lifetime of an idle MAC address in the uc_fwd table.\n");
   printf("\nValues:\n");
   printf("Units of seconds.\n");
   printf("Default:\n");
   printf("300 \n");
}

MOCALIB_CLI_HELP static void mocacli_mac_aging__mc_fwd_age_help(void)
{
   printf("mc_fwd_age:\n");
   printf("===========\n");
   printf("Lifetime of an idle MAC address in the mc_fwd table.\n");
   printf("\nValues:\n");
   printf("Units of seconds.\n");
   printf("Default:\n");
   printf("0xFFFF \n");
}

MOCALIB_CLI_HELP static void mocacli_mac_aging__src_addr_age_help(void)
{
   printf("src_addr_age:\n");
   printf("=============\n");
   printf("Lifetime of an idle MAC address in the src_addr table.\n");
   printf("\nValues:\n");
   printf("Units of seconds.\n");
   printf("Default:\n");
   printf("300 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_mac_aging_help( void )
{
   printf("Configure the time in seconds before an idle MAC address will be aged out of its respective table.\n");

   printf("\nmocap get --mac_aging\n");
}

MOCALIB_CLI_GET static int mocacli_get_mac_aging_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_mac_aging mac_aging;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_mac_aging_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&mac_aging, 0, sizeof(mac_aging));

      ret = moca_get_mac_aging(handle, &mac_aging);

      if (ret == 0) {
         mocacli_print_mac_aging(&mac_aging);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_mac_aging_help( void )
{
   printf("Configure the time in seconds before an idle MAC address will be aged out of its respective table.\n");

   printf("\nmocap set --mac_aging <options>\n");
   printf("options:\n");
   printf("   uc_fwd_age     <uint16>\n");
   printf("   src_addr_age   <uint16>\n");
   printf("   mc_fwd_age     <uint16>\n");
}

MOCALIB_CLI_SET static int mocacli_set_mac_aging_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_mac_aging mac_aging;

   if (handle != NULL)
   {
      ret = moca_get_mac_aging(handle, &mac_aging);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "uc_fwd_age"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_mac_aging__uc_fwd_age_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint16(*pp_parms, &mac_aging.uc_fwd_age);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_mac_aging__uc_fwd_age_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "src_addr_age"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_mac_aging__src_addr_age_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint16(*pp_parms, &mac_aging.src_addr_age);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_mac_aging__src_addr_age_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "mc_fwd_age"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_mac_aging__mc_fwd_age_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint16(*pp_parms, &mac_aging.mc_fwd_age);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_mac_aging__mc_fwd_age_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_mac_aging_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_mac_aging(handle, &mac_aging);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_loopback_en__en_help(void)
{
   printf("en:\n");
   printf("===\n");
   printf("\nValues:\n");
   printf("0 = Nomal mode \n");
   printf("1 = loopback\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_loopback_en_help( void )
{
   printf("In loopback mode, the data traffic coming from the Coax will be looped back into the Coax.In 6816 the loopback is a SW loopback, at the MAC level (no supporting HW available)In 7xxx the loopback is by HW at the ECL level.For UC, SA and DA will be flipped.For MC, the SA will be local MAC device, and DA will be a new address according to spec.\n");

   printf("\nmocap get --loopback_en\n");
}

MOCALIB_CLI_GET static int mocacli_get_loopback_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t loopback_en;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_loopback_en_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&loopback_en, 0, sizeof(loopback_en));

      ret = moca_get_loopback_en(handle, &loopback_en);

      if (ret == 0) {
         mocacli_print_loopback_en(&loopback_en);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_loopback_en_help( void )
{
   printf("In loopback mode, the data traffic coming from the Coax will be looped back into the Coax.In 6816 the loopback is a SW loopback, at the MAC level (no supporting HW available)In 7xxx the loopback is by HW at the ECL level.For UC, SA and DA will be flipped.For MC, the SA will be local MAC device, and DA will be a new address according to spec.\n");

   printf("\nmocap set --loopback_en <uint32 en>\n");
}

MOCALIB_CLI_SET static int mocacli_set_loopback_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t loopback_en;

   if (handle != NULL)
   {
      ret = moca_get_loopback_en(handle, &loopback_en);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_loopback_en_help();
            mocacli_loopback_en__en_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &loopback_en);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_loopback_en__en_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_loopback_en(handle, loopback_en);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_mcfilter_enable__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = Disable \n");
   printf("1 = Enable \n");
   printf("2 = Enable on DFID only\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_mcfilter_enable_help( void )
{
   printf("Enables/Disables multicast Filter mode or enable on DFID only.\n");

   printf("\nmocap get --mcfilter_enable\n");
}

MOCALIB_CLI_GET static int mocacli_get_mcfilter_enable_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t mcfilter_enable;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_mcfilter_enable_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&mcfilter_enable, 0, sizeof(mcfilter_enable));

      ret = moca_get_mcfilter_enable(handle, &mcfilter_enable);

      if (ret == 0) {
         mocacli_print_mcfilter_enable(&mcfilter_enable);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_mcfilter_enable_help( void )
{
   printf("Enables/Disables multicast Filter mode or enable on DFID only.\n");

   printf("\nmocap set --mcfilter_enable <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_mcfilter_enable_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t mcfilter_enable;

   if (handle != NULL)
   {
      ret = moca_get_mcfilter_enable(handle, &mcfilter_enable);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_mcfilter_enable_help();
            mocacli_mcfilter_enable__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &mcfilter_enable);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_mcfilter_enable__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_mcfilter_enable(handle, mcfilter_enable);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_mcfilter_addentry__addr_help(void)
{
   printf("addr:\n");
   printf("=====\n");
   printf("\nValues:\n");
   printf("Multicast MAC Address to be filtered\n");
}

MOCALIB_CLI_HELP static void mocacli_set_mcfilter_addentry_help( void )
{
   printf("Add Multicast MAC Address filtering entry.\n");

   printf("\nmocap set --mcfilter_addentry <options>\n");
   printf("options:\n");
   printf("   addr   <macaddr, format xx:xx:xx:xx:xx:xx>\n");
}

MOCALIB_CLI_SET static int mocacli_set_mcfilter_addentry_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_mcfilter_addentry mcfilter_addentry;

   memset(&mcfilter_addentry, 0, sizeof(mcfilter_addentry));

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "addr"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_mcfilter_addentry__addr_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_macaddr(*pp_parms, &mcfilter_addentry.addr);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_mcfilter_addentry__addr_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_mcfilter_addentry_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_mcfilter_addentry(handle, &mcfilter_addentry);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_mcfilter_delentry__addr_help(void)
{
   printf("addr:\n");
   printf("=====\n");
   printf("\nValues:\n");
   printf("Multicast MAC Address to be filtered\n");
}

MOCALIB_CLI_HELP static void mocacli_set_mcfilter_delentry_help( void )
{
   printf("Delete Multicast MAC Address filtering entry.\n");

   printf("\nmocap set --mcfilter_delentry <options>\n");
   printf("options:\n");
   printf("   addr   <macaddr, format xx:xx:xx:xx:xx:xx>\n");
}

MOCALIB_CLI_SET static int mocacli_set_mcfilter_delentry_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_mcfilter_delentry mcfilter_delentry;

   memset(&mcfilter_delentry, 0, sizeof(mcfilter_delentry));

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "addr"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_mcfilter_delentry__addr_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_macaddr(*pp_parms, &mcfilter_delentry.addr);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_mcfilter_delentry__addr_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_mcfilter_delentry_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_mcfilter_delentry(handle, &mcfilter_delentry);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_pause_fc_en__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = Disable \n");
   printf("1 = Enable\n");
   printf("Default:\n");
   printf("0 \n1 (STANDALONE)\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_pause_fc_en_help( void )
{
   printf("Enable/Disable Pause Frame Flow Control for packets destined for the MoCA network, if available. Not all MoCA chips support Pause frames.\n");

   printf("\nmocap get --pause_fc_en\n");
}

MOCALIB_CLI_GET static int mocacli_get_pause_fc_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t pause_fc_en;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_pause_fc_en_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&pause_fc_en, 0, sizeof(pause_fc_en));

      ret = moca_get_pause_fc_en(handle, &pause_fc_en);

      if (ret == 0) {
         mocacli_print_pause_fc_en(&pause_fc_en);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_pause_fc_en_help( void )
{
   printf("Enable/Disable Pause Frame Flow Control for packets destined for the MoCA network, if available. Not all MoCA chips support Pause frames.\n");

   printf("\nmocap set --pause_fc_en <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_pause_fc_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t pause_fc_en;

   if (handle != NULL)
   {
      ret = moca_get_pause_fc_en(handle, &pause_fc_en);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_pause_fc_en_help();
            mocacli_pause_fc_en__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &pause_fc_en);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_pause_fc_en__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_pause_fc_en(handle, pause_fc_en);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_stag_priority__enable_help(void)
{
   printf("enable:\n");
   printf("=======\n");
   printf("\nValues:\n");
   printf("Enable stag priority mapping\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_stag_priority__tag_mask_help(void)
{
   printf("tag_mask:\n");
   printf("=========\n");
   printf("\nValues:\n");
   printf("Tag Priority mask (16 bit).\n");
   printf("This parameter indicates which bits within PCP/CFI/VID fields (Lower 16 bits of \n");
   printf("the Tag) contain the priority according to which the ECL should classify the \n");
   printf("packet.\n");
   printf("Example: 0xE means bits 1-3\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("0xFFFF \n");
}

MOCALIB_CLI_HELP static void mocacli_stag_priority__moca_priority_0_help(void)
{
   printf("moca_priority_0:\n");
   printf("================\n");
   printf("\nValues:\n");
   printf("MoCA priority - index 0\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("4 \n");
}

MOCALIB_CLI_HELP static void mocacli_stag_priority__tag_priority_0_help(void)
{
   printf("tag_priority_0:\n");
   printf("===============\n");
   printf("\nValues:\n");
   printf("S-Tag priority - index 0\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("4 \n");
}

MOCALIB_CLI_HELP static void mocacli_stag_priority__moca_priority_1_help(void)
{
   printf("moca_priority_1:\n");
   printf("================\n");
   printf("\nValues:\n");
   printf("MoCA priority - index 1\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("4 \n");
}

MOCALIB_CLI_HELP static void mocacli_stag_priority__tag_priority_1_help(void)
{
   printf("tag_priority_1:\n");
   printf("===============\n");
   printf("\nValues:\n");
   printf("S-Tag priority - index 1\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("4 \n");
}

MOCALIB_CLI_HELP static void mocacli_stag_priority__moca_priority_2_help(void)
{
   printf("moca_priority_2:\n");
   printf("================\n");
   printf("\nValues:\n");
   printf("MoCA priority - index 2\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("4 \n");
}

MOCALIB_CLI_HELP static void mocacli_stag_priority__tag_priority_2_help(void)
{
   printf("tag_priority_2:\n");
   printf("===============\n");
   printf("\nValues:\n");
   printf("S-Tag priority - index 2\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("4 \n");
}

MOCALIB_CLI_HELP static void mocacli_stag_priority__moca_priority_3_help(void)
{
   printf("moca_priority_3:\n");
   printf("================\n");
   printf("\nValues:\n");
   printf("MoCA priority - index 3\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("4 \n");
}

MOCALIB_CLI_HELP static void mocacli_stag_priority__tag_priority_3_help(void)
{
   printf("tag_priority_3:\n");
   printf("===============\n");
   printf("\nValues:\n");
   printf("S-Tag priority - index 3\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("4 \n");
}

MOCALIB_CLI_HELP static void mocacli_stag_priority__moca_priority_4_help(void)
{
   printf("moca_priority_4:\n");
   printf("================\n");
   printf("\nValues:\n");
   printf("MoCA priority - index 4\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("4 \n");
}

MOCALIB_CLI_HELP static void mocacli_stag_priority__tag_priority_4_help(void)
{
   printf("tag_priority_4:\n");
   printf("===============\n");
   printf("\nValues:\n");
   printf("S-Tag priority - index 4\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("4 \n");
}

MOCALIB_CLI_HELP static void mocacli_stag_priority__moca_priority_5_help(void)
{
   printf("moca_priority_5:\n");
   printf("================\n");
   printf("\nValues:\n");
   printf("MoCA priority - index 5\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_stag_priority__tag_priority_5_help(void)
{
   printf("tag_priority_5:\n");
   printf("===============\n");
   printf("\nValues:\n");
   printf("S-Tag priority - index 5\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("4 \n");
}

MOCALIB_CLI_HELP static void mocacli_stag_priority__moca_priority_6_help(void)
{
   printf("moca_priority_6:\n");
   printf("================\n");
   printf("\nValues:\n");
   printf("MoCA priority - index 6\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("4 \n");
}

MOCALIB_CLI_HELP static void mocacli_stag_priority__tag_priority_6_help(void)
{
   printf("tag_priority_6:\n");
   printf("===============\n");
   printf("\nValues:\n");
   printf("S-Tag priority - index 6\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("4 \n");
}

MOCALIB_CLI_HELP static void mocacli_stag_priority__moca_priority_7_help(void)
{
   printf("moca_priority_7:\n");
   printf("================\n");
   printf("\nValues:\n");
   printf("MoCA priority - index 7\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("4 \n");
}

MOCALIB_CLI_HELP static void mocacli_stag_priority__tag_priority_7_help(void)
{
   printf("tag_priority_7:\n");
   printf("===============\n");
   printf("\nValues:\n");
   printf("S-Tag priority - index 7\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("4 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_stag_priority_help( void )
{
   printf("Mapping between stag priority and MoCA priority\n");

   printf("\nmocap get --stag_priority\n");
}

MOCALIB_CLI_GET static int mocacli_get_stag_priority_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_stag_priority stag_priority;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_stag_priority_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&stag_priority, 0, sizeof(stag_priority));

      ret = moca_get_stag_priority(handle, &stag_priority);

      if (ret == 0) {
         mocacli_print_stag_priority(&stag_priority);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_stag_priority_help( void )
{
   printf("Mapping between stag priority and MoCA priority\n");

   printf("\nmocap set --stag_priority <options>\n");
   printf("options:\n");
   printf("   moca_priority_2   <uint32>\n");
   printf("   tag_priority_2    <uint32>\n");
   printf("   moca_priority_5   <uint32>\n");
   printf("   tag_mask          <uint32>\n");
   printf("   tag_priority_5    <uint32>\n");
   printf("   moca_priority_7   <uint32>\n");
   printf("   tag_priority_0    <uint32>\n");
   printf("   moca_priority_0   <uint32>\n");
   printf("   tag_priority_6    <uint32>\n");
   printf("   moca_priority_4   <uint32>\n");
   printf("   tag_priority_7    <uint32>\n");
   printf("   tag_priority_3    <uint32>\n");
   printf("   enable            <uint32>\n");
   printf("   tag_priority_1    <uint32>\n");
   printf("   moca_priority_3   <uint32>\n");
   printf("   tag_priority_4    <uint32>\n");
   printf("   moca_priority_1   <uint32>\n");
   printf("   moca_priority_6   <uint32>\n");
}

MOCALIB_CLI_SET static int mocacli_set_stag_priority_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_stag_priority stag_priority;

   if (handle != NULL)
   {
      ret = moca_get_stag_priority(handle, &stag_priority);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "moca_priority_2"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_priority__moca_priority_2_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_priority.moca_priority_2);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_priority__moca_priority_2_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "tag_priority_2"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_priority__tag_priority_2_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_priority.tag_priority_2);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_priority__tag_priority_2_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "moca_priority_5"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_priority__moca_priority_5_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_priority.moca_priority_5);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_priority__moca_priority_5_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "tag_mask"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_priority__tag_mask_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_priority.tag_mask);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_priority__tag_mask_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "tag_priority_5"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_priority__tag_priority_5_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_priority.tag_priority_5);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_priority__tag_priority_5_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "moca_priority_7"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_priority__moca_priority_7_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_priority.moca_priority_7);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_priority__moca_priority_7_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "tag_priority_0"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_priority__tag_priority_0_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_priority.tag_priority_0);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_priority__tag_priority_0_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "moca_priority_0"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_priority__moca_priority_0_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_priority.moca_priority_0);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_priority__moca_priority_0_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "tag_priority_6"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_priority__tag_priority_6_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_priority.tag_priority_6);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_priority__tag_priority_6_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "moca_priority_4"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_priority__moca_priority_4_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_priority.moca_priority_4);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_priority__moca_priority_4_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "tag_priority_7"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_priority__tag_priority_7_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_priority.tag_priority_7);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_priority__tag_priority_7_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "tag_priority_3"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_priority__tag_priority_3_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_priority.tag_priority_3);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_priority__tag_priority_3_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "enable"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_priority__enable_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_priority.enable);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_priority__enable_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "tag_priority_1"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_priority__tag_priority_1_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_priority.tag_priority_1);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_priority__tag_priority_1_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "moca_priority_3"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_priority__moca_priority_3_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_priority.moca_priority_3);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_priority__moca_priority_3_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "tag_priority_4"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_priority__tag_priority_4_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_priority.tag_priority_4);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_priority__tag_priority_4_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "moca_priority_1"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_priority__moca_priority_1_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_priority.moca_priority_1);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_priority__moca_priority_1_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "moca_priority_6"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_priority__moca_priority_6_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_priority.moca_priority_6);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_priority__moca_priority_6_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_stag_priority_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_stag_priority(handle, &stag_priority);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_stag_removal__enable_help(void)
{
   printf("enable:\n");
   printf("=======\n");
   printf("\nValues:\n");
   printf("Enable stag removal\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_stag_removal__valid_0_help(void)
{
   printf("valid_0:\n");
   printf("========\n");
   printf("\nValues:\n");
   printf("Indicates if table row is active\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_stag_removal__value_0_help(void)
{
   printf("value_0:\n");
   printf("========\n");
   printf("\nValues:\n");
   printf("Value to match against\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_stag_removal__mask_0_help(void)
{
   printf("mask_0:\n");
   printf("=======\n");
   printf("\nValues:\n");
   printf("If mask bit is set, the associated bit in value is don't care\n");
   printf("Default:\n");
   printf("0xffffffff \n");
}

MOCALIB_CLI_HELP static void mocacli_stag_removal__valid_1_help(void)
{
   printf("valid_1:\n");
   printf("========\n");
   printf("\nValues:\n");
   printf("Indicates if table row is active\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_stag_removal__value_1_help(void)
{
   printf("value_1:\n");
   printf("========\n");
   printf("\nValues:\n");
   printf("Value to match against\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_stag_removal__mask_1_help(void)
{
   printf("mask_1:\n");
   printf("=======\n");
   printf("\nValues:\n");
   printf("If mask bit is set, the associated bit in value is don't care\n");
   printf("Default:\n");
   printf("0xffffffff \n");
}

MOCALIB_CLI_HELP static void mocacli_stag_removal__valid_2_help(void)
{
   printf("valid_2:\n");
   printf("========\n");
   printf("\nValues:\n");
   printf("Indicates if table row is active\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_stag_removal__value_2_help(void)
{
   printf("value_2:\n");
   printf("========\n");
   printf("\nValues:\n");
   printf("Value to match against\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_stag_removal__mask_2_help(void)
{
   printf("mask_2:\n");
   printf("=======\n");
   printf("\nValues:\n");
   printf("If mask bit is set, the associated bit in value is don't care\n");
   printf("Default:\n");
   printf("0xffffffff \n");
}

MOCALIB_CLI_HELP static void mocacli_stag_removal__valid_3_help(void)
{
   printf("valid_3:\n");
   printf("========\n");
   printf("\nValues:\n");
   printf("Indicates if table row is active\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_stag_removal__value_3_help(void)
{
   printf("value_3:\n");
   printf("========\n");
   printf("\nValues:\n");
   printf("Value to match against\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_stag_removal__mask_3_help(void)
{
   printf("mask_3:\n");
   printf("=======\n");
   printf("\nValues:\n");
   printf("If mask bit is set, the associated bit in value is don't care\n");
   printf("Default:\n");
   printf("0xffffffff \n");
}

MOCALIB_CLI_HELP static void mocacli_get_stag_removal_help( void )
{
   printf("Tag reference table, used for tag removal\n");

   printf("\nmocap get --stag_removal\n");
}

MOCALIB_CLI_GET static int mocacli_get_stag_removal_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_stag_removal stag_removal;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_stag_removal_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&stag_removal, 0, sizeof(stag_removal));

      ret = moca_get_stag_removal(handle, &stag_removal);

      if (ret == 0) {
         mocacli_print_stag_removal(&stag_removal);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_stag_removal_help( void )
{
   printf("Tag reference table, used for tag removal\n");

   printf("\nmocap set --stag_removal <options>\n");
   printf("options:\n");
   printf("   valid_3   <uint32>\n");
   printf("   valid_1   <uint32>\n");
   printf("   valid_0   <uint32>\n");
   printf("   mask_3    <uint32>\n");
   printf("   value_2   <uint32>\n");
   printf("   valid_2   <uint32>\n");
   printf("   value_3   <uint32>\n");
   printf("   value_1   <uint32>\n");
   printf("   enable    <uint32>\n");
   printf("   value_0   <uint32>\n");
   printf("   mask_1    <uint32>\n");
   printf("   mask_0    <uint32>\n");
   printf("   mask_2    <uint32>\n");
}

MOCALIB_CLI_SET static int mocacli_set_stag_removal_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_stag_removal stag_removal;

   if (handle != NULL)
   {
      ret = moca_get_stag_removal(handle, &stag_removal);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "valid_3"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_removal__valid_3_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_removal.valid_3);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_removal__valid_3_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "valid_1"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_removal__valid_1_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_removal.valid_1);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_removal__valid_1_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "valid_0"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_removal__valid_0_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_removal.valid_0);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_removal__valid_0_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "mask_3"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_removal__mask_3_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_removal.mask_3);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_removal__mask_3_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "value_2"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_removal__value_2_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_removal.value_2);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_removal__value_2_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "valid_2"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_removal__valid_2_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_removal.valid_2);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_removal__valid_2_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "value_3"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_removal__value_3_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_removal.value_3);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_removal__value_3_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "value_1"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_removal__value_1_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_removal.value_1);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_removal__value_1_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "enable"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_removal__enable_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_removal.enable);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_removal__enable_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "value_0"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_removal__value_0_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_removal.value_0);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_removal__value_0_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "mask_1"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_removal__mask_1_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_removal.mask_1);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_removal__mask_1_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "mask_0"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_removal__mask_0_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_removal.mask_0);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_removal__mask_0_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "mask_2"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_stag_removal__mask_2_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &stag_removal.mask_2);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_stag_removal__mask_2_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_stag_removal_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_stag_removal(handle, &stag_removal);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_pqos_create_flow__ingress_node_help(void)
{
   printf("ingress_node:\n");
   printf("=============\n");
   printf("MAC address of the ingress node of the flow.\n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_create_flow__egress_node_help(void)
{
   printf("egress_node:\n");
   printf("============\n");
   printf("MAC address of the egress node of the flow. If more than 1 node will be on the egress of this flow, set this field to broadcast MAC address (FF:FF:FF:FF:FF:FF).\n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_create_flow__flow_id_help(void)
{
   printf("flow_id:\n");
   printf("========\n");
   printf("Flow identifier in the form of a multicast MAC address\n");
   printf("Default:\n");
   printf("01:00:5e:00:01:00 \n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_create_flow__packet_da_help(void)
{
   printf("packet_da:\n");
   printf("==========\n");
   printf("Destination MAC address of the actual traffic to be sent on this flow.\n");
   printf("Default:\n");
   printf("01:00:5e:00:01:00 \n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_create_flow__packet_size_help(void)
{
   printf("packet_size:\n");
   printf("============\n");
   printf("Packet size in bytes, including the VLAN header but not including the FCS.\n");
   printf("\nValues:\n");
   printf("The minimum value of 59 is not valid, but are required for CTP testing. The actual valid range is 60-1518. The maximum value comes from the parameter pqos_max_packet_size.\n");
   printf("Default:\n");
   printf("800 \n");
   printf("Minimum:\n");
   printf("59 \n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_create_flow__flow_tag_help(void)
{
   printf("flow_tag:\n");
   printf("=========\n");
   printf("Optional identifier for application use.\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_create_flow__peak_data_rate_help(void)
{
   printf("peak_data_rate:\n");
   printf("===============\n");
   printf("Peak data rate in kbps\n");
   printf("Default:\n");
   printf("1000 \n");
   printf("Minimum:\n");
   printf("1 \n");
   printf("Maximum:\n");
   printf("0xFFFFFF \n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_create_flow__lease_time_help(void)
{
   printf("lease_time:\n");
   printf("===========\n");
   printf("Lease time in seconds. Infinite lease time if set to zero.\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_create_flow__burst_size_help(void)
{
   printf("burst_size:\n");
   printf("===========\n");
   printf("Number of packets per burst.\n");
   printf("\nValues:\n");
   printf("The minimum value of 0 and maximum value of 10 are not valid, but are required for CTP testing. The actual valid range is 1-9.\n");
   printf("Default:\n");
   printf("2 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("10 \n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_create_flow__vlan_id_help(void)
{
   printf("vlan_id:\n");
   printf("========\n");
   printf("VLAN ID of this flow (optional, set to 0xFFFFFFFF if unused).\n");
   printf("Default:\n");
   printf("0xFFFFFFFF \n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_create_flow__max_latency_help(void)
{
   printf("max_latency:\n");
   printf("============\n");
   printf("The maximum latency of the flow.\n");
   printf("\nValues:\n");
   printf("In units of ms with range of 1 to 255. A value of 0 indicates no value for this field.\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("255 \n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_create_flow__short_term_avg_ratio_help(void)
{
   printf("short_term_avg_ratio:\n");
   printf("=====================\n");
   printf("The ratio of the short term average rate of the flow compared to the peak rate over the interval of max_latency. This value plus one serves as the numerator of the ratio. The denominator is 256. This value is only applicable when the max_latency value is greater than or equal to 10 ms.\n");
   printf("Default:\n");
   printf("255 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("255 \n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_create_flow__max_retry_help(void)
{
   printf("max_retry:\n");
   printf("==========\n");
   printf("Maximum number of retransmission attempts for each MSDU of the PQoS Flow.\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("3 \n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_create_flow__flow_per_help(void)
{
   printf("flow_per:\n");
   printf("=========\n");
   printf("Used to specify whether the flow should use the Nominal packet error rate (PER) PHY profile or the Very Low PER PHY profile.\n");
   printf("\nValues:\n");
   printf("0 - Nominal PER 1e-6 \n");
   printf("1 - Very Low PER 1e-8\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_create_flow__in_order_delivery_help(void)
{
   printf("in_order_delivery:\n");
   printf("==================\n");
   printf("Indication of recommendation for Egress Node to deliver retransmitted MSDUs belonging to this PQoS Flow in order.\n");
   printf("\nValues:\n");
   printf("0 - No information for in-order delivery \n");
   printf("1 - In-order delivery of MSDUs is not needed \n");
   printf("2 - In-order delivery of MSDUs is recommended\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("2 \n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_create_flow__traffic_protocol_help(void)
{
   printf("traffic_protocol:\n");
   printf("=================\n");
   printf("The type of traffic carried over this PQOS flow.\n");
   printf("\nValues:\n");
   printf("0 - No traffic information provided \n");
   printf("1 - UDP \n");
   printf("2 - TCP \n");
   printf("3 - RTP over UDP \n");
   printf("4 - MPEG2-TS over UDP \n");
   printf("5 - HTTP over TCP\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("5 \n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_create_flow__ingr_class_rule_help(void)
{
   printf("ingr_class_rule:\n");
   printf("================\n");
   printf("Ingress classification rule for assigning MSDUs to the PQOS flow.\n");
   printf("\nValues:\n");
   printf("0 - Classify using DA and VLAN tag, VLAN tag is 4 or 5 (MoCA 1.1 classification) \n");
   printf("4 - Classify using DA only \n");
   printf("5 - Classify using DA and DSCP, no VLAN tag \n");
   printf("6 - Classify using DA and VLAN tag, ignore DSCP \n");
   printf("7 - Classify using DA and VLAN tag if present, otherwise DA and DSCP\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_create_flow__vlan_tag_help(void)
{
   printf("vlan_tag:\n");
   printf("=========\n");
   printf("The VLAN priority used for MSDU classification when ingr_class_rule is set to 6 or 7.\n");
   printf("Default:\n");
   printf("5 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("7 \n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_create_flow__dscp_moca_help(void)
{
   printf("dscp_moca:\n");
   printf("==========\n");
   printf("The value of the three MSB of the DSCP Type of Service field used for MSDU classification when ingr_class_ryle is set to 1 or 3.\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("7 \n");
}

MOCALIB_CLI_HELP static void mocacli_do_pqos_create_flow_help( void )
{
   printf("Creating a new PQoS flow. The flowid field must be unique to the network. The Ingress side is configured by entering the ingress node MAC address. The Egress side is configured by entering the egress node MAC address.\n");

   printf("\nmocap do --pqos_create_flow <options>\n");
   printf("options:\n");
   printf("   ingress_node           <macaddr>\n");
   printf("   egress_node            <macaddr>\n");
   printf("   flow_id                <macaddr>\n");
   printf("   packet_da              <macaddr>\n");
   printf("   packet_size            <uint32>\n");
   printf("   flow_tag               <uint32>\n");
   printf("   peak_data_rate         <uint32>\n");
   printf("   lease_time             <uint32>\n");
   printf("   burst_size             <uint32>\n");
   printf("   vlan_id                <uint32>\n");
   printf("   max_latency            <uint32>\n");
   printf("   short_term_avg_ratio   <uint32>\n");
   printf("   max_retry              <uint32>\n");
   printf("   flow_per               <uint32>\n");
   printf("   in_order_delivery      <uint32>\n");
   printf("   traffic_protocol       <uint32>\n");
   printf("   ingr_class_rule        <uint32>\n");
   printf("   vlan_tag               <uint32>\n");
   printf("   dscp_moca              <uint32>\n");
}

MOCALIB_CLI_DO static int mocacli_do_pqos_create_flow_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_pqos_create_flow_out pqos_create_flow;
   int found_ingress_node = 0;
   int found_egress_node = 0;
   struct moca_pqos_create_flow_in pqos_create_flow_in;

   memset(&pqos_create_flow_in, 0, sizeof(pqos_create_flow_in));
   MOCA_SET_PQOS_CREATE_FLOW_FLOW_ID_DEF(pqos_create_flow_in.flow_id);
   MOCA_SET_PQOS_CREATE_FLOW_PACKET_DA_DEF(pqos_create_flow_in.packet_da);
   pqos_create_flow_in.packet_size = MOCA_PQOS_CREATE_FLOW_PACKET_SIZE_DEF;
   pqos_create_flow_in.flow_tag = MOCA_PQOS_CREATE_FLOW_FLOW_TAG_DEF;
   pqos_create_flow_in.peak_data_rate = MOCA_PQOS_CREATE_FLOW_PEAK_DATA_RATE_DEF;
   pqos_create_flow_in.lease_time = MOCA_PQOS_CREATE_FLOW_LEASE_TIME_DEF;
   pqos_create_flow_in.burst_size = MOCA_PQOS_CREATE_FLOW_BURST_SIZE_DEF;
   pqos_create_flow_in.vlan_id = MOCA_PQOS_CREATE_FLOW_VLAN_ID_DEF;
   pqos_create_flow_in.max_latency = MOCA_PQOS_CREATE_FLOW_MAX_LATENCY_DEF;
   pqos_create_flow_in.short_term_avg_ratio = MOCA_PQOS_CREATE_FLOW_SHORT_TERM_AVG_RATIO_DEF;
   pqos_create_flow_in.max_retry = MOCA_PQOS_CREATE_FLOW_MAX_RETRY_DEF;
   pqos_create_flow_in.flow_per = MOCA_PQOS_CREATE_FLOW_FLOW_PER_DEF;
   pqos_create_flow_in.in_order_delivery = MOCA_PQOS_CREATE_FLOW_IN_ORDER_DELIVERY_DEF;
   pqos_create_flow_in.traffic_protocol = MOCA_PQOS_CREATE_FLOW_TRAFFIC_PROTOCOL_DEF;
   pqos_create_flow_in.ingr_class_rule = MOCA_PQOS_CREATE_FLOW_INGR_CLASS_RULE_DEF;
   pqos_create_flow_in.vlan_tag = MOCA_PQOS_CREATE_FLOW_VLAN_TAG_DEF;
   pqos_create_flow_in.dscp_moca = MOCA_PQOS_CREATE_FLOW_DSCP_MOCA_DEF;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_do_pqos_create_flow_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "ingress_node"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_pqos_create_flow__ingress_node_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_macaddr(*pp_parms, &pqos_create_flow_in.ingress_node);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_pqos_create_flow__ingress_node_help();
               return(ret);
            }
            found_ingress_node = 1;
         }
      }
      else if (!strcmp(*pp_parms, "egress_node"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_pqos_create_flow__egress_node_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_macaddr(*pp_parms, &pqos_create_flow_in.egress_node);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_pqos_create_flow__egress_node_help();
               return(ret);
            }
            found_egress_node = 1;
         }
      }
      else if (!strcmp(*pp_parms, "flow_id"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_pqos_create_flow__flow_id_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_macaddr(*pp_parms, &pqos_create_flow_in.flow_id);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_pqos_create_flow__flow_id_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "packet_da"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_pqos_create_flow__packet_da_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_macaddr(*pp_parms, &pqos_create_flow_in.packet_da);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_pqos_create_flow__packet_da_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "packet_size"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_pqos_create_flow__packet_size_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &pqos_create_flow_in.packet_size);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_pqos_create_flow__packet_size_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "flow_tag"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_pqos_create_flow__flow_tag_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &pqos_create_flow_in.flow_tag);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_pqos_create_flow__flow_tag_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "peak_data_rate"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_pqos_create_flow__peak_data_rate_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &pqos_create_flow_in.peak_data_rate);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_pqos_create_flow__peak_data_rate_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "lease_time"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_pqos_create_flow__lease_time_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &pqos_create_flow_in.lease_time);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_pqos_create_flow__lease_time_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "burst_size"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_pqos_create_flow__burst_size_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &pqos_create_flow_in.burst_size);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_pqos_create_flow__burst_size_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "vlan_id"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_pqos_create_flow__vlan_id_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &pqos_create_flow_in.vlan_id);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_pqos_create_flow__vlan_id_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "max_latency"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_pqos_create_flow__max_latency_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &pqos_create_flow_in.max_latency);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_pqos_create_flow__max_latency_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "short_term_avg_ratio"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_pqos_create_flow__short_term_avg_ratio_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &pqos_create_flow_in.short_term_avg_ratio);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_pqos_create_flow__short_term_avg_ratio_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "max_retry"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_pqos_create_flow__max_retry_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &pqos_create_flow_in.max_retry);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_pqos_create_flow__max_retry_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "flow_per"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_pqos_create_flow__flow_per_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &pqos_create_flow_in.flow_per);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_pqos_create_flow__flow_per_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "in_order_delivery"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_pqos_create_flow__in_order_delivery_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &pqos_create_flow_in.in_order_delivery);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_pqos_create_flow__in_order_delivery_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "traffic_protocol"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_pqos_create_flow__traffic_protocol_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &pqos_create_flow_in.traffic_protocol);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_pqos_create_flow__traffic_protocol_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "ingr_class_rule"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_pqos_create_flow__ingr_class_rule_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &pqos_create_flow_in.ingr_class_rule);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_pqos_create_flow__ingr_class_rule_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "vlan_tag"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_pqos_create_flow__vlan_tag_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &pqos_create_flow_in.vlan_tag);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_pqos_create_flow__vlan_tag_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "dscp_moca"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_pqos_create_flow__dscp_moca_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &pqos_create_flow_in.dscp_moca);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_pqos_create_flow__dscp_moca_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_do_pqos_create_flow_help();
         return(0);
      }

   }

   if (!found_ingress_node)
   {
      printf("Missing ingress_node parameter.\n");
      return(0);
   }
   if (!found_egress_node)
   {
      printf("Missing egress_node parameter.\n");
      return(0);
   }

   if (handle != NULL)
   {
      memset(&pqos_create_flow, 0, sizeof(pqos_create_flow));

      ret = moca_do_pqos_create_flow(handle, &pqos_create_flow_in, &pqos_create_flow);

      if (ret == 0)
         mocacli_print_pqos_create_flow(&pqos_create_flow);
      else
         printf("Error %d\n", ret);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_pqos_update_flow__flow_id_help(void)
{
   printf("flow_id:\n");
   printf("========\n");
   printf("Flow identifier in the form of a multicast MAC address\n");
   printf("Default:\n");
   printf("01:00:5e:00:00:00 \n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_update_flow__ingress_mac_help(void)
{
   printf("ingress_mac:\n");
   printf("============\n");
   printf("MAC address of the ingress node. This can be obtained for the given Flow ID from a PQOS Query operation.\n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_update_flow__egress_mac_help(void)
{
   printf("egress_mac:\n");
   printf("===========\n");
   printf("MAC address of the egress node. This can be obtained for the given Flow ID from a PQOS Query operation.\n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_update_flow__reserved_help(void)
{
   printf("reserved:\n");
   printf("=========\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_update_flow__packet_size_help(void)
{
   printf("packet_size:\n");
   printf("============\n");
   printf("Packet size in bytes.\n");
   printf("\nValues:\n");
   printf("The minimum value of 59 is not valid, but is required for CTP testing.The maximum size comes from the parameter pqos_max_packet_size.\n");
   printf("Minimum:\n");
   printf("59 \n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_update_flow__flow_tag_help(void)
{
   printf("flow_tag:\n");
   printf("=========\n");
   printf("Optional identifier for application use.\n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_update_flow__peak_data_rate_help(void)
{
   printf("peak_data_rate:\n");
   printf("===============\n");
   printf("Peak data rate in kbps\n");
   printf("Minimum:\n");
   printf("1 \n");
   printf("Maximum:\n");
   printf("0xFFFFFE \n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_update_flow__lease_time_help(void)
{
   printf("lease_time:\n");
   printf("===========\n");
   printf("Lease time in seconds. Infinite lease time if set to zero.\n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_update_flow__burst_size_help(void)
{
   printf("burst_size:\n");
   printf("===========\n");
   printf("Number of packets per burst.\n");
   printf("Minimum:\n");
   printf("1 \n");
   printf("Maximum:\n");
   printf("9 \n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_update_flow__max_latency_help(void)
{
   printf("max_latency:\n");
   printf("============\n");
   printf("The maximum latency of the flow.\n");
   printf("\nValues:\n");
   printf("In units of ms with range of 1 to 255. A value of 0 indicates no value for this field.\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("255 \n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_update_flow__short_term_avg_ratio_help(void)
{
   printf("short_term_avg_ratio:\n");
   printf("=====================\n");
   printf("The ratio of the short term average rate of the flow compared to the peak rate over the interval of max_latency. This value plus one serves as the numerator of the ratio. The denominator is 256. This value is only applicable when the max_latency value is greater than or equal to 10 ms.\n");
   printf("Default:\n");
   printf("255 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("255 \n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_update_flow__max_retry_help(void)
{
   printf("max_retry:\n");
   printf("==========\n");
   printf("Maximum number of retransmission attempts for each MSDU of the PQoS Flow.\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("3 \n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_update_flow__flow_per_help(void)
{
   printf("flow_per:\n");
   printf("=========\n");
   printf("Used to specify whether the flow should use the Nominal packet error rate (PER) PHY profile or the Very Low PER PHY profile.\n");
   printf("\nValues:\n");
   printf("0 - Nominal PER 1e-6 \n");
   printf("1 - Very Low PER 1e-8\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_update_flow__in_order_delivery_help(void)
{
   printf("in_order_delivery:\n");
   printf("==================\n");
   printf("Indication of recommendation for Egress Node to deliver retransmitted MSDUs belonging to this PQoS Flow in order.\n");
   printf("\nValues:\n");
   printf("0 - No information for in-order delivery \n");
   printf("1 - In-order delivery of MSDUs is not needed \n");
   printf("2 - In-order delivery of MSDUs is recommended\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("2 \n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_update_flow__traffic_protocol_help(void)
{
   printf("traffic_protocol:\n");
   printf("=================\n");
   printf("The type of traffic carried over this PQOS flow.\n");
   printf("\nValues:\n");
   printf("0 - No traffic information provided \n");
   printf("1 - UDP \n");
   printf("2 - TCP \n");
   printf("3 - RTP over UDP \n");
   printf("4 - MPEG2-TS over UDP \n");
   printf("5 - HTTP over TCP\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("5 \n");
}

MOCALIB_CLI_HELP static void mocacli_do_pqos_update_flow_help( void )
{
   printf("Update the parameters of an existing PQoS flow\n");

   printf("\nmocap do --pqos_update_flow <options>\n");
   printf("options:\n");
   printf("   flow_id                <macaddr>\n");
   printf("   ingress_mac            <macaddr>\n");
   printf("   egress_mac             <macaddr>\n");
   printf("   reserved               <uint16>\n");
   printf("   packet_size            <uint32>\n");
   printf("   flow_tag               <uint32>\n");
   printf("   peak_data_rate         <uint32>\n");
   printf("   lease_time             <uint32>\n");
   printf("   burst_size             <uint32>\n");
   printf("   max_latency            <uint32>\n");
   printf("   short_term_avg_ratio   <uint32>\n");
   printf("   max_retry              <uint32>\n");
   printf("   flow_per               <uint32>\n");
   printf("   in_order_delivery      <uint32>\n");
   printf("   traffic_protocol       <uint32>\n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_delete_flow__flow_id_help(void)
{
   printf("flow_id:\n");
   printf("========\n");
   printf("Default:\n");
   printf("01:00:5e:00:00:00 \n");
}

MOCALIB_CLI_HELP static void mocacli_do_pqos_delete_flow_help( void )
{
   printf("Deleting an existing PQoS flow\n");

   printf("\nmocap do --pqos_delete_flow <macaddr flow_id>\n");
}

MOCALIB_CLI_DO static int mocacli_do_pqos_delete_flow_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_pqos_delete_flow_out pqos_delete_flow;
   macaddr_t flow_id;
   MOCA_SET_PQOS_DELETE_FLOW_DEF(flow_id);

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_do_pqos_delete_flow_help();
      mocacli_pqos_delete_flow__flow_id_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_pqos_delete_flow__flow_id_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_macaddr(*pp_parms, &flow_id);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_pqos_delete_flow__flow_id_help();
               return(ret);
            }
         }
   }


   if (handle != NULL)
   {
      memset(&pqos_delete_flow, 0, sizeof(pqos_delete_flow));

      ret = moca_do_pqos_delete_flow(handle, flow_id, &pqos_delete_flow);

      if (ret == 0)
         mocacli_print_pqos_delete_flow(&pqos_delete_flow);
      else
         printf("Error %d\n", ret);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_pqos_list__ingr_node_id_help(void)
{
   printf("ingr_node_id:\n");
   printf("=============\n");
   printf("Node ID of the ingress node. Only used if ingress_node_mac is set to zero.\n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_list__ingr_node_mac_help(void)
{
   printf("ingr_node_mac:\n");
   printf("==============\n");
   printf("MAC address of the ingress node. Set to 00:00:00:00:00:00 to specify the node using the ingress_node_id parameter.\n");
   printf("Default:\n");
   printf("00:00:00:00:00:00 \n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_list__flow_max_return_help(void)
{
   printf("flow_max_return:\n");
   printf("================\n");
   printf("The maximum number of flows to be returned in this operation.\n");
   printf("Default:\n");
   printf("32 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("32 \n");
}

MOCALIB_CLI_HELP static void mocacli_pqos_list__flow_start_index_help(void)
{
   printf("flow_start_index:\n");
   printf("=================\n");
   printf("The index of the first flow to be returned from the requested node.\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_do_pqos_list_help( void )
{
   printf("Retrieving the list of flow IDs for a specific ingress node. The node can be selected by its MAC Addr or its node ID.\n");
   printf("A maximum of 32 PQOS flows will be returned.\n");

   printf("\nmocap do --pqos_list <options>\n");
   printf("options:\n");
   printf("   ingr_node_id       <uint32>\n");
   printf("   ingr_node_mac      <macaddr>\n");
   printf("   flow_max_return    <uint16>\n");
   printf("   flow_start_index   <uint32>\n");
}

MOCALIB_CLI_DO static int mocacli_do_pqos_list_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_pqos_list_out pqos_list;
   int found_ingr_node_id = 0;
   struct moca_pqos_list_in pqos_list_in;

   memset(&pqos_list_in, 0, sizeof(pqos_list_in));
   MOCA_SET_PQOS_LIST_INGR_NODE_MAC_DEF(pqos_list_in.ingr_node_mac);
   pqos_list_in.flow_max_return = MOCA_PQOS_LIST_FLOW_MAX_RETURN_DEF;
   pqos_list_in.flow_start_index = MOCA_PQOS_LIST_FLOW_START_INDEX_DEF;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_do_pqos_list_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "ingr_node_id"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_pqos_list__ingr_node_id_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &pqos_list_in.ingr_node_id);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_pqos_list__ingr_node_id_help();
               return(ret);
            }
            found_ingr_node_id = 1;
         }
      }
      else if (!strcmp(*pp_parms, "ingr_node_mac"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_pqos_list__ingr_node_mac_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_macaddr(*pp_parms, &pqos_list_in.ingr_node_mac);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_pqos_list__ingr_node_mac_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "flow_max_return"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_pqos_list__flow_max_return_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint16(*pp_parms, &pqos_list_in.flow_max_return);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_pqos_list__flow_max_return_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "flow_start_index"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_pqos_list__flow_start_index_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &pqos_list_in.flow_start_index);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_pqos_list__flow_start_index_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_do_pqos_list_help();
         return(0);
      }

   }

   if (!found_ingr_node_id)
   {
      printf("Missing ingr_node_id parameter.\n");
      return(0);
   }

   if (handle != NULL)
   {
      memset(&pqos_list, 0, sizeof(pqos_list));

      ret = moca_do_pqos_list(handle, &pqos_list_in, &pqos_list);

      if (ret == 0)
         mocacli_print_pqos_list(&pqos_list);
      else
         printf("Error %d\n", ret);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_pqos_query__flow_id_help(void)
{
   printf("flow_id:\n");
   printf("========\n");
   printf("Flow identifier in the form of a multicast MAC address\n");
   printf("Default:\n");
   printf("01:00:5e:00:01:00 \n");
}

MOCALIB_CLI_HELP static void mocacli_do_pqos_query_help( void )
{
   printf("Retrieving a specific PQoS flow parameters\n");

   printf("\nmocap do --pqos_query <macaddr flow_id>\n");
}

MOCALIB_CLI_DO static int mocacli_do_pqos_query_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_pqos_query_out pqos_query;
   macaddr_t flow_id;
   MOCA_SET_PQOS_QUERY_DEF(flow_id);

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_do_pqos_query_help();
      mocacli_pqos_query__flow_id_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_pqos_query__flow_id_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_macaddr(*pp_parms, &flow_id);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_pqos_query__flow_id_help();
               return(ret);
            }
         }
   }


   if (handle != NULL)
   {
      memset(&pqos_query, 0, sizeof(pqos_query));

      ret = moca_do_pqos_query(handle, flow_id, &pqos_query);

      if (ret == 0)
         mocacli_print_pqos_query(&pqos_query);
      else
         printf("Error %d\n", ret);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_pqos_status__unused_help(void)
{
   printf("unused:\n");
   printf("=======\n");
   printf("Dummy variable.\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_do_pqos_status_help( void )
{
   printf("Perform a PQOS Status operation to obtain the available PQOS resources on this node.\n");

   printf("\nmocap do --pqos_status <uint32 unused>\n");
}

MOCALIB_CLI_DO static int mocacli_do_pqos_status_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_pqos_status_out pqos_status;
   uint32_t unused;
   unused = MOCA_PQOS_STATUS_DEF;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_do_pqos_status_help();
      mocacli_pqos_status__unused_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_pqos_status__unused_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &unused);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_pqos_status__unused_help();
               return(ret);
            }
         }
   }


   if (handle != NULL)
   {
      memset(&pqos_status, 0, sizeof(pqos_status));

      ret = moca_do_pqos_status(handle, unused, &pqos_status);

      if (ret == 0)
         mocacli_print_pqos_status(&pqos_status);
      else
         printf("Error %d\n", ret);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_mcfilter_clear_table_help( void )
{
   printf("Clear Multicast filtering table.\n");

   printf("\nmocap set --mcfilter_clear_table\n");
}

MOCALIB_CLI_SET static int mocacli_set_mcfilter_clear_table_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;


   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_set_mcfilter_clear_table_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   if (handle != NULL)
   {
      ret = moca_set_mcfilter_clear_table(handle);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_get_mcfilter_table_help( void )
{
   printf("Get Multicast MAC Address filtering entry.\n");

   printf("\nmocap get --mcfilter_table\n");
}

MOCALIB_CLI_GET static int mocacli_get_mcfilter_table_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_mcfilter_table mcfilter_table;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_mcfilter_table_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&mcfilter_table, 0, sizeof(mcfilter_table));

      ret = moca_get_mcfilter_table(handle, &mcfilter_table);

      if (ret == 0) {
         mocacli_print_mcfilter_table(&mcfilter_table);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_host_qos__enable_help(void)
{
   printf("enable:\n");
   printf("=======\n");
   printf("\nValues:\n");
   printf("0 = mocad will not create filters \n");
   printf("1 = mocad will create filters\n");
   printf("Default:\n");
   printf("1 (FC_CAPABLE_CHIP)\n0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_host_qos_help( void )
{
   printf("Controls whether or not mocad will automatically create filters for prioritizing MoCA traffic, including PQOS traffic.\n");

   printf("\nmocap get --host_qos\n");
}

MOCALIB_CLI_GET static int mocacli_get_host_qos_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t host_qos;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_host_qos_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&host_qos, 0, sizeof(host_qos));

      ret = moca_get_host_qos(handle, &host_qos);

      if (ret == 0) {
         mocacli_print_host_qos(&host_qos);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_host_qos_help( void )
{
   printf("Controls whether or not mocad will automatically create filters for prioritizing MoCA traffic, including PQOS traffic.\n");

   printf("\nmocap set --host_qos <uint32 enable>\n");
}

MOCALIB_CLI_SET static int mocacli_set_host_qos_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t host_qos;

   if (handle != NULL)
   {
      ret = moca_get_host_qos(handle, &host_qos);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_host_qos_help();
            mocacli_host_qos__enable_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &host_qos);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_host_qos__enable_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_host_qos(handle, host_qos);
   }

   return(ret);
}

MOCALIB_CLI_GET static int mocacli_get_forwarding_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   char **tmpPtr = pp_parms; 
   int nump = num_parms; 

   while (nump > 0)
   {
      if ((nump != 0) && !strcmp(*tmpPtr, "help"))
      {
         printf("The Forwarding group of parameters are used to control how data traffic is handled by the MoCA core.\n");
         printf("IE list for this group: \n"); 
         printf("======================= \n"); 
         printf("multicast_mode\n"); 
         printf("low_pri_q_num\n"); 
         printf("egr_mc_filter_en\n"); 
         printf("fc_mode\n"); 
         printf("pqos_max_packet_size\n"); 
         printf("per_mode\n"); 
         printf("policing_en\n"); 
         printf("pqos_egress_numflows\n"); 
         printf("orr_en\n"); 
         printf("brcmtag_enable\n"); 
         printf("priority_allocations\n"); 
         printf("uc_fwd\n"); 
         printf("src_addr\n"); 
         printf("mac_aging\n"); 
         printf("loopback_en\n"); 
         printf("mcfilter_enable\n"); 
         printf("pause_fc_en\n"); 
         printf("stag_priority\n"); 
         printf("stag_removal\n"); 
         printf("mcfilter_table\n"); 
         printf("host_qos\n"); 
         return(0); 
      }
      tmpPtr++;
      nump--;
  }

   if (handle != NULL)
   {
      ret = mocacli_get_multicast_mode_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_low_pri_q_num_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_egr_mc_filter_en_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_fc_mode_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_pqos_max_packet_size_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_per_mode_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_policing_en_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_pqos_egress_numflows_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_orr_en_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_brcmtag_enable_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_priority_allocations_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_uc_fwd_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_src_addr_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_mac_aging_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_loopback_en_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_mcfilter_enable_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_pause_fc_en_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_stag_priority_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_stag_removal_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_mcfilter_table_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_host_qos_handler(handle, pp_parms, num_parms );

   }
   return(ret);
}

MOCALIB_CLI_PRINT void mocacli_print_ooo_lmo_threshold (uint32_t * in)
{
   printf("ooo_lmo_threshold: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_taboo_channels (struct moca_taboo_channels * in)
{
   printf("== taboo_channels ");
   printf(" ==================================== \n");
   printf("taboo_fixed_mask_start  : %u  ( 0x%x )\n", in->taboo_fixed_mask_start, in->taboo_fixed_mask_start);
   printf("taboo_fixed_channel_mask: %u  ( 0x%x )\n", in->taboo_fixed_channel_mask, in->taboo_fixed_channel_mask);
   printf("taboo_left_mask         : %u  ( 0x%x )\n", in->taboo_left_mask, in->taboo_left_mask);
   printf("taboo_right_mask        : %u  ( 0x%x )\n", in->taboo_right_mask, in->taboo_right_mask);
   printf("== end taboo_channels ");
   printf(" ================================ \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_gen_node_status (struct moca_gen_node_status * in)
{
   printf("== gen_node_status ");
   printf(" =================================== \n");
   printf("eui                : %02x:%02x:%02x:%02x:%02x:%02x \n", MOCA_DISPLAY_MAC(in->eui));
   printf("freq_offset        : %d Hz\n", in->freq_offset);
   printf("node_tx_backoff    : %u  ( 0x%x )\n", in->node_tx_backoff, in->node_tx_backoff);
   printf("protocol_support   : 0x%x (MoCA:%x Concat:%d Bonding:%d 1.1Aggr:%d PrfNC:%d QAM256:%d)\n", in->protocol_support, (in->protocol_support >> 24), ((in->protocol_support >> 10) & 0x1), ((in->protocol_support >> 9) & 1), ((in->protocol_support >> 7) & 0x3) == 0x2 ? 10 : 6, ((in->protocol_support >> 6) & 0x1), ((in->protocol_support >> 4) & 0x1));
   printf("active_moca_version: %u  ( 0x%x )\n", in->active_moca_version, in->active_moca_version);
   printf("max_ingress_pqos   : %u  ( 0x%x )\n", in->max_ingress_pqos, in->max_ingress_pqos);
   printf("max_egress_pqos    : %u  ( 0x%x )\n", in->max_egress_pqos, in->max_egress_pqos);
   printf("ae_number          : %u  ( 0x%x )\n", in->ae_number, in->ae_number);
   printf("max_aggr_pdus      : %u  ( 0x%x )\n", in->max_aggr_pdus, in->max_aggr_pdus);
   printf("max_aggr_kb        : %u  ( 0x%x )\n", in->max_aggr_kb, in->max_aggr_kb);
   printf("== end gen_node_status ");
   printf(" =============================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_gen_node_ext_status (struct moca_gen_node_ext_status * in)
{
   uint32_t i;

   printf("== gen_node_ext_status ");
   printf(" =============================== \n");
   printf("nbas           : %u  ( 0x%x )\n", in->nbas, in->nbas);
   printf("preamble_type  : %u  ( 0x%x )\n", (in->preamble_type == 0 ? 1 : (in->preamble_type == 1 ? 1 : (in->preamble_type == 2 ? 2 : (in->preamble_type == 12 ? 0 : (in->preamble_type - 1))))), (in->preamble_type == 0 ? 1 : (in->preamble_type == 1 ? 1 : (in->preamble_type == 2 ? 2 : (in->preamble_type == 12 ? 0 : (in->preamble_type - 1))))));
   printf("cp             : %u  ( 0x%x )\n", in->cp, in->cp);
   printf("tx_power       : %d dBm\n", in->tx_power);
   printf("rx_power       : %d.%02d \n", in->rx_power>>4, (in->rx_power&0xF)*100/16);
   printf("agc_address    : 0x%x  ( %d )\n", in->agc_address, in->agc_address);
   printf("bit_loading[64]: ");
   for (i = 0; i < 64; i++) {
      printf("%08x ", in->bit_loading[i]);
      if (i % 8 == 7) printf("\n                 ");
   }
   printf("\n");
   printf("avg_snr        : %d.%03d \n", in->avg_snr>>8, (in->avg_snr&0xFF)*1000/256);
   printf("phy_rate       : %d Mbps\n", in->phy_rate);
   printf("turbo_status   : %u  ( 0x%x )\n", in->turbo_status, in->turbo_status);
   printf("tx_backoff     : %d dB\n", in->tx_backoff);
   printf("rx_backoff     : %d dB\n", in->rx_backoff);
   printf("== end gen_node_ext_status ");
   printf(" =========================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_node_stats (struct moca_node_stats * in)
{
   printf("== node_stats ");
   printf(" ======================================== \n");
   printf("tx_packets                    : %d\n", in->tx_packets);
   printf("rx_packets                    : %d\n", in->rx_packets);
   printf("primary_ch_rx_cw_unerror      : %d\n", in->primary_ch_rx_cw_unerror);
   printf("primary_ch_rx_cw_corrected    : %d\n", in->primary_ch_rx_cw_corrected);
   printf("primary_ch_rx_cw_uncorrected  : %d\n", in->primary_ch_rx_cw_uncorrected);
   printf("primary_ch_rx_no_sync         : %d\n", in->primary_ch_rx_no_sync);
   printf("secondary_ch_rx_cw_unerror    : %d\n", in->secondary_ch_rx_cw_unerror);
   printf("secondary_ch_rx_cw_corrected  : %d\n", in->secondary_ch_rx_cw_corrected);
   printf("secondary_ch_rx_cw_uncorrected: %d\n", in->secondary_ch_rx_cw_uncorrected);
   printf("secondary_ch_rx_no_sync       : %d\n", in->secondary_ch_rx_no_sync);
   printf("== end node_stats ");
   printf(" ==================================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_node_stats_ext (struct moca_node_stats_ext * in)
{
   printf("== node_stats_ext ");
   printf(" ==================================== \n");
   printf("rx_uc_crc_error              : %u  ( 0x%04x )\n", in->rx_uc_crc_error, in->rx_uc_crc_error);
   printf("rx_uc_crc_error_sec_ch       : %u  ( 0x%04x )\n", in->rx_uc_crc_error_sec_ch, in->rx_uc_crc_error_sec_ch);
   printf("rx_uc_timeout_error          : %u  ( 0x%04x )\n", in->rx_uc_timeout_error, in->rx_uc_timeout_error);
   printf("rx_uc_timeout_error_sec_ch   : %u  ( 0x%04x )\n", in->rx_uc_timeout_error_sec_ch, in->rx_uc_timeout_error_sec_ch);
   printf("rx_bc_crc_error              : %u  ( 0x%04x )\n", in->rx_bc_crc_error, in->rx_bc_crc_error);
   printf("rx_bc_timeout_error          : %u  ( 0x%04x )\n", in->rx_bc_timeout_error, in->rx_bc_timeout_error);
   printf("rx_map_crc_error             : %u  ( 0x%04x )\n", in->rx_map_crc_error, in->rx_map_crc_error);
   printf("rx_map_timeout_error         : %u  ( 0x%04x )\n", in->rx_map_timeout_error, in->rx_map_timeout_error);
   printf("rx_beacon_crc_error          : %u  ( 0x%04x )\n", in->rx_beacon_crc_error, in->rx_beacon_crc_error);
   printf("rx_beacon_timeout_error      : %u  ( 0x%04x )\n", in->rx_beacon_timeout_error, in->rx_beacon_timeout_error);
   printf("rx_rr_crc_error              : %u  ( 0x%04x )\n", in->rx_rr_crc_error, in->rx_rr_crc_error);
   printf("rx_ofdma_rr_crc_error        : %u  ( 0x%04x )\n", in->rx_ofdma_rr_crc_error, in->rx_ofdma_rr_crc_error);
   printf("rx_rr_timeout_error          : %u  ( 0x%04x )\n", in->rx_rr_timeout_error, in->rx_rr_timeout_error);
   printf("rx_lc_uc_crc_error           : %u  ( 0x%04x )\n", in->rx_lc_uc_crc_error, in->rx_lc_uc_crc_error);
   printf("rx_lc_bc_crc_error           : %u  ( 0x%04x )\n", in->rx_lc_bc_crc_error, in->rx_lc_bc_crc_error);
   printf("rx_lc_uc_timeout_error       : %u  ( 0x%04x )\n", in->rx_lc_uc_timeout_error, in->rx_lc_uc_timeout_error);
   printf("rx_lc_bc_timeout_error       : %u  ( 0x%04x )\n", in->rx_lc_bc_timeout_error, in->rx_lc_bc_timeout_error);
   printf("rx_probe1_error              : %u  ( 0x%04x )\n", in->rx_probe1_error, in->rx_probe1_error);
   printf("rx_probe1_error_sec_ch       : %u  ( 0x%04x )\n", in->rx_probe1_error_sec_ch, in->rx_probe1_error_sec_ch);
   printf("rx_probe2_error              : %u  ( 0x%04x )\n", in->rx_probe2_error, in->rx_probe2_error);
   printf("rx_probe3_error              : %u  ( 0x%04x )\n", in->rx_probe3_error, in->rx_probe3_error);
   printf("rx_probe1_gcd_error          : %u  ( 0x%04x )\n", in->rx_probe1_gcd_error, in->rx_probe1_gcd_error);
   printf("rx_plp_crc_error             : %u  ( 0x%04x )\n", in->rx_plp_crc_error, in->rx_plp_crc_error);
   printf("rx_plp_timeout_error         : %u  ( 0x%04x )\n", in->rx_plp_timeout_error, in->rx_plp_timeout_error);
   printf("rx_broken_packet_error       : %u  ( 0x%04x )\n", in->rx_broken_packet_error, in->rx_broken_packet_error);
   printf("rx_broken_packet_error_sec_ch: %u  ( 0x%04x )\n", in->rx_broken_packet_error_sec_ch, in->rx_broken_packet_error_sec_ch);
   printf("rx_acf_crc_error             : %u  ( 0x%04x )\n", in->rx_acf_crc_error, in->rx_acf_crc_error);
   printf("== end node_stats_ext ");
   printf(" ================================ \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_network_status (struct moca_network_status * in)
{
   printf("== network_status ");
   printf(" ==================================== \n");
   printf("network_moca_version: %u  ( 0x%x )\n", in->network_moca_version, in->network_moca_version);
   printf("connected_nodes     : %d  (bitmask 0x%x)\n", moca_count_bits(in->connected_nodes), in->connected_nodes);
   printf("node_id             : %u  ( 0x%x )\n", in->node_id, in->node_id);
   printf("nc_node_id          : %u  ( 0x%x )\n", in->nc_node_id, in->nc_node_id);
   printf("backup_nc_id        : %u  ( 0x%x )\n", in->backup_nc_id, in->backup_nc_id);
   printf("bw_status           : %u  ( 0x%x )\n", in->bw_status, in->bw_status);
   printf("nodes_usable_bitmask: %u  ( 0x%x )\n", in->nodes_usable_bitmask, in->nodes_usable_bitmask);
   printf("network_taboo_mask  : %u  ( 0x%x )\n", in->network_taboo_mask, in->network_taboo_mask);
   printf("network_taboo_start : %u  ( 0x%x )\n", in->network_taboo_start, in->network_taboo_start);
   printf("bonded_nodes_bitmask: %u  ( 0x%x )\n", in->bonded_nodes_bitmask, in->bonded_nodes_bitmask);
   printf("== end network_status ");
   printf(" ================================ \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_start_ulmo (struct moca_start_ulmo * in)
{
   uint32_t i;

   printf("== start_ulmo ");
   printf(" ======================================== \n");
   printf("report_type    : %u  ( 0x%x )\n", in->report_type, in->report_type);
   printf("node_id        : %u  ( 0x%x )\n", in->node_id, in->node_id);
   printf("ofdma_node_mask: %u  ( 0x%x )\n", in->ofdma_node_mask, in->ofdma_node_mask);
   printf("subcarrier[16] : ");
   for (i = 0; i < 16; i++) {
      printf("%08x ", in->subcarrier[i]);
      if (i % 8 == 7) printf("\n                 ");
   }
   printf("\n");
   printf("== end start_ulmo ");
   printf(" ==================================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_ofdma_definition_table (struct moca_ofdma_definition_table * in)
{
   uint32_t i;

   printf("== ofdma_definition_table ");
   printf(" ============================ \n");
   printf("ofdmaDefTabNum    : %u  ( 0x%x )\n", in->ofdmaDefTabNum, in->ofdmaDefTabNum);
   printf("subchannelDefId[4]: ");
   for (i = 0; i < 4; i++) {
      printf("0x%x ", in->subchannelDefId[i]);
      if (i % 8 == 7) printf("\n                    ");
   }
   printf("\n");
   printf("node_bitmask[4]   : ");
   for (i = 0; i < 4; i++) {
      printf("0x%x ", in->node_bitmask[i]);
      if (i % 8 == 7) printf("\n                    ");
   }
   printf("\n");
   printf("subchannel_NBAS[4]: ");
   for (i = 0; i < 4; i++) {
      printf("0x%x ", in->subchannel_NBAS[i]);
      if (i % 8 == 7) printf("\n                    ");
   }
   printf("\n");
   printf("== end ofdma_definition_table ");
   printf(" ======================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_ofdma_assignment_table (struct moca_ofdma_assignment_table * in)
{
   uint32_t i;

   printf("== ofdma_assignment_table ");
   printf(" ============================ \n");
   printf("ofdmaDefTabNum    : %u  ( 0x%x )\n", in->ofdmaDefTabNum, in->ofdmaDefTabNum);
   printf("ofdmaFrameId[4]   : ");
   for (i = 0; i < 4; i++) {
      printf("0x%x ", in->ofdmaFrameId[i]);
      if (i % 8 == 7) printf("\n                    ");
   }
   printf("\n");
   printf("subchannelDefId[4]: ");
   for (i = 0; i < 4; i++) {
      printf("0x%x ", in->subchannelDefId[i]);
      if (i % 8 == 7) printf("\n                    ");
   }
   printf("\n");
   printf("num_Subchannels[4]: ");
   for (i = 0; i < 4; i++) {
      printf("0x%x ", in->num_Subchannels[i]);
      if (i % 8 == 7) printf("\n                    ");
   }
   printf("\n");
   printf("node_bitmask[4]   : ");
   for (i = 0; i < 4; i++) {
      printf("0x%x ", in->node_bitmask[i]);
      if (i % 8 == 7) printf("\n                    ");
   }
   printf("\n");
   printf("cp_length[4]      : ");
   for (i = 0; i < 4; i++) {
      printf("0x%x ", in->cp_length[i]);
      if (i % 8 == 7) printf("\n                    ");
   }
   printf("\n");
   printf("== end ofdma_assignment_table ");
   printf(" ======================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_adm_stats (struct moca_adm_stats * in)
{
   printf("== adm_stats ");
   printf(" ========================================= \n");
   printf("started            : %u  ( 0x%04x )\n", in->started, in->started);
   printf("succeeded          : %u  ( 0x%04x )\n", in->succeeded, in->succeeded);
   printf("admission_failed   : %u  ( 0x%04x )\n", in->admission_failed, in->admission_failed);
   printf("no_response        : %u  ( 0x%04x )\n", in->no_response, in->no_response);
   printf("channel_unusable   : %u  ( 0x%04x )\n", in->channel_unusable, in->channel_unusable);
   printf("t2_timeout         : %u  ( 0x%04x )\n", in->t2_timeout, in->t2_timeout);
   printf("priv_full_blacklist: %u  ( 0x%04x )\n", in->priv_full_blacklist, in->priv_full_blacklist);
   printf("admission_failed_nc: %u  ( 0x%04x )\n", in->admission_failed_nc, in->admission_failed_nc);
   printf("resync_loss        : %u  ( 0x%04x )\n", in->resync_loss, in->resync_loss);
   printf("reserved           : %u  ( 0x%04x )\n", in->reserved, in->reserved);
   printf("== end adm_stats ");
   printf(" ===================================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_aca (struct moca_aca_out * in)
{
   uint32_t i;

   printf("== aca ");
   printf(" =============================================== \n");
   printf("aca_status        : %u  ( 0x%x )\n", in->aca_status, in->aca_status);
   printf("aca_type          : %u  ( 0x%x )\n", in->aca_type, in->aca_type);
   printf("tx_status         : %u  ( 0x%x )\n", in->tx_status, in->tx_status);
   printf("rx_status         : %u  ( 0x%x )\n", in->rx_status, in->rx_status);
   printf("total_power       : 0x%x  ( %d )\n", in->total_power, in->total_power);
   printf("relative_power    : 0x%x  ( %d )\n", in->relative_power, in->relative_power);
   printf("num_elements      : %u  ( 0x%x )\n", in->num_elements, in->num_elements);
   printf("power_profile[512]: ");
   for (i = 0; i < 512; i++) {
      printf("%4u ", in->power_profile[i]);
      if (i % 8 == 7) printf("\n                    ");
   }
   printf("\n");
   printf("== end aca ");
   printf(" =========================================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_fmr_init (struct moca_fmr_init_out * in)
{
   uint32_t i;

   printf("== fmr_init ");
   printf(" ========================================== \n");
   printf("responsecode       : %s (%d)\n", moca_l2_error_name(in->responsecode), in->responsecode);
   printf("responded_node_0   : %d\n", in->responded_node_0);
   printf("fmrinfo_node_0[16] : ");
   for (i = 0; i < 16; i++) {
      printf("%4d/%-2d ", (in->fmrinfo_node_0[i] & 0x7FF), (in->fmrinfo_node_0[i] >> 11));
   }
   printf("\n");
   printf("responded_node_1   : %d\n", in->responded_node_1);
   printf("fmrinfo_node_1[16] : ");
   for (i = 0; i < 16; i++) {
      printf("%4d/%-2d ", (in->fmrinfo_node_1[i] & 0x7FF), (in->fmrinfo_node_1[i] >> 11));
   }
   printf("\n");
   printf("responded_node_2   : %d\n", in->responded_node_2);
   printf("fmrinfo_node_2[16] : ");
   for (i = 0; i < 16; i++) {
      printf("%4d/%-2d ", (in->fmrinfo_node_2[i] & 0x7FF), (in->fmrinfo_node_2[i] >> 11));
   }
   printf("\n");
   printf("responded_node_3   : %d\n", in->responded_node_3);
   printf("fmrinfo_node_3[16] : ");
   for (i = 0; i < 16; i++) {
      printf("%4d/%-2d ", (in->fmrinfo_node_3[i] & 0x7FF), (in->fmrinfo_node_3[i] >> 11));
   }
   printf("\n");
   printf("responded_node_4   : %d\n", in->responded_node_4);
   printf("fmrinfo_node_4[16] : ");
   for (i = 0; i < 16; i++) {
      printf("%4d/%-2d ", (in->fmrinfo_node_4[i] & 0x7FF), (in->fmrinfo_node_4[i] >> 11));
   }
   printf("\n");
   printf("responded_node_5   : %d\n", in->responded_node_5);
   printf("fmrinfo_node_5[16] : ");
   for (i = 0; i < 16; i++) {
      printf("%4d/%-2d ", (in->fmrinfo_node_5[i] & 0x7FF), (in->fmrinfo_node_5[i] >> 11));
   }
   printf("\n");
   printf("responded_node_6   : %d\n", in->responded_node_6);
   printf("fmrinfo_node_6[16] : ");
   for (i = 0; i < 16; i++) {
      printf("%4d/%-2d ", (in->fmrinfo_node_6[i] & 0x7FF), (in->fmrinfo_node_6[i] >> 11));
   }
   printf("\n");
   printf("responded_node_7   : %d\n", in->responded_node_7);
   printf("fmrinfo_node_7[16] : ");
   for (i = 0; i < 16; i++) {
      printf("%4d/%-2d ", (in->fmrinfo_node_7[i] & 0x7FF), (in->fmrinfo_node_7[i] >> 11));
   }
   printf("\n");
   printf("responded_node_8   : %d\n", in->responded_node_8);
   printf("fmrinfo_node_8[16] : ");
   for (i = 0; i < 16; i++) {
      printf("%4d/%-2d ", (in->fmrinfo_node_8[i] & 0x7FF), (in->fmrinfo_node_8[i] >> 11));
   }
   printf("\n");
   printf("responded_node_9   : %d\n", in->responded_node_9);
   printf("fmrinfo_node_9[16] : ");
   for (i = 0; i < 16; i++) {
      printf("%4d/%-2d ", (in->fmrinfo_node_9[i] & 0x7FF), (in->fmrinfo_node_9[i] >> 11));
   }
   printf("\n");
   printf("responded_node_10  : %d\n", in->responded_node_10);
   printf("fmrinfo_node_10[16]: ");
   for (i = 0; i < 16; i++) {
      printf("%4d/%-2d ", (in->fmrinfo_node_10[i] & 0x7FF), (in->fmrinfo_node_10[i] >> 11));
   }
   printf("\n");
   printf("responded_node_11  : %d\n", in->responded_node_11);
   printf("fmrinfo_node_11[16]: ");
   for (i = 0; i < 16; i++) {
      printf("%4d/%-2d ", (in->fmrinfo_node_11[i] & 0x7FF), (in->fmrinfo_node_11[i] >> 11));
   }
   printf("\n");
   printf("responded_node_12  : %d\n", in->responded_node_12);
   printf("fmrinfo_node_12[16]: ");
   for (i = 0; i < 16; i++) {
      printf("%4d/%-2d ", (in->fmrinfo_node_12[i] & 0x7FF), (in->fmrinfo_node_12[i] >> 11));
   }
   printf("\n");
   printf("responded_node_13  : %d\n", in->responded_node_13);
   printf("fmrinfo_node_13[16]: ");
   for (i = 0; i < 16; i++) {
      printf("%4d/%-2d ", (in->fmrinfo_node_13[i] & 0x7FF), (in->fmrinfo_node_13[i] >> 11));
   }
   printf("\n");
   printf("responded_node_14  : %d\n", in->responded_node_14);
   printf("fmrinfo_node_14[16]: ");
   for (i = 0; i < 16; i++) {
      printf("%4d/%-2d ", (in->fmrinfo_node_14[i] & 0x7FF), (in->fmrinfo_node_14[i] >> 11));
   }
   printf("\n");
   printf("responded_node_15  : %d\n", in->responded_node_15);
   printf("fmrinfo_node_15[16]: ");
   for (i = 0; i < 16; i++) {
      printf("%4d/%-2d ", (in->fmrinfo_node_15[i] & 0x7FF), (in->fmrinfo_node_15[i] >> 11));
   }
   printf("\n");
   printf("== end fmr_init ");
   printf(" ====================================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_moca_reset (struct moca_moca_reset_out * in)
{
   printf("== moca_reset ");
   printf(" ======================================== \n");
   printf("response_code  : %s (%d)\n", moca_l2_error_name(in->response_code), in->response_code);
   printf("reset_status   : %u  ( 0x%x )\n", in->reset_status, in->reset_status);
   printf("non_def_seq_num: %u  ( 0x%x )\n", in->non_def_seq_num, in->non_def_seq_num);
   printf("n00ResetStatus : %u  ( %02x )\n", in->n00ResetStatus, in->n00ResetStatus);
   printf("n00RspCode     : %u  ( %02x )\n", in->n00RspCode, in->n00RspCode);
   printf("n01ResetStatus : %u  ( %02x )\n", in->n01ResetStatus, in->n01ResetStatus);
   printf("n01RspCode     : %u  ( %02x )\n", in->n01RspCode, in->n01RspCode);
   printf("n02ResetStatus : %u  ( %02x )\n", in->n02ResetStatus, in->n02ResetStatus);
   printf("n02RspCode     : %u  ( %02x )\n", in->n02RspCode, in->n02RspCode);
   printf("n03ResetStatus : %u  ( %02x )\n", in->n03ResetStatus, in->n03ResetStatus);
   printf("n03RspCode     : %u  ( %02x )\n", in->n03RspCode, in->n03RspCode);
   printf("n04ResetStatus : %u  ( %02x )\n", in->n04ResetStatus, in->n04ResetStatus);
   printf("n04RspCode     : %u  ( %02x )\n", in->n04RspCode, in->n04RspCode);
   printf("n05ResetStatus : %u  ( %02x )\n", in->n05ResetStatus, in->n05ResetStatus);
   printf("n05RspCode     : %u  ( %02x )\n", in->n05RspCode, in->n05RspCode);
   printf("n06ResetStatus : %u  ( %02x )\n", in->n06ResetStatus, in->n06ResetStatus);
   printf("n06RspCode     : %u  ( %02x )\n", in->n06RspCode, in->n06RspCode);
   printf("n07ResetStatus : %u  ( %02x )\n", in->n07ResetStatus, in->n07ResetStatus);
   printf("n07RspCode     : %u  ( %02x )\n", in->n07RspCode, in->n07RspCode);
   printf("n08ResetStatus : %u  ( %02x )\n", in->n08ResetStatus, in->n08ResetStatus);
   printf("n08RspCode     : %u  ( %02x )\n", in->n08RspCode, in->n08RspCode);
   printf("n09ResetStatus : %u  ( %02x )\n", in->n09ResetStatus, in->n09ResetStatus);
   printf("n09RspCode     : %u  ( %02x )\n", in->n09RspCode, in->n09RspCode);
   printf("n10ResetStatus : %u  ( %02x )\n", in->n10ResetStatus, in->n10ResetStatus);
   printf("n10RspCode     : %u  ( %02x )\n", in->n10RspCode, in->n10RspCode);
   printf("n11ResetStatus : %u  ( %02x )\n", in->n11ResetStatus, in->n11ResetStatus);
   printf("n11RspCode     : %u  ( %02x )\n", in->n11RspCode, in->n11RspCode);
   printf("n12ResetStatus : %u  ( %02x )\n", in->n12ResetStatus, in->n12ResetStatus);
   printf("n12RspCode     : %u  ( %02x )\n", in->n12RspCode, in->n12RspCode);
   printf("n13ResetStatus : %u  ( %02x )\n", in->n13ResetStatus, in->n13ResetStatus);
   printf("n13RspCode     : %u  ( %02x )\n", in->n13RspCode, in->n13RspCode);
   printf("n14ResetStatus : %u  ( %02x )\n", in->n14ResetStatus, in->n14ResetStatus);
   printf("n14RspCode     : %u  ( %02x )\n", in->n14RspCode, in->n14RspCode);
   printf("n15ResetStatus : %u  ( %02x )\n", in->n15ResetStatus, in->n15ResetStatus);
   printf("n15RspCode     : %u  ( %02x )\n", in->n15RspCode, in->n15RspCode);
   printf("== end moca_reset ");
   printf(" ==================================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_dd_init (struct moca_dd_init_out * in)
{
   uint32_t i;

   printf("== dd_init ");
   printf(" =========================================== \n");
   printf("responsecode          : %s (%d)\n", moca_l2_error_name(in->responsecode), in->responsecode);
   printf("responded_nodemask    : 0x%x\n", in->responded_nodemask);
   printf("ingress_pqos_flows[16]: ");
   for (i = 0; i < 16; i++) {
      printf("%6u ", in->ingress_pqos_flows[i]);
      if (i % 8 == 7) printf("\n                        ");
   }
   printf("\n");
   printf("egress_pqos_flows[16] : ");
   for (i = 0; i < 16; i++) {
      printf("%6u ", in->egress_pqos_flows[i]);
      if (i % 8 == 7) printf("\n                        ");
   }
   printf("\n");
   printf("aggr_pdus[16]         : ");
   for (i = 0; i < 16; i++) {
      printf("%6u ", in->aggr_pdus[i]);
      if (i % 8 == 7) printf("\n                        ");
   }
   printf("\n");
   printf("aggr_size[16]         : ");
   for (i = 0; i < 16; i++) {
      printf("%6u ", in->aggr_size[i]);
      if (i % 8 == 7) printf("\n                        ");
   }
   printf("\n");
   printf("ae_number[16]         : ");
   for (i = 0; i < 16; i++) {
      printf("%6u ", in->ae_number[i]);
      if (i % 8 == 7) printf("\n                        ");
   }
   printf("\n");
   printf("aggr_pdus_bonded[16]  : ");
   for (i = 0; i < 16; i++) {
      printf("%6u ", in->aggr_pdus_bonded[i]);
      if (i % 8 == 7) printf("\n                        ");
   }
   printf("\n");
   printf("aggr_size_bonded[16]  : ");
   for (i = 0; i < 16; i++) {
      printf("%6u ", in->aggr_size_bonded[i]);
      if (i % 8 == 7) printf("\n                        ");
   }
   printf("\n");
   printf("== end dd_init ");
   printf(" ======================================= \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_fmr_20 (struct moca_fmr_20_out * in)
{
   uint32_t i;

   printf("== fmr_20 ");
   printf(" ============================================ \n");
   printf("responsecode                    : %s (%d)\n", moca_l2_error_name(in->responsecode), in->responsecode);
   printf("node0_gap_nper[16]              : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node0_gap_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node0_gap_vlper[16]             : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node0_gap_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node0_ofdmb_nper[16]            : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node0_ofdmb_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node0_ofdmb_vlper[16]           : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node0_ofdmb_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node0_ofdmb_gcd                 : %4d \n", in->node0_ofdmb_gcd);
   printf("node0_gap_gcd                   : %4d \n", in->node0_gap_gcd);
   printf("node0_ofdma_def_tab_num         : %4d \n", in->node0_ofdma_def_tab_num);
   printf("node0_ofdma_tab_node_bitmask[4] : ");
   for (i = 0; i < 4; i++) {
      printf("%04x ", in->node0_ofdma_tab_node_bitmask[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node0_ofdma_tab_num_subchan[4]  : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node0_ofdma_tab_num_subchan[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node0_ofdma_tab_gap[4]          : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node0_ofdma_tab_gap[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node0_ofdma_tab_bps[4]          : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node0_ofdma_tab_bps[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node1_gap_nper[16]              : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node1_gap_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node1_gap_vlper[16]             : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node1_gap_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node1_ofdmb_nper[16]            : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node1_ofdmb_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node1_ofdmb_vlper[16]           : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node1_ofdmb_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node1_ofdmb_gcd                 : %4d \n", in->node1_ofdmb_gcd);
   printf("node1_gap_gcd                   : %4d \n", in->node1_gap_gcd);
   printf("node1_ofdma_def_tab_num         : %4d \n", in->node1_ofdma_def_tab_num);
   printf("node1_ofdma_tab_node_bitmask[4] : ");
   for (i = 0; i < 4; i++) {
      printf("%04x ", in->node1_ofdma_tab_node_bitmask[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node1_ofdma_tab_num_subchan[4]  : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node1_ofdma_tab_num_subchan[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node1_ofdma_tab_gap[4]          : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node1_ofdma_tab_gap[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node1_ofdma_tab_bps[4]          : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node1_ofdma_tab_bps[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node2_gap_nper[16]              : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node2_gap_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node2_gap_vlper[16]             : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node2_gap_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node2_ofdmb_nper[16]            : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node2_ofdmb_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node2_ofdmb_vlper[16]           : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node2_ofdmb_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node2_ofdmb_gcd                 : %4d \n", in->node2_ofdmb_gcd);
   printf("node2_gap_gcd                   : %4d \n", in->node2_gap_gcd);
   printf("node2_ofdma_def_tab_num         : %4d \n", in->node2_ofdma_def_tab_num);
   printf("node2_ofdma_tab_node_bitmask[4] : ");
   for (i = 0; i < 4; i++) {
      printf("%04x ", in->node2_ofdma_tab_node_bitmask[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node2_ofdma_tab_num_subchan[4]  : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node2_ofdma_tab_num_subchan[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node2_ofdma_tab_gap[4]          : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node2_ofdma_tab_gap[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node2_ofdma_tab_bps[4]          : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node2_ofdma_tab_bps[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node3_gap_nper[16]              : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node3_gap_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node3_gap_vlper[16]             : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node3_gap_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node3_ofdmb_nper[16]            : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node3_ofdmb_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node3_ofdmb_vlper[16]           : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node3_ofdmb_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node3_ofdmb_gcd                 : %4d \n", in->node3_ofdmb_gcd);
   printf("node3_gap_gcd                   : %4d \n", in->node3_gap_gcd);
   printf("node3_ofdma_def_tab_num         : %4d \n", in->node3_ofdma_def_tab_num);
   printf("node3_ofdma_tab_node_bitmask[4] : ");
   for (i = 0; i < 4; i++) {
      printf("%04x ", in->node3_ofdma_tab_node_bitmask[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node3_ofdma_tab_num_subchan[4]  : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node3_ofdma_tab_num_subchan[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node3_ofdma_tab_gap[4]          : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node3_ofdma_tab_gap[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node3_ofdma_tab_bps[4]          : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node3_ofdma_tab_bps[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node4_gap_nper[16]              : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node4_gap_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node4_gap_vlper[16]             : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node4_gap_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node4_ofdmb_nper[16]            : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node4_ofdmb_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node4_ofdmb_vlper[16]           : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node4_ofdmb_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node4_ofdmb_gcd                 : %4d \n", in->node4_ofdmb_gcd);
   printf("node4_gap_gcd                   : %4d \n", in->node4_gap_gcd);
   printf("node4_ofdma_def_tab_num         : %4d \n", in->node4_ofdma_def_tab_num);
   printf("node4_ofdma_tab_node_bitmask[4] : ");
   for (i = 0; i < 4; i++) {
      printf("%04x ", in->node4_ofdma_tab_node_bitmask[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node4_ofdma_tab_num_subchan[4]  : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node4_ofdma_tab_num_subchan[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node4_ofdma_tab_gap[4]          : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node4_ofdma_tab_gap[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node4_ofdma_tab_bps[4]          : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node4_ofdma_tab_bps[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node5_gap_nper[16]              : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node5_gap_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node5_gap_vlper[16]             : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node5_gap_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node5_ofdmb_nper[16]            : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node5_ofdmb_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node5_ofdmb_vlper[16]           : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node5_ofdmb_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node5_ofdmb_gcd                 : %4d \n", in->node5_ofdmb_gcd);
   printf("node5_gap_gcd                   : %4d \n", in->node5_gap_gcd);
   printf("node5_ofdma_def_tab_num         : %4d \n", in->node5_ofdma_def_tab_num);
   printf("node5_ofdma_tab_node_bitmask[4] : ");
   for (i = 0; i < 4; i++) {
      printf("%04x ", in->node5_ofdma_tab_node_bitmask[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node5_ofdma_tab_num_subchan[4]  : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node5_ofdma_tab_num_subchan[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node5_ofdma_tab_gap[4]          : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node5_ofdma_tab_gap[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node5_ofdma_tab_bps[4]          : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node5_ofdma_tab_bps[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node6_gap_nper[16]              : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node6_gap_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node6_gap_vlper[16]             : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node6_gap_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node6_ofdmb_nper[16]            : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node6_ofdmb_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node6_ofdmb_vlper[16]           : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node6_ofdmb_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node6_ofdmb_gcd                 : %4d \n", in->node6_ofdmb_gcd);
   printf("node6_gap_gcd                   : %4d \n", in->node6_gap_gcd);
   printf("node6_ofdma_def_tab_num         : %4d \n", in->node6_ofdma_def_tab_num);
   printf("node6_ofdma_tab_node_bitmask[4] : ");
   for (i = 0; i < 4; i++) {
      printf("%04x ", in->node6_ofdma_tab_node_bitmask[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node6_ofdma_tab_num_subchan[4]  : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node6_ofdma_tab_num_subchan[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node6_ofdma_tab_gap[4]          : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node6_ofdma_tab_gap[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node6_ofdma_tab_bps[4]          : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node6_ofdma_tab_bps[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node7_gap_nper[16]              : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node7_gap_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node7_gap_vlper[16]             : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node7_gap_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node7_ofdmb_nper[16]            : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node7_ofdmb_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node7_ofdmb_vlper[16]           : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node7_ofdmb_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node7_ofdmb_gcd                 : %4d \n", in->node7_ofdmb_gcd);
   printf("node7_gap_gcd                   : %4d \n", in->node7_gap_gcd);
   printf("node7_ofdma_def_tab_num         : %4d \n", in->node7_ofdma_def_tab_num);
   printf("node7_ofdma_tab_node_bitmask[4] : ");
   for (i = 0; i < 4; i++) {
      printf("%04x ", in->node7_ofdma_tab_node_bitmask[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node7_ofdma_tab_num_subchan[4]  : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node7_ofdma_tab_num_subchan[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node7_ofdma_tab_gap[4]          : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node7_ofdma_tab_gap[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node7_ofdma_tab_bps[4]          : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node7_ofdma_tab_bps[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node8_gap_nper[16]              : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node8_gap_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node8_gap_vlper[16]             : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node8_gap_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node8_ofdmb_nper[16]            : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node8_ofdmb_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node8_ofdmb_vlper[16]           : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node8_ofdmb_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node8_ofdmb_gcd                 : %4d \n", in->node8_ofdmb_gcd);
   printf("node8_gap_gcd                   : %4d \n", in->node8_gap_gcd);
   printf("node8_ofdma_def_tab_num         : %4d \n", in->node8_ofdma_def_tab_num);
   printf("node8_ofdma_tab_node_bitmask[4] : ");
   for (i = 0; i < 4; i++) {
      printf("%04x ", in->node8_ofdma_tab_node_bitmask[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node8_ofdma_tab_num_subchan[4]  : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node8_ofdma_tab_num_subchan[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node8_ofdma_tab_gap[4]          : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node8_ofdma_tab_gap[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node8_ofdma_tab_bps[4]          : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node8_ofdma_tab_bps[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node9_gap_nper[16]              : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node9_gap_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node9_gap_vlper[16]             : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node9_gap_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node9_ofdmb_nper[16]            : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node9_ofdmb_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node9_ofdmb_vlper[16]           : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node9_ofdmb_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node9_ofdmb_gcd                 : %4d \n", in->node9_ofdmb_gcd);
   printf("node9_gap_gcd                   : %4d \n", in->node9_gap_gcd);
   printf("node9_ofdma_def_tab_num         : %4d \n", in->node9_ofdma_def_tab_num);
   printf("node9_ofdma_tab_node_bitmask[4] : ");
   for (i = 0; i < 4; i++) {
      printf("%04x ", in->node9_ofdma_tab_node_bitmask[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node9_ofdma_tab_num_subchan[4]  : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node9_ofdma_tab_num_subchan[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node9_ofdma_tab_gap[4]          : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node9_ofdma_tab_gap[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node9_ofdma_tab_bps[4]          : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node9_ofdma_tab_bps[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node10_gap_nper[16]             : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node10_gap_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node10_gap_vlper[16]            : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node10_gap_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node10_ofdmb_nper[16]           : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node10_ofdmb_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node10_ofdmb_vlper[16]          : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node10_ofdmb_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node10_ofdmb_gcd                : %4d \n", in->node10_ofdmb_gcd);
   printf("node10_gap_gcd                  : %4d \n", in->node10_gap_gcd);
   printf("node10_ofdma_def_tab_num        : %4d \n", in->node10_ofdma_def_tab_num);
   printf("node10_ofdma_tab_node_bitmask[4]: ");
   for (i = 0; i < 4; i++) {
      printf("%04x ", in->node10_ofdma_tab_node_bitmask[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node10_ofdma_tab_num_subchan[4] : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node10_ofdma_tab_num_subchan[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node10_ofdma_tab_gap[4]         : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node10_ofdma_tab_gap[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node10_ofdma_tab_bps[4]         : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node10_ofdma_tab_bps[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node11_gap_nper[16]             : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node11_gap_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node11_gap_vlper[16]            : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node11_gap_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node11_ofdmb_nper[16]           : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node11_ofdmb_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node11_ofdmb_vlper[16]          : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node11_ofdmb_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node11_ofdmb_gcd                : %4d \n", in->node11_ofdmb_gcd);
   printf("node11_gap_gcd                  : %4d \n", in->node11_gap_gcd);
   printf("node11_ofdma_def_tab_num        : %4d \n", in->node11_ofdma_def_tab_num);
   printf("node11_ofdma_tab_node_bitmask[4]: ");
   for (i = 0; i < 4; i++) {
      printf("%04x ", in->node11_ofdma_tab_node_bitmask[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node11_ofdma_tab_num_subchan[4] : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node11_ofdma_tab_num_subchan[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node11_ofdma_tab_gap[4]         : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node11_ofdma_tab_gap[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node11_ofdma_tab_bps[4]         : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node11_ofdma_tab_bps[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node12_gap_nper[16]             : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node12_gap_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node12_gap_vlper[16]            : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node12_gap_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node12_ofdmb_nper[16]           : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node12_ofdmb_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node12_ofdmb_vlper[16]          : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node12_ofdmb_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node12_ofdmb_gcd                : %4d \n", in->node12_ofdmb_gcd);
   printf("node12_gap_gcd                  : %4d \n", in->node12_gap_gcd);
   printf("node12_ofdma_def_tab_num        : %4d \n", in->node12_ofdma_def_tab_num);
   printf("node12_ofdma_tab_node_bitmask[4]: ");
   for (i = 0; i < 4; i++) {
      printf("%04x ", in->node12_ofdma_tab_node_bitmask[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node12_ofdma_tab_num_subchan[4] : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node12_ofdma_tab_num_subchan[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node12_ofdma_tab_gap[4]         : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node12_ofdma_tab_gap[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node12_ofdma_tab_bps[4]         : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node12_ofdma_tab_bps[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node13_gap_nper[16]             : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node13_gap_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node13_gap_vlper[16]            : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node13_gap_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node13_ofdmb_nper[16]           : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node13_ofdmb_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node13_ofdmb_vlper[16]          : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node13_ofdmb_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node13_ofdmb_gcd                : %4d \n", in->node13_ofdmb_gcd);
   printf("node13_gap_gcd                  : %4d \n", in->node13_gap_gcd);
   printf("node13_ofdma_def_tab_num        : %4d \n", in->node13_ofdma_def_tab_num);
   printf("node13_ofdma_tab_node_bitmask[4]: ");
   for (i = 0; i < 4; i++) {
      printf("%04x ", in->node13_ofdma_tab_node_bitmask[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node13_ofdma_tab_num_subchan[4] : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node13_ofdma_tab_num_subchan[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node13_ofdma_tab_gap[4]         : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node13_ofdma_tab_gap[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node13_ofdma_tab_bps[4]         : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node13_ofdma_tab_bps[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node14_gap_nper[16]             : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node14_gap_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node14_gap_vlper[16]            : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node14_gap_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node14_ofdmb_nper[16]           : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node14_ofdmb_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node14_ofdmb_vlper[16]          : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node14_ofdmb_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node14_ofdmb_gcd                : %4d \n", in->node14_ofdmb_gcd);
   printf("node14_gap_gcd                  : %4d \n", in->node14_gap_gcd);
   printf("node14_ofdma_def_tab_num        : %4d \n", in->node14_ofdma_def_tab_num);
   printf("node14_ofdma_tab_node_bitmask[4]: ");
   for (i = 0; i < 4; i++) {
      printf("%04x ", in->node14_ofdma_tab_node_bitmask[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node14_ofdma_tab_num_subchan[4] : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node14_ofdma_tab_num_subchan[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node14_ofdma_tab_gap[4]         : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node14_ofdma_tab_gap[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node14_ofdma_tab_bps[4]         : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node14_ofdma_tab_bps[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node15_gap_nper[16]             : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node15_gap_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node15_gap_vlper[16]            : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node15_gap_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node15_ofdmb_nper[16]           : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node15_ofdmb_nper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node15_ofdmb_vlper[16]          : ");
   for (i = 0; i < 16; i++) {
      printf("%4d ", in->node15_ofdmb_vlper[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node15_ofdmb_gcd                : %4d \n", in->node15_ofdmb_gcd);
   printf("node15_gap_gcd                  : %4d \n", in->node15_gap_gcd);
   printf("node15_ofdma_def_tab_num        : %4d \n", in->node15_ofdma_def_tab_num);
   printf("node15_ofdma_tab_node_bitmask[4]: ");
   for (i = 0; i < 4; i++) {
      printf("%04x ", in->node15_ofdma_tab_node_bitmask[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node15_ofdma_tab_num_subchan[4] : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node15_ofdma_tab_num_subchan[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node15_ofdma_tab_gap[4]         : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node15_ofdma_tab_gap[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("node15_ofdma_tab_bps[4]         : ");
   for (i = 0; i < 4; i++) {
      printf("%4d ", in->node15_ofdma_tab_bps[i]);
      if (i % 8 == 7) printf("\n                                  ");
   }
   printf("\n");
   printf("== end fmr_20 ");
   printf(" ======================================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_error_stats (struct moca_error_stats * in)
{
   printf("== error_stats ");
   printf(" ======================================= \n");
   printf("rx_uc_crc_error           : %u\n", in->rx_uc_crc_error);
   printf("rx_uc_crc_error_sec_ch    : %u\n", in->rx_uc_crc_error_sec_ch);
   printf("rx_uc_timeout_error       : %u\n", in->rx_uc_timeout_error);
   printf("rx_uc_timeout_error_sec_ch: %u\n", in->rx_uc_timeout_error_sec_ch);
   printf("rx_bc_crc_error           : %u\n", in->rx_bc_crc_error);
   printf("rx_bc_timeout_error       : %u\n", in->rx_bc_timeout_error);
   printf("rx_map_crc_error          : %u\n", in->rx_map_crc_error);
   printf("rx_map_timeout_error      : %u\n", in->rx_map_timeout_error);
   printf("rx_beacon_crc_error       : %u\n", in->rx_beacon_crc_error);
   printf("rx_beacon_timeout_error   : %u\n", in->rx_beacon_timeout_error);
   printf("rx_rr_crc_error           : %u\n", in->rx_rr_crc_error);
   printf("rx_ofdma_rr_crc_error     : %u\n", in->rx_ofdma_rr_crc_error);
   printf("rx_rr_timeout_error       : %u\n", in->rx_rr_timeout_error);
   printf("rx_lc_uc_crc_error        : %u\n", in->rx_lc_uc_crc_error);
   printf("rx_lc_bc_crc_error        : %u\n", in->rx_lc_bc_crc_error);
   printf("rx_lc_uc_timeout_error    : %u\n", in->rx_lc_uc_timeout_error);
   printf("rx_lc_bc_timeout_error    : %u\n", in->rx_lc_bc_timeout_error);
   printf("rx_probe1_error           : %u\n", in->rx_probe1_error);
   printf("rx_probe1_error_sec_ch    : %u\n", in->rx_probe1_error_sec_ch);
   printf("rx_probe2_error           : %u\n", in->rx_probe2_error);
   printf("rx_probe3_error           : %u\n", in->rx_probe3_error);
   printf("rx_probe1_gcd_error       : %u\n", in->rx_probe1_gcd_error);
   printf("rx_plp_crc_error          : %u\n", in->rx_plp_crc_error);
   printf("rx_plp_timeout_error      : %u\n", in->rx_plp_timeout_error);
   printf("rx_acf_crc_error          : %u\n", in->rx_acf_crc_error);
   printf("== end error_stats ");
   printf(" =================================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_hostless_mode (uint32_t * in)
{
   printf("hostless_mode: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_wakeup_node (uint32_t * in)
{
   printf("wakeup_node: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_last_mr_events (struct moca_last_mr_events * in)
{
   printf("== last_mr_events ");
   printf(" ==================================== \n");
   printf("last_cause    : 0x%x  ( %d )\n", in->last_cause, in->last_cause);
   printf("last_seq_num  : %u  ( 0x%x )\n", in->last_seq_num, in->last_seq_num);
   printf("last_mr_result: 0x%x  ( %d )\n", in->last_mr_result, in->last_mr_result);
   printf("== end last_mr_events ");
   printf(" ================================ \n\n");
}

MOCALIB_CLI_HELP static void mocacli_ooo_lmo_threshold__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("OO LMO trigger threshold\n");
   printf("Default:\n");
   printf("5 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_ooo_lmo_threshold_help( void )
{
   printf("Out-of-order lmo trigger threshold\n");

   printf("\nmocap get --ooo_lmo_threshold\n");
}

MOCALIB_CLI_GET static int mocacli_get_ooo_lmo_threshold_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t ooo_lmo_threshold;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_ooo_lmo_threshold_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&ooo_lmo_threshold, 0, sizeof(ooo_lmo_threshold));

      ret = __moca_get_ooo_lmo_threshold(handle, &ooo_lmo_threshold);

      if (ret == 0) {
         mocacli_print_ooo_lmo_threshold(&ooo_lmo_threshold);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_ooo_lmo_threshold_help( void )
{
   printf("Out-of-order lmo trigger threshold\n");

   printf("\nmocap set --ooo_lmo_threshold <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_ooo_lmo_threshold_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t ooo_lmo_threshold;

   if (handle != NULL)
   {
      ret = __moca_get_ooo_lmo_threshold(handle, &ooo_lmo_threshold);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_ooo_lmo_threshold_help();
            mocacli_ooo_lmo_threshold__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &ooo_lmo_threshold);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_ooo_lmo_threshold__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_ooo_lmo_threshold(handle, ooo_lmo_threshold);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_taboo_channels__taboo_fixed_mask_start_help(void)
{
   printf("taboo_fixed_mask_start:\n");
   printf("=======================\n");
   printf("RF channel number of the lowest frequency channel covered by the Taboo Channel Mask field. - This is the 'fixed' taboo, i.e. The node will publish this taboo irrelevant to the LOF value.\n");
   printf("\nValues:\n");
   printf("User enters values, but Host is responsible for range checking. \n");
   printf("Range checking goes as follows: \n");
   printf("The Default value is also the minimum value in the range. The maximum value is the default value plus 24.\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_taboo_channels__taboo_fixed_channel_mask_help(void)
{
   printf("taboo_fixed_channel_mask:\n");
   printf("=========================\n");
   printf("Ability to change 'fixed' Taboo Frequency Mask (GCAP.9)\n");
   printf("The MSB corresponds to the lowest Taboo channel as identified in the TABOO_MASK_START field. Each consecutive bit then corresponds to channels offset by multiples of 25MHz. A bit in the TABOO_CHANNEL_MASK field is set to '1' if the corresponding channel is Taboo.This is the 'fixed' taboo, i.e. The node will publish this taboo irrelevant to the LOF value.\n");
   printf("\nValues:\n");
   printf("According to the MoCA spec, this field is 24 bits only. \n");
   printf("\n");
   printf("Note here:\n");
   printf("Only the 24 lsb are relevant. i.e 0x00HHHHHH where H represents any Hex number.\n");
   printf("Default:\n");
   printf("0x0 \n");
}

MOCALIB_CLI_HELP static void mocacli_taboo_channels__taboo_left_mask_help(void)
{
   printf("taboo_left_mask:\n");
   printf("================\n");
   printf("Left side mask for adjacent channels taboo, relative to the LOF.\n");
   printf("\nValues:\n");
   printf("Only 24 lsb are relevant.\n");
   printf("Default:\n");
   printf("0x00ffffff \n");
}

MOCALIB_CLI_HELP static void mocacli_taboo_channels__taboo_right_mask_help(void)
{
   printf("taboo_right_mask:\n");
   printf("=================\n");
   printf("Right side mask for adjacent channels taboo, relative to the LOF\n");
   printf("\nValues:\n");
   printf("Only 24 msb are relevant.\n");
   printf("Default:\n");
   printf("0xffffff00 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_taboo_channels_help( void )
{
   printf("Set and Get taboo channel configuration. The fixed mask parameters are used to set specific frequencies as taboo regardless of the operating frequency. The left and right mask values are used to set frequencies relative to the operatingfrequency as taboo.\n");

   printf("\nmocap get --taboo_channels\n");
}

MOCALIB_CLI_GET static int mocacli_get_taboo_channels_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_taboo_channels taboo_channels;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_taboo_channels_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&taboo_channels, 0, sizeof(taboo_channels));

      ret = moca_get_taboo_channels(handle, &taboo_channels);

      if (ret == 0) {
         mocacli_print_taboo_channels(&taboo_channels);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_taboo_channels_help( void )
{
   printf("Set and Get taboo channel configuration. The fixed mask parameters are used to set specific frequencies as taboo regardless of the operating frequency. The left and right mask values are used to set frequencies relative to the operatingfrequency as taboo.\n");

   printf("\nmocap set --taboo_channels <options>\n");
   printf("options:\n");
   printf("   taboo_left_mask            <uint32>\n");
   printf("   taboo_fixed_mask_start     <uint32>\n");
   printf("   taboo_fixed_channel_mask   <uint32>\n");
   printf("   taboo_right_mask           <uint32>\n");
}

MOCALIB_CLI_SET static int mocacli_set_taboo_channels_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_taboo_channels taboo_channels;

   if (handle != NULL)
   {
      ret = moca_get_taboo_channels(handle, &taboo_channels);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "taboo_left_mask"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_taboo_channels__taboo_left_mask_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &taboo_channels.taboo_left_mask);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_taboo_channels__taboo_left_mask_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "taboo_fixed_mask_start"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_taboo_channels__taboo_fixed_mask_start_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &taboo_channels.taboo_fixed_mask_start);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_taboo_channels__taboo_fixed_mask_start_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "taboo_fixed_channel_mask"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_taboo_channels__taboo_fixed_channel_mask_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &taboo_channels.taboo_fixed_channel_mask);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_taboo_channels__taboo_fixed_channel_mask_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "taboo_right_mask"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_taboo_channels__taboo_right_mask_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &taboo_channels.taboo_right_mask);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_taboo_channels__taboo_right_mask_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_taboo_channels_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_taboo_channels(handle, &taboo_channels);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_gen_node_status__index_help(void)
{
   printf("index:\n");
   printf("======\n");
   printf("Node ID of the destination node\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("15 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_gen_node_status_help( void )
{
   printf("Nodes Status Parameters \n");
   printf("\n");
   printf("The following table is maintained for each MoCA destination node on the MoCA network.\n");

   printf("\nmocap get --gen_node_status <uint32 index>\n");
}

MOCALIB_CLI_GET static int mocacli_get_gen_node_status_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_gen_node_status gen_node_status;
   int found_index = 0;
   uint32_t index;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_gen_node_status_help();
      mocacli_gen_node_status__index_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_gen_node_status__index_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &index);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_gen_node_status__index_help();
               return(ret);
            }
            found_index = 1;
         }
   }

   if (!found_index)
   {
      printf("Missing index parameter.\n");
      return(0);
   }

   if (handle != NULL)
   {
      memset(&gen_node_status, 0, sizeof(gen_node_status));

      ret = moca_get_gen_node_status(handle, index, &gen_node_status);

      if (ret == 0) {
         mocacli_print_gen_node_status(&gen_node_status);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_gen_node_ext_status__index_help(void)
{
   printf("index:\n");
   printf("======\n");
   printf("Node ID of the destination node\n");
   printf("\nValues:\n");
   printf("The value of this field is not used when profile_typeis set to 'TX Unicast' or 'TX Broadcast'\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("15 \n");
}

MOCALIB_CLI_HELP static void mocacli_gen_node_ext_status__profile_type_help(void)
{
   printf("profile_type:\n");
   printf("=============\n");
   printf("The profile type of which the corresponding table is to be retrieved.\n");
   printf("MoCA 2.0 profiles start with profile_type 6.\n");
   printf("\nValues:\n");
   printf("0 = RX Unicast \n");
   printf("1 = RX Broadcast \n");
   printf("2 = RX Map \n");
   printf("3 = TX Unicast \n");
   printf("4 = TX Broadcast \n");
   printf("5 = TX Map \n");
   printf("6 = RX Unicast VLPER \n");
   printf("7 = RX Unicast NPER \n");
   printf("8 = RX Broadcast VLPER \n");
   printf("9 = RX Broadcast NPER \n");
   printf("10 = RX Map 2.0 \n");
   printf("11 = RX OFDMA \n");
   printf("12 = TX Unicast VLPER \n");
   printf("13 = TX Unicast NPER \n");
   printf("14 = TX Broadcast VLPER \n");
   printf("15 = TX Broadcast NPER \n");
   printf("16 = TX Map 2.0 \n");
   printf("17 = TX OFDMA \n");
   printf("18 = RX Unicast NPER Secondary Channel \n");
   printf("19 = RX Unicast VLPER Secondary Channel \n");
   printf("20 = TX Unicast NPER Secondary Channel \n");
   printf("21 = TX Unicast VLPER Secondary Channel\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("21 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_gen_node_ext_status_help( void )
{
   printf("Nodes Extended Status (PHY Parameters) \n");
   printf("\n");
   printf("The following table is maintained for each MoCA destination node on the MoCA network. This table is also maintained for the various profile types.\n");

   printf("\nmocap get --gen_node_ext_status <options>\n");
   printf("options:\n");
   printf("   index          <uint32>\n");
   printf("   profile_type   <uint32>\n");
}

MOCALIB_CLI_HELP static void mocacli_node_stats__index_help(void)
{
   printf("index:\n");
   printf("======\n");
   printf("Node ID of the destination node\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("15 \n");
}

MOCALIB_CLI_HELP static void mocacli_node_stats__reset_stats_help(void)
{
   printf("reset_stats:\n");
   printf("============\n");
   printf("Reset the statistics following the read.\n");
   printf("\nValues:\n");
   printf("0 = Don't reset the statistics \n");
   printf("1 = Reset the statistics\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_node_stats_help( void )
{
   printf("Nodes Statistics \n");
   printf("\n");
   printf("The following table is maintained for each MoCA destination node on the MoCA network.\n");

   printf("\nmocap get --node_stats <options>\n");
   printf("options:\n");
   printf("   index         <uint32>\n");
   printf("   reset_stats   <uint32>\n");
}

MOCALIB_CLI_GET static int mocacli_get_node_stats_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_node_stats node_stats;
   int found_index = 0;
   struct moca_node_stats_in node_stats_in;

   memset(&node_stats_in, 0, sizeof(node_stats_in));
   node_stats_in.reset_stats = MOCA_NODE_STATS_RESET_STATS_DEF;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_node_stats_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "index"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_node_stats__index_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &node_stats_in.index);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_node_stats__index_help();
               return(ret);
            }
            found_index = 1;
         }
      }
      else if (!strcmp(*pp_parms, "reset_stats"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_node_stats__reset_stats_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &node_stats_in.reset_stats);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_node_stats__reset_stats_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_get_node_stats_help();
         return(0);
      }

   }

   if (!found_index)
   {
      printf("Missing index parameter.\n");
      return(0);
   }

   if (handle != NULL)
   {
      memset(&node_stats, 0, sizeof(node_stats));

      ret = moca_get_node_stats(handle, &node_stats_in, &node_stats);

      if (ret == 0) {
         printf("Node %d  %02X:%02X:%02X:%02X:%02X:%02X\n", node_stats_in.index, MOCA_DISPLAY_MAC(mocacli_node_to_mac(handle, node_stats_in.index)));
         mocacli_print_node_stats(&node_stats);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_node_stats_ext__index_help(void)
{
   printf("index:\n");
   printf("======\n");
   printf("Node ID of the destination node\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("15 \n");
}

MOCALIB_CLI_HELP static void mocacli_node_stats_ext__reset_stats_help(void)
{
   printf("reset_stats:\n");
   printf("============\n");
   printf("Reset the statistics following the read.\n");
   printf("\nValues:\n");
   printf("0 = Don't reset the statistics \n");
   printf("1 = Reset the statistics\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_node_stats_ext_help( void )
{
   printf("Nodes Extended Statistics \n");
   printf("\n");
   printf("The following table is maintained for each MoCA destination node on the MoCA network.\n");

   printf("\nmocap get --node_stats_ext <options>\n");
   printf("options:\n");
   printf("   index         <uint32>\n");
   printf("   reset_stats   <uint32>\n");
}

MOCALIB_CLI_GET static int mocacli_get_node_stats_ext_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_node_stats_ext node_stats_ext;
   int found_index = 0;
   struct moca_node_stats_ext_in node_stats_ext_in;

   memset(&node_stats_ext_in, 0, sizeof(node_stats_ext_in));
   node_stats_ext_in.reset_stats = MOCA_NODE_STATS_EXT_RESET_STATS_DEF;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_node_stats_ext_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "index"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_node_stats_ext__index_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &node_stats_ext_in.index);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_node_stats_ext__index_help();
               return(ret);
            }
            found_index = 1;
         }
      }
      else if (!strcmp(*pp_parms, "reset_stats"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_node_stats_ext__reset_stats_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &node_stats_ext_in.reset_stats);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_node_stats_ext__reset_stats_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_get_node_stats_ext_help();
         return(0);
      }

   }

   if (!found_index)
   {
      printf("Missing index parameter.\n");
      return(0);
   }

   if (handle != NULL)
   {
      memset(&node_stats_ext, 0, sizeof(node_stats_ext));

      ret = moca_get_node_stats_ext(handle, &node_stats_ext_in, &node_stats_ext);

      if (ret == 0) {
         printf("Node %d  %02X:%02X:%02X:%02X:%02X:%02X\n", node_stats_ext_in.index, MOCA_DISPLAY_MAC(mocacli_node_to_mac(handle, node_stats_ext_in.index)));
         mocacli_print_node_stats_ext(&node_stats_ext);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_get_network_status_help( void )
{
   printf("Retrieve status information about the MoCA network.\n");

   printf("\nmocap get --network_status\n");
}

MOCALIB_CLI_GET static int mocacli_get_network_status_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_network_status network_status;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_network_status_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&network_status, 0, sizeof(network_status));

      ret = moca_get_network_status(handle, &network_status);

      if (ret == 0) {
         mocacli_print_network_status(&network_status);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_ooo_lmo__node_id_help(void)
{
   printf("node_id:\n");
   printf("========\n");
   printf("\nValues:\n");
   printf("LMO Node ID\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("15 \n");
}

MOCALIB_CLI_HELP static void mocacli_set_ooo_lmo_help( void )
{
   printf("A Request for an Out-of-Order LMO to any node (GCAP.27)\n");

   printf("\nmocap set --ooo_lmo <uint32 node_id>\n");
}

MOCALIB_CLI_SET static int mocacli_set_ooo_lmo_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t ooo_lmo;

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_ooo_lmo_help();
            mocacli_ooo_lmo__node_id_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &ooo_lmo);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_ooo_lmo__node_id_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_ooo_lmo(handle, ooo_lmo);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_start_ulmo__report_type_help(void)
{
   printf("report_type:\n");
   printf("============\n");
   printf("The unsolicited LMO type (GCD,UC,OFDMA).\n");
   printf("\nValues:\n");
   printf("0 = UC \n");
   printf("1 = OFDMA \n");
   printf("2 = GCD\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("2 \n");
}

MOCALIB_CLI_HELP static void mocacli_start_ulmo__node_id_help(void)
{
   printf("node_id:\n");
   printf("========\n");
   printf("The ID of the node to send the unsolicited LMO to.\n");
   printf("\nValues:\n");
   printf("LMO Node ID\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("0x3F \n");
}

MOCALIB_CLI_HELP static void mocacli_start_ulmo__ofdma_node_mask_help(void)
{
   printf("ofdma_node_mask:\n");
   printf("================\n");
   printf("The bitmask of nodes to send the unsolicited OFDMA LMO to.\n");
   printf("\nValues:\n");
   printf("Bit X represents Node ID X\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("0xFFFF \n");
}

MOCALIB_CLI_HELP static void mocacli_start_ulmo__subcarrier_help(void)
{
   printf("subcarrier[16]:\n");
   printf("===============\n");
   printf("Bitmask of the valid 0 - 511 sub-carriers \n");
   printf("E.g. subcarrier[0] corresponds to SCs 0-31 \n");
   printf("Setting subcarrier[0] to 0x8000000F will enable SCs 0,28-31 \n");
   printf("Setting subcarrier[15] to 0x00000001 will enable SC 511\n");
}

MOCALIB_CLI_HELP static void mocacli_get_start_ulmo_help( void )
{
   printf("A Request for an unsolicited LMO to any node.\n");

   printf("\nmocap get --start_ulmo\n");
}

MOCALIB_CLI_GET static int mocacli_get_start_ulmo_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_start_ulmo start_ulmo;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_start_ulmo_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&start_ulmo, 0, sizeof(start_ulmo));

      ret = moca_get_start_ulmo(handle, &start_ulmo);

      if (ret == 0) {
         mocacli_print_start_ulmo(&start_ulmo);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_start_ulmo_help( void )
{
   printf("A Request for an unsolicited LMO to any node.\n");

   printf("\nmocap set --start_ulmo <options>\n");
   printf("options:\n");
   printf("   ofdma_node_mask   <uint32>\n");
   printf("   node_id           <uint32>\n");
   printf("   subcarrier        <bits (format \"w,x,y-z\")>\n");
   printf("   report_type       <uint32>\n");
}

MOCALIB_CLI_SET static int mocacli_set_start_ulmo_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_start_ulmo start_ulmo;

   if (handle != NULL)
   {
      ret = moca_get_start_ulmo(handle, &start_ulmo);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "ofdma_node_mask"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_start_ulmo__ofdma_node_mask_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &start_ulmo.ofdma_node_mask);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_start_ulmo__ofdma_node_mask_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "node_id"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_start_ulmo__node_id_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &start_ulmo.node_id);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_start_ulmo__node_id_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "subcarrier"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_start_ulmo__subcarrier_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_bits(*pp_parms, (uint32_t *)(&start_ulmo.subcarrier), sizeof(start_ulmo.subcarrier));
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_start_ulmo__subcarrier_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "report_type"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_start_ulmo__report_type_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &start_ulmo.report_type);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_start_ulmo__report_type_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_start_ulmo_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_start_ulmo(handle, &start_ulmo);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_rxd_lmo_request__node_id_help(void)
{
   printf("node_id:\n");
   printf("========\n");
   printf("node ID of the current device\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("15 \n");
}

MOCALIB_CLI_HELP static void mocacli_rxd_lmo_request__probe_id_help(void)
{
   printf("probe_id:\n");
   printf("=========\n");
   printf("Predefined probe configuration\n");
   printf("Minimum:\n");
   printf("1 \n");
   printf("Maximum:\n");
   printf("2 \n");
}

MOCALIB_CLI_HELP static void mocacli_rxd_lmo_request__channel_id_help(void)
{
   printf("channel_id:\n");
   printf("===========\n");
   printf("Primary (0), secondary (1) or both (2) channels\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("2 \n");
}

MOCALIB_CLI_HELP static void mocacli_set_rxd_lmo_request_help( void )
{
   printf("A Request for a Receiver-Determined Probe LMO (GCAP.119)\n");

   printf("\nmocap set --rxd_lmo_request <options>\n");
   printf("options:\n");
   printf("   node_id      <uint32>\n");
   printf("   channel_id   <uint32>\n");
   printf("   probe_id     <uint32>\n");
}

MOCALIB_CLI_SET static int mocacli_set_rxd_lmo_request_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_rxd_lmo_request rxd_lmo_request;

   memset(&rxd_lmo_request, 0, sizeof(rxd_lmo_request));

   rxd_lmo_request.channel_id = MOCA_RXD_LMO_REQUEST_CHANNEL_ID_DEF;

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "node_id"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_rxd_lmo_request__node_id_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &rxd_lmo_request.node_id);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_rxd_lmo_request__node_id_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "channel_id"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_rxd_lmo_request__channel_id_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &rxd_lmo_request.channel_id);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_rxd_lmo_request__channel_id_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "probe_id"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_rxd_lmo_request__probe_id_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &rxd_lmo_request.probe_id);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_rxd_lmo_request__probe_id_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_rxd_lmo_request_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_rxd_lmo_request(handle, &rxd_lmo_request);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_get_ofdma_definition_table_help( void )
{
   printf("Display selected values from OFDMA Subchannel Definition Table (GCAP.130)\n");

   printf("\nmocap get --ofdma_definition_table\n");
}

MOCALIB_CLI_GET static int mocacli_get_ofdma_definition_table_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_ofdma_definition_table ofdma_definition_table;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_ofdma_definition_table_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&ofdma_definition_table, 0, sizeof(ofdma_definition_table));

      ret = moca_get_ofdma_definition_table(handle, &ofdma_definition_table);

      if (ret == 0) {
         mocacli_print_ofdma_definition_table(&ofdma_definition_table);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_get_ofdma_assignment_table_help( void )
{
   printf("Display selected values from OFDMA Subchannel Assignment Table (GCAP.131)\n");

   printf("\nmocap get --ofdma_assignment_table\n");
}

MOCALIB_CLI_GET static int mocacli_get_ofdma_assignment_table_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_ofdma_assignment_table ofdma_assignment_table;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_ofdma_assignment_table_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&ofdma_assignment_table, 0, sizeof(ofdma_assignment_table));

      ret = moca_get_ofdma_assignment_table(handle, &ofdma_assignment_table);

      if (ret == 0) {
         mocacli_print_ofdma_assignment_table(&ofdma_assignment_table);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_get_adm_stats_help( void )
{
   printf("Admission Statistics.\n");

   printf("\nmocap get --adm_stats\n");
}

MOCALIB_CLI_GET static int mocacli_get_adm_stats_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_adm_stats adm_stats;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_adm_stats_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&adm_stats, 0, sizeof(adm_stats));

      ret = moca_get_adm_stats(handle, &adm_stats);

      if (ret == 0) {
         mocacli_print_adm_stats(&adm_stats);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_aca__src_node_help(void)
{
   printf("src_node:\n");
   printf("=========\n");
   printf("The Node ID of the source node for the ACA.\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("15 \n");
}

MOCALIB_CLI_HELP static void mocacli_aca__dest_nodemask_help(void)
{
   printf("dest_nodemask:\n");
   printf("==============\n");
   printf("The bitmask of the destination nodes for the ACA.\n");
   printf("Minimum:\n");
   printf("1 \n");
   printf("Maximum:\n");
   printf("0xFFFF \n");
}

MOCALIB_CLI_HELP static void mocacli_aca__type_help(void)
{
   printf("type:\n");
   printf("=====\n");
   printf("The type of ACA to perform, either EVM or Quiet.\n");
   printf("\nValues:\n");
   printf("1 = Quiet assessment \n");
   printf("2 = EVM assessment\n");
   printf("Default:\n");
   printf("1 \n");
   printf("Minimum:\n");
   printf("1 \n");
   printf("Maximum:\n");
   printf("2 \n");
}

MOCALIB_CLI_HELP static void mocacli_aca__channel_help(void)
{
   printf("channel:\n");
   printf("========\n");
   printf("The channel number to perform the ACA on.\n");
}

MOCALIB_CLI_HELP static void mocacli_aca__num_probes_help(void)
{
   printf("num_probes:\n");
   printf("===========\n");
   printf("The number of probes to be used in the ACA operation.\n");
   printf("Maximum:\n");
   printf("8 \n");
}

MOCALIB_CLI_HELP static void mocacli_do_aca_help( void )
{
   printf("Perform an Alternate Channel Assessment operation.\n");

   printf("\nmocap do --aca <options>\n");
   printf("options:\n");
   printf("   src_node        <uint32>\n");
   printf("   dest_nodemask   <uint32>\n");
   printf("   type            <uint32>\n");
   printf("   channel         <uint32>\n");
   printf("   num_probes      <uint32>\n");
}

MOCALIB_CLI_DO static int mocacli_do_aca_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_aca_out aca;
   int found_src_node = 0;
   int found_dest_nodemask = 0;
   int found_channel = 0;
   int found_num_probes = 0;
   struct moca_aca_in aca_in;

   memset(&aca_in, 0, sizeof(aca_in));
   aca_in.type = MOCA_ACA_TYPE_DEF;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_do_aca_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "src_node"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_aca__src_node_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &aca_in.src_node);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_aca__src_node_help();
               return(ret);
            }
            found_src_node = 1;
         }
      }
      else if (!strcmp(*pp_parms, "dest_nodemask"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_aca__dest_nodemask_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &aca_in.dest_nodemask);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_aca__dest_nodemask_help();
               return(ret);
            }
            found_dest_nodemask = 1;
         }
      }
      else if (!strcmp(*pp_parms, "type"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_aca__type_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &aca_in.type);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_aca__type_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "channel"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_aca__channel_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &aca_in.channel);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_aca__channel_help();
               return(ret);
            }
            found_channel = 1;
         }
      }
      else if (!strcmp(*pp_parms, "num_probes"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_aca__num_probes_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &aca_in.num_probes);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_aca__num_probes_help();
               return(ret);
            }
            found_num_probes = 1;
         }
      }
      else
      {
         mocacli_do_aca_help();
         return(0);
      }

   }

   if (!found_src_node)
   {
      printf("Missing src_node parameter.\n");
      return(0);
   }
   if (!found_dest_nodemask)
   {
      printf("Missing dest_nodemask parameter.\n");
      return(0);
   }
   if (!found_channel)
   {
      printf("Missing channel parameter.\n");
      return(0);
   }
   if (!found_num_probes)
   {
      printf("Missing num_probes parameter.\n");
      return(0);
   }

   if (handle != NULL)
   {
      memset(&aca, 0, sizeof(aca));

      ret = moca_do_aca(handle, &aca_in, &aca);

      if (ret == 0)
         mocacli_print_aca(&aca);
      else
         printf("Error %d\n", ret);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_fmr_init__node_mask_help(void)
{
   printf("node_mask:\n");
   printf("==========\n");
   printf("To include node with ID 'x' in the request, set bit (1 << 'x'). \n");
   printf("\n");
   printf("For example, set node_mask to 0x8D to includenode IDs 0, 2, 3 and 7. \n");
   printf("Setting the value to zero will perform FMR for all active nodes.\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_do_fmr_init_help( void )
{
   printf("A trigger for initiating a full mesh rate operation.The request can be for a specific node or for group of nodes by setting the appropriate bits in the node_mask field.\n");

   printf("\nmocap do --fmr_init <uint32 node_mask>\n");
}

MOCALIB_CLI_DO static int mocacli_do_fmr_init_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_fmr_init_out fmr_init;
   uint32_t node_mask;
   node_mask = MOCA_FMR_INIT_DEF;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_do_fmr_init_help();
      mocacli_fmr_init__node_mask_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_fmr_init__node_mask_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &node_mask);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_fmr_init__node_mask_help();
               return(ret);
            }
         }
   }


   if (handle != NULL)
   {
      memset(&fmr_init, 0, sizeof(fmr_init));

      ret = moca_do_fmr_init(handle, node_mask, &fmr_init);

      if (ret == 0)
         mocacli_print_fmr_init(&fmr_init);
      else
         printf("Error %d\n", ret);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_moca_reset__node_mask_help(void)
{
   printf("node_mask:\n");
   printf("==========\n");
   printf("To include node with ID 'x' in the request, set bit (1 << 'x'). \n");
   printf("\n");
   printf("For example, set node_mask to 0x8D to includenode IDs 0, 2, 3 and 7.\n");
}

MOCALIB_CLI_HELP static void mocacli_moca_reset__reset_timer_help(void)
{
   printf("reset_timer:\n");
   printf("============\n");
   printf("Default:\n");
   printf("1 \n");
   printf("Maximum:\n");
   printf("255 \n");
}

MOCALIB_CLI_HELP static void mocacli_moca_reset__non_def_seq_num_help(void)
{
   printf("non_def_seq_num:\n");
   printf("================\n");
   printf("The non-default sequence number to use in the MR submit message. The default value of 0x10000 indicates that the node will use its internal sequence value for the transaction (see mr_seq_num).\n");
   printf("Default:\n");
   printf("0x10000 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("0x10000 \n");
}

MOCALIB_CLI_HELP static void mocacli_do_moca_reset_help( void )
{
   printf("Order a MoCA Reset operation on the MoCA network.Specify the nodes to be reset using the node_mask field.\n");

   printf("\nmocap do --moca_reset <options>\n");
   printf("options:\n");
   printf("   node_mask         <uint32>\n");
   printf("   reset_timer       <uint32>\n");
   printf("   non_def_seq_num   <uint32>\n");
}

MOCALIB_CLI_DO static int mocacli_do_moca_reset_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_moca_reset_out moca_reset;
   int found_node_mask = 0;
   struct moca_moca_reset_in moca_reset_in;

   memset(&moca_reset_in, 0, sizeof(moca_reset_in));
   moca_reset_in.reset_timer = MOCA_MOCA_RESET_RESET_TIMER_DEF;
   moca_reset_in.non_def_seq_num = MOCA_MOCA_RESET_NON_DEF_SEQ_NUM_DEF;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_do_moca_reset_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "node_mask"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_moca_reset__node_mask_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &moca_reset_in.node_mask);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_moca_reset__node_mask_help();
               return(ret);
            }
            found_node_mask = 1;
         }
      }
      else if (!strcmp(*pp_parms, "reset_timer"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_moca_reset__reset_timer_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &moca_reset_in.reset_timer);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_moca_reset__reset_timer_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "non_def_seq_num"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_moca_reset__non_def_seq_num_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &moca_reset_in.non_def_seq_num);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_moca_reset__non_def_seq_num_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_do_moca_reset_help();
         return(0);
      }

   }

   if (!found_node_mask)
   {
      printf("Missing node_mask parameter.\n");
      return(0);
   }

   if (handle != NULL)
   {
      memset(&moca_reset, 0, sizeof(moca_reset));

      ret = moca_do_moca_reset(handle, &moca_reset_in, &moca_reset);

      if (ret == 0)
         mocacli_print_moca_reset(&moca_reset);
      else
         printf("Error %d\n", ret);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_dd_init__node_mask_help(void)
{
   printf("node_mask:\n");
   printf("==========\n");
   printf("To include node with ID 'x' in the request, set bit (1 << 'x'). \n");
   printf("\n");
   printf("For example, set node_mask to 0x8D to includenode IDs 0, 2, 3 and 7.\n");
   printf("Default:\n");
   printf("0xFFFF \n");
}

MOCALIB_CLI_HELP static void mocacli_do_dd_init_help( void )
{
   printf("A trigger for initiating a Device Discovery operation.The request can be for a specific node or for group of nodes by setting the appropriate bits in the node_mask field. \n");
   printf("This operation is for MoCA 2.0 nodes only.\n");
   printf("The output arrays are indexed by node ID. Nodes that are not included in the DD transaction or that don't respond to the DD transaction will have values of zero.\n");

   printf("\nmocap do --dd_init <uint32 node_mask>\n");
}

MOCALIB_CLI_DO static int mocacli_do_dd_init_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_dd_init_out dd_init;
   uint32_t node_mask;
   node_mask = MOCA_DD_INIT_DEF;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_do_dd_init_help();
      mocacli_dd_init__node_mask_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_dd_init__node_mask_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &node_mask);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_dd_init__node_mask_help();
               return(ret);
            }
         }
   }


   if (handle != NULL)
   {
      memset(&dd_init, 0, sizeof(dd_init));

      ret = moca_do_dd_init(handle, node_mask, &dd_init);

      if (ret == 0)
         mocacli_print_dd_init(&dd_init);
      else
         printf("Error %d\n", ret);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_fmr_20__node_mask_help(void)
{
   printf("node_mask:\n");
   printf("==========\n");
   printf("To include node with ID 'x' in the request, set bit (1 << 'x'). \n");
   printf("\n");
   printf("For example, set node_mask to 0x8D to includenode IDs 0, 2, 3 and 7. \n");
   printf("Setting the value to zero will perform FMR for all active nodes.\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_do_fmr_20_help( void )
{
   printf("A trigger for initiating a MoCA 2.0 full mesh rate operation.The request can be for a specific node or for group of nodes by setting the appropriate bits in the node_mask field.\n");

   printf("\nmocap do --fmr_20 <uint32 node_mask>\n");
}

MOCALIB_CLI_DO static int mocacli_do_fmr_20_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_fmr_20_out fmr_20;
   uint32_t node_mask;
   node_mask = MOCA_FMR_20_DEF;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_do_fmr_20_help();
      mocacli_fmr_20__node_mask_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_fmr_20__node_mask_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &node_mask);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_fmr_20__node_mask_help();
               return(ret);
            }
         }
   }


   if (handle != NULL)
   {
      memset(&fmr_20, 0, sizeof(fmr_20));

      ret = moca_do_fmr_20(handle, node_mask, &fmr_20);

      if (ret == 0)
         mocacli_print_fmr_20(&fmr_20);
      else
         printf("Error %d\n", ret);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_get_error_stats_help( void )
{
   printf("Error Statistics \n");
   printf("\n");
   printf("The following table is a sum of the node_stats_ext counters for each node on the MoCA network.\n");

   printf("\nmocap get --error_stats\n");
}

MOCALIB_CLI_GET static int mocacli_get_error_stats_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_error_stats error_stats;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_error_stats_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&error_stats, 0, sizeof(error_stats));

      ret = moca_get_error_stats(handle, &error_stats);

      if (ret == 0) {
         mocacli_print_error_stats(&error_stats);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_hostless_mode__enable_help(void)
{
   printf("enable:\n");
   printf("=======\n");
   printf("Enable or disable hostless-mode.\n");
   printf("0 - Disable (normal operation)\n");
   printf("1 - Enable\n");
   printf("2 - Enable, but allow traffic to be forwarded to the host\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_do_hostless_mode_help( void )
{
   printf("Put firmware into host-less mode of operation. Firmware will not send any traps to mocad, and mocad will disable the watchdog.\n");

   printf("\nmocap do --hostless_mode <uint32 enable>\n");
}

MOCALIB_CLI_DO static int mocacli_do_hostless_mode_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t hostless_mode;
   uint32_t enable;
   enable = MOCA_HOSTLESS_MODE_DEF;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_do_hostless_mode_help();
      mocacli_hostless_mode__enable_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_hostless_mode__enable_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &enable);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_hostless_mode__enable_help();
               return(ret);
            }
         }
   }


   if (handle != NULL)
   {
      memset(&hostless_mode, 0, sizeof(hostless_mode));

      ret = moca_do_hostless_mode(handle, enable, &hostless_mode);

      if (ret == 0)
         mocacli_print_hostless_mode(&hostless_mode);
      else
         printf("Error %d\n", ret);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_wakeup_node__node_help(void)
{
   printf("node:\n");
   printf("=====\n");
   printf("Node ID to wake-up\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("15 \n");
}

MOCALIB_CLI_HELP static void mocacli_do_wakeup_node_help( void )
{
   printf("Wake up a remote node (request that it change to M0)\n");

   printf("\nmocap do --wakeup_node <uint32 node>\n");
}

MOCALIB_CLI_DO static int mocacli_do_wakeup_node_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t wakeup_node;
   uint32_t node;
   node = MOCA_WAKEUP_NODE_DEF;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_do_wakeup_node_help();
      mocacli_wakeup_node__node_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_wakeup_node__node_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &node);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_wakeup_node__node_help();
               return(ret);
            }
         }
   }


   if (handle != NULL)
   {
      memset(&wakeup_node, 0, sizeof(wakeup_node));

      ret = moca_do_wakeup_node(handle, node, &wakeup_node);

      if (ret == 0)
         mocacli_print_wakeup_node(&wakeup_node);
      else
         printf("Error %d\n", ret);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_get_last_mr_events_help( void )
{
   printf("Reports data related to the most recent MR events.\n");

   printf("\nmocap get --last_mr_events\n");
}

MOCALIB_CLI_GET static int mocacli_get_last_mr_events_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_last_mr_events last_mr_events;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_last_mr_events_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&last_mr_events, 0, sizeof(last_mr_events));

      ret = moca_get_last_mr_events(handle, &last_mr_events);

      if (ret == 0) {
         mocacli_print_last_mr_events(&last_mr_events);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_PRINT void mocacli_print_rf_band (uint32_t * in)
{
   printf("rf_band: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_rf_switch (uint32_t * in)
{
   printf("rf_switch: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_if_access_en (uint32_t * in)
{
   printf("if_access_en: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_led_mode (uint32_t * in)
{
   printf("led_mode: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_gen_stats (struct moca_gen_stats * in)
{
   uint32_t i;

   printf("== gen_stats ");
   printf(" ========================================= \n");
   printf("ecl_tx_total_pkts          : %u\n", in->ecl_tx_total_pkts);
   printf("ecl_tx_ucast_pkts          : %u\n", in->ecl_tx_ucast_pkts);
   printf("ecl_tx_bcast_pkts          : %u\n", in->ecl_tx_bcast_pkts);
   printf("ecl_tx_mcast_pkts          : %u\n", in->ecl_tx_mcast_pkts);
   printf("ecl_tx_ucast_unknown       : %u\n", in->ecl_tx_ucast_unknown);
   printf("ecl_tx_mcast_unknown       : %u\n", in->ecl_tx_mcast_unknown);
   printf("ecl_tx_ucast_drops         : %u\n", in->ecl_tx_ucast_drops);
   printf("ecl_tx_mcast_drops         : %u\n", in->ecl_tx_mcast_drops);
   printf("ecl_tx_total_bytes         : %lld\n", in->ecl_tx_total_bytes);
   printf("ecl_tx_buff_drop_pkts      : %u\n", in->ecl_tx_buff_drop_pkts);
   printf("ecl_tx_error_drop_pkts     : %u\n", in->ecl_tx_error_drop_pkts);
   printf("ecl_rx_total_pkts          : %u\n", in->ecl_rx_total_pkts);
   printf("ecl_rx_ucast_pkts          : %u\n", in->ecl_rx_ucast_pkts);
   printf("ecl_rx_bcast_pkts          : %u\n", in->ecl_rx_bcast_pkts);
   printf("ecl_rx_mcast_pkts          : %u\n", in->ecl_rx_mcast_pkts);
   printf("ecl_rx_ucast_drops         : %u\n", in->ecl_rx_ucast_drops);
   printf("ecl_rx_mcast_filter_pkts   : %u\n", in->ecl_rx_mcast_filter_pkts);
   printf("ecl_rx_total_bytes         : %lld\n", in->ecl_rx_total_bytes);
   printf("ecl_fc_bg                  : %u\n", in->ecl_fc_bg);
   printf("ecl_fc_low                 : %u\n", in->ecl_fc_low);
   printf("ecl_fc_medium              : %u\n", in->ecl_fc_medium);
   printf("ecl_fc_high                : %u\n", in->ecl_fc_high);
   printf("ecl_fc_pqos                : %u\n", in->ecl_fc_pqos);
   printf("ecl_fc_bp_all              : %u\n", in->ecl_fc_bp_all);
   printf("mac_tx_low_drop_pkts       : %u\n", in->mac_tx_low_drop_pkts);
   printf("mac_rx_buff_drop_pkts      : %u\n", in->mac_rx_buff_drop_pkts);
   printf("mac_channel_usable_drop    : %u\n", in->mac_channel_usable_drop);
   printf("mac_remove_node_drop       : %u\n", in->mac_remove_node_drop);
   printf("mac_loopback_pkts          : %u\n", in->mac_loopback_pkts);
   printf("mac_loopback_drop_pkts     : %u\n", in->mac_loopback_drop_pkts);
   printf("aggr_pkt_stats_rx_max      : %u\n", in->aggr_pkt_stats_rx_max);
   printf("aggr_pkt_stats_rx_count    : %u\n", in->aggr_pkt_stats_rx_count);
   printf("aggr_pkt_stats_tx[30]      : ");
   for (i = 0; i < 30; i++) {
      printf("%u ", in->aggr_pkt_stats_tx[i]);
      if (i % 8 == 7) printf("\n                             ");
   }
   printf("\n");
   printf("link_down_count            : %u\n", in->link_down_count);
   printf("link_up_count              : %u\n", in->link_up_count);
   printf("nc_handoff_counter         : %u\n", in->nc_handoff_counter);
   printf("nc_backup_counter          : %u\n", in->nc_backup_counter);
   printf("resync_attempts_to_network : %u\n", in->resync_attempts_to_network);
   printf("tx_beacons                 : %u\n", in->tx_beacons);
   printf("tx_map_packets             : %u\n", in->tx_map_packets);
   printf("tx_rr_packets              : %u\n", in->tx_rr_packets);
   printf("tx_ofdma_rr_packets        : %u\n", in->tx_ofdma_rr_packets);
   printf("tx_control_uc_packets      : %u\n", in->tx_control_uc_packets);
   printf("tx_control_bc_packets      : %u\n", in->tx_control_bc_packets);
   printf("tx_protocol_ie             : %u\n", in->tx_protocol_ie);
   printf("rx_beacons                 : %u\n", in->rx_beacons);
   printf("rx_map_packets             : %u\n", in->rx_map_packets);
   printf("rx_rr_packets              : %u\n", in->rx_rr_packets);
   printf("rx_ofdma_rr_packets        : %u\n", in->rx_ofdma_rr_packets);
   printf("rx_control_uc_packets      : %u\n", in->rx_control_uc_packets);
   printf("rx_control_bc_packets      : %u\n", in->rx_control_bc_packets);
   printf("rx_protocol_ie             : %u\n", in->rx_protocol_ie);
   printf("mac_frag_mpdu_tx           : %u\n", in->mac_frag_mpdu_tx);
   printf("mac_frag_mpdu_rx           : %u\n", in->mac_frag_mpdu_rx);
   printf("mac_pqos_policing_tx       : %u\n", in->mac_pqos_policing_tx);
   printf("mac_pqos_policing_drop     : %u\n", in->mac_pqos_policing_drop);
   printf("nc_became_nc_counter       : %u\n", in->nc_became_nc_counter);
   printf("nc_became_backup_nc_counter: %u\n", in->nc_became_backup_nc_counter);
   printf("rx_buffer_full_counter     : %u\n", in->rx_buffer_full_counter);
   printf("== end gen_stats ");
   printf(" ===================================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_interface_status (struct moca_interface_status * in)
{
   printf("== interface_status ");
   printf(" ================================== \n");
   printf("link_status      : %s (%d)\n", (in->link_status ? "Up" : "Down"), in->link_status);
   printf("rf_channel       : %2d - %d MHz\n", in->rf_channel, in->rf_channel * 25);
   printf("primary_channel  : %2d - %d MHz\n", in->primary_channel, in->primary_channel * 25);
   printf("secondary_channel: %2d - %d MHz\n", in->secondary_channel, in->secondary_channel * 25);
   printf("== end interface_status ");
   printf(" ============================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_if_access_table (struct moca_if_access_table * in)
{
   uint32_t i;

   printf("if_access_table: ");
   for (i = 0; i < 16; i++) {
      printf("%02x:%02x:%02x:%02x:%02x:%02x \n", MOCA_DISPLAY_MAC(in->mac_addr[i]));
      if (i < (16 - 1))
         printf("              ");
   }
   printf("\n");
}

MOCALIB_CLI_HELP static void mocacli_rf_band__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = D-Low, support all MoCA channels in sub-band D-Low \n");
   printf("1 = D-High, support all MoCA channels in sub-band D-High \n");
   printf("2 = ExD, support all MoCA channels in band D\n");
   printf("3 = E, support all MoCA channels in band E \n");
   printf("4 = F, support all MoCA channels in band F \n");
   printf("5 = C4, support single MoCA channel C4 (1000 MHz) \n");
   printf("6 = H, support all MoCA channels in band H \n");
   printf("7 = Generic, support all MoCA channels in single channel mode only \n");
}

MOCALIB_CLI_HELP static void mocacli_get_rf_band_help( void )
{
   printf("Defines one or multiple bands or sub-bands of operation of the Node among all the supported bands and sub-bands.\n");

   printf("\nmocap get --rf_band\n");
}

MOCALIB_CLI_GET static int mocacli_get_rf_band_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t rf_band;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_rf_band_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&rf_band, 0, sizeof(rf_band));

      ret = moca_get_rf_band(handle, &rf_band);

      if (ret == 0) {
         mocacli_print_rf_band(&rf_band);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_rf_band_help( void )
{
   printf("Defines one or multiple bands or sub-bands of operation of the Node among all the supported bands and sub-bands.\n");

   printf("\nmocap set --rf_band <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_rf_band_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t rf_band;

   if (handle != NULL)
   {
      ret = moca_get_rf_band(handle, &rf_band);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_rf_band_help();
            mocacli_rf_band__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &rf_band);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_rf_band__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_rf_band(handle, rf_band);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_rf_switch__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = Disable \n");
   printf("1 = Enable on GPIO 28 and 29\n");
   printf("2 = Enable on GPIO 27 and 28\n");
   printf("3 = Enable on GPIO 28 and 27\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("2 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_rf_switch_help( void )
{
   printf("Configures the firmware to configure an RF switch for changing between RF bands for the MoCA interface.\n");

   printf("\nmocap get --rf_switch\n");
}

MOCALIB_CLI_GET static int mocacli_get_rf_switch_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t rf_switch;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_rf_switch_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&rf_switch, 0, sizeof(rf_switch));

      ret = __moca_get_rf_switch(handle, &rf_switch);

      if (ret == 0) {
         mocacli_print_rf_switch(&rf_switch);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_rf_switch_help( void )
{
   printf("Configures the firmware to configure an RF switch for changing between RF bands for the MoCA interface.\n");

   printf("\nmocap set --rf_switch <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_rf_switch_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t rf_switch;

   if (handle != NULL)
   {
      ret = __moca_get_rf_switch(handle, &rf_switch);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_rf_switch_help();
            mocacli_rf_switch__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &rf_switch);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_rf_switch__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_rf_switch(handle, rf_switch);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_if_access_en__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = Disable \n");
   printf("1 = Enable\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_if_access_en_help( void )
{
   printf("Configures the firmware to use the if_access_table when decidingwhether or not to admit nodes to the network. This setting will only havean effect when the self node is the NC. Nodes currently joined to the network will not be affected, only new nodes attempting to join the networkwill be affected.\n");

   printf("\nmocap get --if_access_en\n");
}

MOCALIB_CLI_GET static int mocacli_get_if_access_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t if_access_en;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_if_access_en_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&if_access_en, 0, sizeof(if_access_en));

      ret = moca_get_if_access_en(handle, &if_access_en);

      if (ret == 0) {
         mocacli_print_if_access_en(&if_access_en);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_if_access_en_help( void )
{
   printf("Configures the firmware to use the if_access_table when decidingwhether or not to admit nodes to the network. This setting will only havean effect when the self node is the NC. Nodes currently joined to the network will not be affected, only new nodes attempting to join the networkwill be affected.\n");

   printf("\nmocap set --if_access_en <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_if_access_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t if_access_en;

   if (handle != NULL)
   {
      ret = moca_get_if_access_en(handle, &if_access_en);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_if_access_en_help();
            mocacli_if_access_en__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &if_access_en);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_if_access_en__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_if_access_en(handle, if_access_en);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_led_mode__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("Mode 0: \n");
   printf("- LED off when link is down \n");
   printf("- LED on when link is up \n");
   printf("- LED blinks when there is traffic \n");
   printf("\n");
   printf("Mode 1: \n");
   printf("- LED off when MoCA is not running \n");
   printf("- LED on when MoCA is running \n");
   printf("- LED slow blinks when there is traffic, except in 6802 standalone mode \n");
   printf("\n");
   printf("Mode 2: \n");
   printf("- LED off when MoCA is not running \n");
   printf("- LED slow blinks when MoCA is performing network search \n");
   printf("- LED on when link is up \n");
   printf("- LED blinks when there is traffic \n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("2 \n1 (STANDALONE)\n");
}

MOCALIB_CLI_HELP static void mocacli_get_led_mode_help( void )
{
   printf("Configure the firmware to control the MoCA LED according to the rules described by the mode value.\n");

   printf("\nmocap get --led_mode\n");
}

MOCALIB_CLI_GET static int mocacli_get_led_mode_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t led_mode;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_led_mode_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&led_mode, 0, sizeof(led_mode));

      ret = moca_get_led_mode(handle, &led_mode);

      if (ret == 0) {
         mocacli_print_led_mode(&led_mode);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_led_mode_help( void )
{
   printf("Configure the firmware to control the MoCA LED according to the rules described by the mode value.\n");

   printf("\nmocap set --led_mode <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_led_mode_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t led_mode;

   if (handle != NULL)
   {
      ret = moca_get_led_mode(handle, &led_mode);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_led_mode_help();
            mocacli_led_mode__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &led_mode);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_led_mode__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_led_mode(handle, led_mode);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_gen_stats__reset_stats_help(void)
{
   printf("reset_stats:\n");
   printf("============\n");
   printf("Reset the statistics following the read.\n");
   printf("\nValues:\n");
   printf("0 = Don't reset the statistics \n");
   printf("1 = Reset the statistics\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_gen_stats_help( void )
{
   printf("Retrieve statistics from the MoCA interface \n");
   printf("ECL_INGR = received at the ECL layer from the Ethernet interface and destined for the MoCA RF interface \n");
   printf("ECL_EGR = received at the ECL layer from the MoCA RF interface and destined for the Ethernet interface \n");
   printf("IN = ingress = into the MoCA coax network (Switch -> MoCA core -> Coax) \n");
   printf("OUT = Egress = out of the MoCA coax network (Coax -> MoCA core -> Switch)\n");

   printf("\nmocap get --gen_stats <uint32 reset_stats>\n");
}

MOCALIB_CLI_GET static int mocacli_get_gen_stats_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_gen_stats gen_stats;
   uint32_t reset_stats = MOCA_GEN_STATS_DEF;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_gen_stats_help();
      mocacli_gen_stats__reset_stats_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_gen_stats__reset_stats_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &reset_stats);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_gen_stats__reset_stats_help();
               return(ret);
            }
         }
   }


   if (handle != NULL)
   {
      memset(&gen_stats, 0, sizeof(gen_stats));

      ret = moca_get_gen_stats(handle, reset_stats, &gen_stats);

      if (ret == 0) {
         mocacli_print_gen_stats(&gen_stats);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_get_interface_status_help( void )
{
   printf("Retrieve general status information about the MoCA interface.\n");

   printf("\nmocap get --interface_status\n");
}

MOCALIB_CLI_GET static int mocacli_get_interface_status_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_interface_status interface_status;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_interface_status_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&interface_status, 0, sizeof(interface_status));

      ret = moca_get_interface_status(handle, &interface_status);

      if (ret == 0) {
         mocacli_print_interface_status(&interface_status);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_if_access_table__mac_addr_help(void)
{
   printf("mac_addr[16]:\n");
   printf("=============\n");
   printf("The MAC addresses of the devices allowed to join the network.\n");
}

MOCALIB_CLI_HELP static void mocacli_get_if_access_table_help( void )
{
   printf("When if_access_en is enabled and this node is the NC, only nodeswith MAC addresses that are listed in this table will be allowed to jointhe network.\n");

   printf("\nmocap get --if_access_table\n");
}

MOCALIB_CLI_GET static int mocacli_get_if_access_table_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_if_access_table if_access_table;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_if_access_table_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&if_access_table, 0, sizeof(if_access_table));

      ret = moca_get_if_access_table(handle, &if_access_table);

      if (ret == 0) {
         mocacli_print_if_access_table(&if_access_table);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_if_access_table_help( void )
{
   printf("When if_access_en is enabled and this node is the NC, only nodeswith MAC addresses that are listed in this table will be allowed to jointhe network.\n");

   printf("\nmocap set --if_access_table <options>\n");
   printf("options:\n");
   printf("   mac_addr   <macaddr value> <index> <end index (optional)>\n");
}

MOCALIB_CLI_SET static int mocacli_set_if_access_table_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_if_access_table if_access_table;

   if (handle != NULL)
   {
      ret = moca_get_if_access_table(handle, &if_access_table);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "mac_addr"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_if_access_table__mac_addr_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_macaddr_array(&pp_parms, &num_parms, &if_access_table.mac_addr[0], 1);
            if (ret != 0)
            {
               mocacli_if_access_table__mac_addr_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_if_access_table_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_if_access_table(handle, &if_access_table);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_reset_stats_help( void )
{

   printf("\nmocap set --reset_stats\n");
}

MOCALIB_CLI_SET static int mocacli_set_reset_stats_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;


   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_set_reset_stats_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   if (handle != NULL)
   {
      ret = moca_set_reset_stats(handle);
   }

   return(ret);
}

MOCALIB_CLI_GET static int mocacli_get_intfc_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   char **tmpPtr = pp_parms; 
   int nump = num_parms; 
   char pstr[1][MAX_STRING_LENGTH]; 
   char *gOptmp[1]; 

   gOptmp[0] = &pstr[0][0]; 


   while (nump > 0)
   {
      if ((nump != 0) && !strcmp(*tmpPtr, "help"))
      {
         printf("The Interface group of parameters provide statistics and status about the MoCA interface of this device.\n");
         printf("IE list for this group: \n"); 
         printf("======================= \n"); 
         printf("rf_band\n"); 
         printf("rf_switch\n"); 
         printf("if_access_en\n"); 
         printf("led_mode\n"); 
         printf("gen_stats\n"); 
         printf("interface_status\n"); 
         printf("if_access_table\n"); 
         return(0); 
      }
      tmpPtr++;
      nump--;
  }

   if (handle != NULL)
   {
      ret = mocacli_get_rf_band_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_rf_switch_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_if_access_en_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_led_mode_handler(handle, pp_parms, num_parms );


       sprintf(gOptmp[0],"%d", 0);
       ret = mocacli_get_gen_stats_handler(handle, gOptmp, 0);


      ret = mocacli_get_interface_status_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_if_access_table_handler(handle, pp_parms, num_parms );

   }
   return(ret);
}

MOCALIB_CLI_PRINT void mocacli_print_m1_tx_power_variation (uint32_t * in)
{
   printf("m1_tx_power_variation: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_nc_listening_interval (uint32_t * in)
{
   printf("nc_listening_interval: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_nc_heartbeat_interval (uint32_t * in)
{
   printf("nc_heartbeat_interval: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_wom_magic_enable (uint32_t * in)
{
   printf("wom_magic_enable: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_pm_restore_on_link_down (uint32_t * in)
{
   printf("pm_restore_on_link_down: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_power_state (uint32_t * in)
{
   printf("power_state: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_node_power_state (struct moca_node_power_state * in)
{
   printf("== node_power_state ");
   printf(" ================================== \n");
   printf("state: %u  ( 0x%x )\n", in->state, in->state);
   printf("pwr  : %u  ( 0x%x )\n", in->pwr, in->pwr);
   printf("== end node_power_state ");
   printf(" ============================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_filter_m2_data_wakeUp (uint32_t * in)
{
   printf("filter_m2_data_wakeUp: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_wom_pattern (struct moca_wom_pattern * in, uint32_t num_entries)
{
   uint32_t i;

   printf("== wom_pattern =======================================================================================================================================================================================================================================================================================================\n");
   printf(" No.  bytes[0]  bytes[1]  bytes[2]  bytes[3]  bytes[4]  bytes[5]  bytes[6]  bytes[7]  bytes[8]  bytes[9]  bytes[10] bytes[11] bytes[12] bytes[13] bytes[14] bytes[15] mask[0]  mask[1]  mask[2]  mask[3]  mask[4]  mask[5]  mask[6]  mask[7]  mask[8]  mask[9]  mask[10] mask[11] mask[12] mask[13] mask[14] mask[15] \n");
   printf("======================================================================================================================================================================================================================================================================================================================\n");
   for (i = 0; i < num_entries; i++)
   {
      printf("%4d: %02x        %02x        %02x        %02x        %02x        %02x        %02x        %02x        %02x        %02x        %02x        %02x        %02x        %02x        %02x        %02x        %02x       %02x       %02x       %02x       %02x       %02x       %02x       %02x       %02x       %02x       %02x       %02x       %02x       %02x       %02x       %02x       \n",
         i, in->bytes[0], in->bytes[1], in->bytes[2], in->bytes[3], in->bytes[4], in->bytes[5], in->bytes[6], in->bytes[7], in->bytes[8], in->bytes[9], in->bytes[10], in->bytes[11], in->bytes[12], in->bytes[13], in->bytes[14], in->bytes[15], in->mask[0], in->mask[1], in->mask[2], in->mask[3], in->mask[4], in->mask[5], in->mask[6], in->mask[7], in->mask[8], in->mask[9], in->mask[10], in->mask[11], in->mask[12], in->mask[13], in->mask[14], in->mask[15]);
      in++;
   }
   printf("== end wom_pattern ===================================================================================================================================================================================================================================================================================================\n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_wom_ip (uint32_t * in, uint32_t num_entries)
{
   uint32_t i;

   printf(" No.  ipaddr                                      \n");
   printf("==================================================\n");
   for (i = 0; i < num_entries; i++)
   {
      printf("%4d:  %d.%d.%d.%d\n",
         i, (*in>>24)&0xFF, (*in>>16)&0xFF, (*in>>8)&0xFF, (*in>>0)&0xFF );
      in++;
   }
}

MOCALIB_CLI_PRINT void mocacli_print_wom_magic_mac (struct moca_wom_magic_mac * in)
{
   printf("== wom_magic_mac ");
   printf(" ===================================== \n");
   printf("val: %02x:%02x:%02x:%02x:%02x:%02x \n", MOCA_DISPLAY_MAC(in->val));
   printf("== end wom_magic_mac ");
   printf(" ================================= \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_standby_power_state (uint32_t * in)
{
   printf("standby_power_state: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_wom_mode (uint32_t * in)
{
   printf("wom_mode: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_ps_cmd (uint32_t * in)
{
   printf("ps_cmd: %s (%d)\n", (*in == 0 ? "ACK" : "NACK"), *in);
}

MOCALIB_CLI_PRINT void mocacli_print_power_state_capabilities (uint32_t * in)
{
   printf("power_state_capabilities: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_last_ps_event_code (int32_t * in)
{
   printf("last_ps_event_code: 0x%x  ( %d )\n", *in, *in);
}

MOCALIB_CLI_HELP static void mocacli_m1_tx_power_variation__state_help(void)
{
   printf("state:\n");
   printf("======\n");
   printf("\nValues:\n");
   printf("0b000 - 0b110 Maximum additional possible variation of TX power of the Node in M1 Power State compared with M0 Power State (in dB)\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("6 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_m1_tx_power_variation_help( void )
{
   printf("Set m1_tx_power_variation\n");

   printf("\nmocap get --m1_tx_power_variation\n");
}

MOCALIB_CLI_GET static int mocacli_get_m1_tx_power_variation_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t m1_tx_power_variation;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_m1_tx_power_variation_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&m1_tx_power_variation, 0, sizeof(m1_tx_power_variation));

      ret = moca_get_m1_tx_power_variation(handle, &m1_tx_power_variation);

      if (ret == 0) {
         mocacli_print_m1_tx_power_variation(&m1_tx_power_variation);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_m1_tx_power_variation_help( void )
{
   printf("Set m1_tx_power_variation\n");

   printf("\nmocap set --m1_tx_power_variation <uint32 state>\n");
}

MOCALIB_CLI_SET static int mocacli_set_m1_tx_power_variation_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t m1_tx_power_variation;

   if (handle != NULL)
   {
      ret = moca_get_m1_tx_power_variation(handle, &m1_tx_power_variation);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_m1_tx_power_variation_help();
            mocacli_m1_tx_power_variation__state_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &m1_tx_power_variation);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_m1_tx_power_variation__state_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_m1_tx_power_variation(handle, m1_tx_power_variation);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_nc_listening_interval__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("10 \n");
   printf("Minimum:\n");
   printf("1 \n");
   printf("Maximum:\n");
   printf("10 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_nc_listening_interval_help( void )
{
   printf("NC listening interval, units of Beacon interval BSI\n");

   printf("\nmocap get --nc_listening_interval\n");
}

MOCALIB_CLI_GET static int mocacli_get_nc_listening_interval_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t nc_listening_interval;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_nc_listening_interval_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&nc_listening_interval, 0, sizeof(nc_listening_interval));

      ret = moca_get_nc_listening_interval(handle, &nc_listening_interval);

      if (ret == 0) {
         mocacli_print_nc_listening_interval(&nc_listening_interval);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_nc_listening_interval_help( void )
{
   printf("NC listening interval, units of Beacon interval BSI\n");

   printf("\nmocap set --nc_listening_interval <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_nc_listening_interval_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t nc_listening_interval;

   if (handle != NULL)
   {
      ret = moca_get_nc_listening_interval(handle, &nc_listening_interval);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_nc_listening_interval_help();
            mocacli_nc_listening_interval__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &nc_listening_interval);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_nc_listening_interval__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_nc_listening_interval(handle, nc_listening_interval);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_nc_heartbeat_interval__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("10 \n");
   printf("Minimum:\n");
   printf("1 \n");
   printf("Maximum:\n");
   printf("255 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_nc_heartbeat_interval_help( void )
{
   printf("NC hearbeat interval, in seconds\n");

   printf("\nmocap get --nc_heartbeat_interval\n");
}

MOCALIB_CLI_GET static int mocacli_get_nc_heartbeat_interval_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t nc_heartbeat_interval;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_nc_heartbeat_interval_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&nc_heartbeat_interval, 0, sizeof(nc_heartbeat_interval));

      ret = moca_get_nc_heartbeat_interval(handle, &nc_heartbeat_interval);

      if (ret == 0) {
         mocacli_print_nc_heartbeat_interval(&nc_heartbeat_interval);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_nc_heartbeat_interval_help( void )
{
   printf("NC hearbeat interval, in seconds\n");

   printf("\nmocap set --nc_heartbeat_interval <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_nc_heartbeat_interval_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t nc_heartbeat_interval;

   if (handle != NULL)
   {
      ret = moca_get_nc_heartbeat_interval(handle, &nc_heartbeat_interval);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_nc_heartbeat_interval_help();
            mocacli_nc_heartbeat_interval__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &nc_heartbeat_interval);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_nc_heartbeat_interval__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_nc_heartbeat_interval(handle, nc_heartbeat_interval);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_wom_magic_enable__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = magic-packet filtering disabled\n");
   printf("1 = magic-packet filtering enabled\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_wom_magic_enable_help( void )
{
   printf("Enables magic-packet filtering for WoM\n");

   printf("\nmocap get --wom_magic_enable\n");
}

MOCALIB_CLI_GET static int mocacli_get_wom_magic_enable_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t wom_magic_enable;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_wom_magic_enable_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&wom_magic_enable, 0, sizeof(wom_magic_enable));

      ret = moca_get_wom_magic_enable(handle, &wom_magic_enable);

      if (ret == 0) {
         mocacli_print_wom_magic_enable(&wom_magic_enable);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_wom_magic_enable_help( void )
{
   printf("Enables magic-packet filtering for WoM\n");

   printf("\nmocap set --wom_magic_enable <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_wom_magic_enable_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t wom_magic_enable;

   if (handle != NULL)
   {
      ret = moca_get_wom_magic_enable(handle, &wom_magic_enable);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_wom_magic_enable_help();
            mocacli_wom_magic_enable__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &wom_magic_enable);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_wom_magic_enable__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_wom_magic_enable(handle, wom_magic_enable);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_pm_restore_on_link_down__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = Restore power mode to previous setting after link-down, link-up\n");
   printf("1 = Reset power mode to M0 on link down\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_pm_restore_on_link_down_help( void )
{
   printf("Resets power mode when link goes down and back up again\n");

   printf("\nmocap get --pm_restore_on_link_down\n");
}

MOCALIB_CLI_GET static int mocacli_get_pm_restore_on_link_down_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t pm_restore_on_link_down;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_pm_restore_on_link_down_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&pm_restore_on_link_down, 0, sizeof(pm_restore_on_link_down));

      ret = moca_get_pm_restore_on_link_down(handle, &pm_restore_on_link_down);

      if (ret == 0) {
         mocacli_print_pm_restore_on_link_down(&pm_restore_on_link_down);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_pm_restore_on_link_down_help( void )
{
   printf("Resets power mode when link goes down and back up again\n");

   printf("\nmocap set --pm_restore_on_link_down <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_pm_restore_on_link_down_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t pm_restore_on_link_down;

   if (handle != NULL)
   {
      ret = moca_get_pm_restore_on_link_down(handle, &pm_restore_on_link_down);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_pm_restore_on_link_down_help();
            mocacli_pm_restore_on_link_down__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &pm_restore_on_link_down);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_pm_restore_on_link_down__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_pm_restore_on_link_down(handle, pm_restore_on_link_down);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_get_power_state_help( void )
{
   printf("For GET operations, reports current power state. \n");
   printf("To SET the power state, use the 'do ps_cmd' operation.\n");
   printf("\n");
   printf("Refer to power_state_capabilities to learn the states that may be transitioned to from the current state.\n");

   printf("\nmocap get --power_state\n");
}

MOCALIB_CLI_GET static int mocacli_get_power_state_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t power_state;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_power_state_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&power_state, 0, sizeof(power_state));

      ret = moca_get_power_state(handle, &power_state);

      if (ret == 0) {
         mocacli_print_power_state(&power_state);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_node_power_state__node_help(void)
{
   printf("node:\n");
   printf("=====\n");
   printf("Node ID to report\n");
}

MOCALIB_CLI_HELP static void mocacli_get_node_power_state_help( void )
{
   printf("Get power state and m1_tx_power_variation (GCAP.124)\n");

   printf("\nmocap get --node_power_state <uint32 node>\n");
}

MOCALIB_CLI_GET static int mocacli_get_node_power_state_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_node_power_state node_power_state;
   int found_node = 0;
   uint32_t node;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_node_power_state_help();
      mocacli_node_power_state__node_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_node_power_state__node_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &node);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_node_power_state__node_help();
               return(ret);
            }
            found_node = 1;
         }
   }

   if (!found_node)
   {
      printf("Missing node parameter.\n");
      return(0);
   }

   if (handle != NULL)
   {
      memset(&node_power_state, 0, sizeof(node_power_state));

      ret = moca_get_node_power_state(handle, node, &node_power_state);

      if (ret == 0) {
         mocacli_print_node_power_state(&node_power_state);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_filter_m2_data_wakeUp__mode_help(void)
{
   printf("mode:\n");
   printf("=====\n");
   printf("\nValues:\n");
   printf("0 = OFF \n");
   printf(" 1 = ON\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_filter_m2_data_wakeUp_help( void )
{
   printf("Force node to wake up\n");

   printf("\nmocap get --filter_m2_data_wakeUp\n");
}

MOCALIB_CLI_GET static int mocacli_get_filter_m2_data_wakeUp_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t filter_m2_data_wakeUp;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_filter_m2_data_wakeUp_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&filter_m2_data_wakeUp, 0, sizeof(filter_m2_data_wakeUp));

      ret = moca_get_filter_m2_data_wakeUp(handle, &filter_m2_data_wakeUp);

      if (ret == 0) {
         mocacli_print_filter_m2_data_wakeUp(&filter_m2_data_wakeUp);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_filter_m2_data_wakeUp_help( void )
{
   printf("Force node to wake up\n");

   printf("\nmocap set --filter_m2_data_wakeUp <uint32 mode>\n");
}

MOCALIB_CLI_SET static int mocacli_set_filter_m2_data_wakeUp_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t filter_m2_data_wakeUp;

   if (handle != NULL)
   {
      ret = moca_get_filter_m2_data_wakeUp(handle, &filter_m2_data_wakeUp);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_filter_m2_data_wakeUp_help();
            mocacli_filter_m2_data_wakeUp__mode_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &filter_m2_data_wakeUp);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_filter_m2_data_wakeUp__mode_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_filter_m2_data_wakeUp(handle, filter_m2_data_wakeUp);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_get_wom_pattern_help( void )
{
   printf("Defines a WoM packet filter. MoCA will trigger a wakeup interruptif it receives a packet matching the filter, and wom_mode is enabled.Up to 5 filters can be configured.\n");

   printf("\nmocap get --wom_pattern\n");
}

MOCALIB_CLI_GET static int mocacli_get_wom_pattern_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_wom_pattern wom_pattern[5];

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_wom_pattern_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&wom_pattern, 0, sizeof(wom_pattern));

      ret = moca_get_wom_pattern(handle, &wom_pattern[0], sizeof(wom_pattern));

      if (ret >= 0) {
         mocacli_print_wom_pattern(&wom_pattern[0], ret);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_wom_pattern__index_help(void)
{
   printf("index:\n");
   printf("======\n");
   printf("Index of filter to modify. 0-4\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("4 \n");
}

MOCALIB_CLI_HELP static void mocacli_wom_pattern__bytes_help(void)
{
   printf("bytes[16]:\n");
   printf("==========\n");
   printf("First 14 bytes of the packet\n");
}

MOCALIB_CLI_HELP static void mocacli_wom_pattern__mask_help(void)
{
   printf("mask[16]:\n");
   printf("=========\n");
   printf("Mask for each byte of the bitmask. Setting a bit to '1' will force the corresponding bit in 'bytes' to be ignored.\n");
   printf("Default:\n");
   printf("0xFF \n");
}

MOCALIB_CLI_HELP static void mocacli_set_wom_pattern_help( void )
{
   printf("Defines a WoL packet filter. MoCA will trigger a wakeup interruptif it receives a packet matching the filter, and wom_mode is enabled.Up to 5 filters can be configured. Set Mask to all 0xFF to invalidatean entry\n");

   printf("\nmocap set --wom_pattern <options>\n");
   printf("options:\n");
   printf("   bytes   <uint8 value> <index> <end index (optional)>\n");
   printf("   mask    <uint8 value> <index> <end index (optional)>\n");
   printf("   index   <uint32>\n");
}

MOCALIB_CLI_SET static int mocacli_set_wom_pattern_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_wom_pattern_set wom_pattern;

   uint32_t i;

   memset(&wom_pattern, 0, sizeof(wom_pattern));

   for (i = 0; i < 16; i++) {
      wom_pattern.mask[i] = MOCA_WOM_PATTERN_MASK_DEF;
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "bytes"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_wom_pattern__bytes_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint8_array(&pp_parms, &num_parms, &wom_pattern.bytes[0], 1);
            if (ret != 0)
            {
               mocacli_wom_pattern__bytes_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "mask"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_wom_pattern__mask_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint8_array(&pp_parms, &num_parms, &wom_pattern.mask[0], 1);
            if (ret != 0)
            {
               mocacli_wom_pattern__mask_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "index"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_wom_pattern__index_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &wom_pattern.index);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_wom_pattern__index_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_wom_pattern_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_wom_pattern(handle, &wom_pattern);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_get_wom_ip_help( void )
{
   printf("Defines a WoL packet filter. MoCA will trigger a wakeup interruptif it receives an ARP packet matching the ipaddress, and wom_mode is enabled.Up to 5 IP addresses can be configured.\n");

   printf("\nmocap get --wom_ip\n");
}

MOCALIB_CLI_GET static int mocacli_get_wom_ip_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t wom_ip[5];

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_wom_ip_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&wom_ip, 0, sizeof(wom_ip));

      ret = moca_get_wom_ip(handle, &wom_ip[0], sizeof(wom_ip));

      if (ret >= 0) {
         mocacli_print_wom_ip(&wom_ip[0], ret);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_wom_ip__index_help(void)
{
   printf("index:\n");
   printf("======\n");
   printf("Index of filter to modify. 0-4\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("4 \n");
}

MOCALIB_CLI_HELP static void mocacli_wom_ip__ipaddr_help(void)
{
   printf("ipaddr:\n");
   printf("=======\n");
   printf("IP address of packet to match\n");
}

MOCALIB_CLI_HELP static void mocacli_set_wom_ip_help( void )
{
   printf("Defines a WoL packet filter. MoCA will trigger a wakeup interruptif it receives an ARP packet matching the ipaddress, and wom_mode is enabled.Up to 5 IP addresses can be configured.\n");

   printf("\nmocap set --wom_ip <options>\n");
   printf("options:\n");
   printf("   ipaddr   <uint32>\n");
   printf("   index    <uint32>\n");
}

MOCALIB_CLI_SET static int mocacli_set_wom_ip_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_wom_ip wom_ip;

   memset(&wom_ip, 0, sizeof(wom_ip));

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "ipaddr"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_wom_ip__ipaddr_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &wom_ip.ipaddr);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_wom_ip__ipaddr_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "index"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_wom_ip__index_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &wom_ip.index);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_wom_ip__index_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_wom_ip_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_wom_ip(handle, &wom_ip);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_wom_magic_mac__val_help(void)
{
   printf("val:\n");
   printf("====\n");
}

MOCALIB_CLI_HELP static void mocacli_get_wom_magic_mac_help( void )
{
   printf("Defines the MAC address to be used in magic-packet filtering.This feature needs to be enabled via wom_magic_enable.MoCA will trigger a wakeup interrupt if it receives a magic-packetwith this MAC address\n");

   printf("\nmocap get --wom_magic_mac\n");
}

MOCALIB_CLI_GET static int mocacli_get_wom_magic_mac_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_wom_magic_mac wom_magic_mac;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_wom_magic_mac_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&wom_magic_mac, 0, sizeof(wom_magic_mac));

      ret = moca_get_wom_magic_mac(handle, &wom_magic_mac);

      if (ret == 0) {
         mocacli_print_wom_magic_mac(&wom_magic_mac);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_wom_magic_mac_help( void )
{
   printf("Defines the MAC address to be used in magic-packet filtering.This feature needs to be enabled via wom_magic_enable.MoCA will trigger a wakeup interrupt if it receives a magic-packetwith this MAC address\n");

   printf("\nmocap set --wom_magic_mac <options>\n");
   printf("options:\n");
   printf("   val   <macaddr, format xx:xx:xx:xx:xx:xx>\n");
}

MOCALIB_CLI_SET static int mocacli_set_wom_magic_mac_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_wom_magic_mac wom_magic_mac;

   if (handle != NULL)
   {
      ret = moca_get_wom_magic_mac(handle, &wom_magic_mac);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "val"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_wom_magic_mac__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_macaddr(*pp_parms, &wom_magic_mac.val);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_wom_magic_mac__val_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_wom_magic_mac_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_wom_magic_mac(handle, &wom_magic_mac);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_standby_power_state__state_help(void)
{
   printf("state:\n");
   printf("======\n");
   printf("A list from the range M0-M3\n");
   printf("\nValues:\n");
   printf("0 = M0, Active\n");
   printf("1 = M1, Idle \n");
   printf("2 = M2, Standby \n");
   printf("3 = M3, Sleep\n");
   printf("Default:\n");
   printf("2 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("3 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_standby_power_state_help( void )
{
   printf("For GET operations, reports current standby power state. \n");
   printf("For SET operations, set the power state of the core during system standby\n");
   printf("\n");
   printf("Refer to power_state_capabilities to learn the supported power states.\n");

   printf("\nmocap get --standby_power_state\n");
}

MOCALIB_CLI_GET static int mocacli_get_standby_power_state_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t standby_power_state;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_standby_power_state_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&standby_power_state, 0, sizeof(standby_power_state));

      ret = moca_get_standby_power_state(handle, &standby_power_state);

      if (ret == 0) {
         mocacli_print_standby_power_state(&standby_power_state);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_standby_power_state_help( void )
{
   printf("For GET operations, reports current standby power state. \n");
   printf("For SET operations, set the power state of the core during system standby\n");
   printf("\n");
   printf("Refer to power_state_capabilities to learn the supported power states.\n");

   printf("\nmocap set --standby_power_state <uint32 state>\n");
}

MOCALIB_CLI_SET static int mocacli_set_standby_power_state_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t standby_power_state;

   if (handle != NULL)
   {
      ret = moca_get_standby_power_state(handle, &standby_power_state);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_standby_power_state_help();
            mocacli_standby_power_state__state_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &standby_power_state);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_standby_power_state__state_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_standby_power_state(handle, standby_power_state);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_wom_mode__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = wom_mode disabled\n");
   printf("1 = wom_mode enabled\n");
   printf("Default:\n");
   printf("0 \n2 (SWITCH)\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("2 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_wom_mode_help( void )
{
   printf("Enables WoM mode via packet filtering in the MoCA core in system suspend. Seewom_ip and wom_pattern to configure the packet filtering\n");

   printf("\nmocap get --wom_mode\n");
}

MOCALIB_CLI_GET static int mocacli_get_wom_mode_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t wom_mode;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_wom_mode_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&wom_mode, 0, sizeof(wom_mode));

      ret = moca_get_wom_mode(handle, &wom_mode);

      if (ret == 0) {
         mocacli_print_wom_mode(&wom_mode);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_wom_mode_help( void )
{
   printf("Enables WoM mode via packet filtering in the MoCA core in system suspend. Seewom_ip and wom_pattern to configure the packet filtering\n");

   printf("\nmocap set --wom_mode <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_wom_mode_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t wom_mode;

   if (handle != NULL)
   {
      ret = moca_get_wom_mode(handle, &wom_mode);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_wom_mode_help();
            mocacli_wom_mode__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &wom_mode);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_wom_mode__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_wom_mode(handle, wom_mode);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_ps_cmd__new_state_help(void)
{
   printf("new_state:\n");
   printf("==========\n");
   printf("A list from the range M0-M3\n");
   printf("\nValues:\n");
   printf("0 = M0, Active\n");
   printf("1 = M1, Idle \n");
   printf("2 = M2, Standby \n");
   printf("3 = M3, Sleep\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("3 \n");
}

MOCALIB_CLI_HELP static void mocacli_do_ps_cmd_help( void )
{
   printf("Execute a power state change command and report the results of the command.\n");

   printf("\nmocap do --ps_cmd <uint32 new_state>\n");
}

MOCALIB_CLI_DO static int mocacli_do_ps_cmd_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t ps_cmd;
   int found_new_state = 0;
   uint32_t new_state;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_do_ps_cmd_help();
      mocacli_ps_cmd__new_state_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_ps_cmd__new_state_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &new_state);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_ps_cmd__new_state_help();
               return(ret);
            }
            found_new_state = 1;
         }
   }

   if (!found_new_state)
   {
      printf("Missing new_state parameter.\n");
      return(0);
   }

   if (handle != NULL)
   {
      memset(&ps_cmd, 0, sizeof(ps_cmd));

      ret = moca_do_ps_cmd(handle, new_state, &ps_cmd);

      if (ret == 0)
         mocacli_print_ps_cmd(&ps_cmd);
      else
         printf("Error %d\n", ret);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_get_power_state_capabilities_help( void )
{

   printf("\nmocap get --power_state_capabilities\n");
}

MOCALIB_CLI_GET static int mocacli_get_power_state_capabilities_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t power_state_capabilities;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_power_state_capabilities_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&power_state_capabilities, 0, sizeof(power_state_capabilities));

      ret = moca_get_power_state_capabilities(handle, &power_state_capabilities);

      if (ret == 0) {
         mocacli_print_power_state_capabilities(&power_state_capabilities);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_get_last_ps_event_code_help( void )
{
   printf("Retrieve the value of the 'event_code' parameter from the last 'power_state_event' event.\n");

   printf("\nmocap get --last_ps_event_code\n");
}

MOCALIB_CLI_GET static int mocacli_get_last_ps_event_code_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   int32_t last_ps_event_code;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_last_ps_event_code_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&last_ps_event_code, 0, sizeof(last_ps_event_code));

      ret = moca_get_last_ps_event_code(handle, &last_ps_event_code);

      if (ret == 0) {
         mocacli_print_last_ps_event_code(&last_ps_event_code);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_GET static int mocacli_get_power_mgmt_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   char **tmpPtr = pp_parms; 
   int nump = num_parms; 

   while (nump > 0)
   {
      if ((nump != 0) && !strcmp(*tmpPtr, "help"))
      {
         printf("The Power Management group of parameters allow the MoCA device to change power states.\n");
         printf("IE list for this group: \n"); 
         printf("======================= \n"); 
         printf("m1_tx_power_variation\n"); 
         printf("nc_listening_interval\n"); 
         printf("nc_heartbeat_interval\n"); 
         printf("wom_magic_enable\n"); 
         printf("pm_restore_on_link_down\n"); 
         printf("power_state\n"); 
         printf("node_power_state\n"); 
         printf("filter_m2_data_wakeUp\n"); 
         printf("wom_pattern\n"); 
         printf("wom_ip\n"); 
         printf("wom_magic_mac\n"); 
         printf("standby_power_state\n"); 
         printf("wom_mode\n"); 
         printf("power_state_capabilities\n"); 
         printf("last_ps_event_code\n"); 
         return(0); 
      }
      tmpPtr++;
      nump--;
  }

   if (handle != NULL)
   {
      ret = mocacli_get_m1_tx_power_variation_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_nc_listening_interval_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_nc_heartbeat_interval_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_wom_magic_enable_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_pm_restore_on_link_down_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_power_state_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_filter_m2_data_wakeUp_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_wom_pattern_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_wom_ip_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_wom_magic_mac_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_standby_power_state_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_wom_mode_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_power_state_capabilities_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_last_ps_event_code_handler(handle, pp_parms, num_parms );

   }
   return(ret);
}

MOCALIB_CLI_PRINT void mocacli_print_privacy_en (uint32_t * in)
{
   printf("privacy_en: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_pmk_exchange_interval (uint32_t * in)
{
   printf("pmk_exchange_interval: %u (%02u:%02u:%02u.%03u)\n", *in, (*in / 3600000), ((*in % 3600000) / 60000), ((*in % 60000)/1000), (*in % 1000));
}

MOCALIB_CLI_PRINT void mocacli_print_tek_exchange_interval (uint32_t * in)
{
   printf("tek_exchange_interval: %u (%02u:%02u:%02u.%03u)\n", *in, (*in / 3600000), ((*in % 3600000) / 60000), ((*in % 60000)/1000), (*in % 1000));
}

MOCALIB_CLI_PRINT void mocacli_print_aes_exchange_interval (uint32_t * in)
{
   printf("aes_exchange_interval: %u (%02u:%02u:%02u.%03u)\n", *in, (*in / 3600000), ((*in % 3600000) / 60000), ((*in % 60000)/1000), (*in % 1000));
}

MOCALIB_CLI_PRINT void mocacli_print_mmk_key (struct moca_mmk_key * in)
{
   printf("== mmk_key ");
   printf(" =========================================== \n");
   printf("mmk_key_hi: %u  ( 0x%x )\n", in->mmk_key_hi, in->mmk_key_hi);
   printf("mmk_key_lo: %u  ( 0x%x )\n", in->mmk_key_lo, in->mmk_key_lo);
   printf("== end mmk_key ");
   printf(" ======================================= \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_pmk_initial_key (struct moca_pmk_initial_key * in)
{
   printf("== pmk_initial_key ");
   printf(" =================================== \n");
   printf("pmk_initial_key_hi: %u  ( 0x%x )\n", in->pmk_initial_key_hi, in->pmk_initial_key_hi);
   printf("pmk_initial_key_lo: %u  ( 0x%x )\n", in->pmk_initial_key_lo, in->pmk_initial_key_lo);
   printf("== end pmk_initial_key ");
   printf(" =============================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_aes_mm_key (struct moca_aes_mm_key * in)
{
   uint32_t i;

   printf("aes_mm_key: ");
   for (i = 0; i < 4; i++) {
      printf("0x%x ", in->val[i]);
      if (i % 8 == 7) printf("\n        ");
   }
   printf("\n");
}

MOCALIB_CLI_PRINT void mocacli_print_aes_pm_key (struct moca_aes_pm_key * in)
{
   uint32_t i;

   printf("aes_pm_key: ");
   for (i = 0; i < 4; i++) {
      printf("0x%x ", in->val[i]);
      if (i % 8 == 7) printf("\n        ");
   }
   printf("\n");
}

MOCALIB_CLI_PRINT void mocacli_print_current_keys (struct moca_current_keys * in)
{
   uint32_t i;

   printf("== current_keys ");
   printf(" ====================================== \n");
   printf("pmk_even_key[2]    : ");
   for (i = 0; i < 2; i++) {
      printf("%08X ", in->pmk_even_key[i]);
      if (i % 8 == 7) printf("\n                     ");
   }
   printf("\n");
   printf("pmk_odd_key[2]     : ");
   for (i = 0; i < 2; i++) {
      printf("%08X ", in->pmk_odd_key[i]);
      if (i % 8 == 7) printf("\n                     ");
   }
   printf("\n");
   printf("tek_even_key[2]    : ");
   for (i = 0; i < 2; i++) {
      printf("%08X ", in->tek_even_key[i]);
      if (i % 8 == 7) printf("\n                     ");
   }
   printf("\n");
   printf("tek_odd_key[2]     : ");
   for (i = 0; i < 2; i++) {
      printf("%08X ", in->tek_odd_key[i]);
      if (i % 8 == 7) printf("\n                     ");
   }
   printf("\n");
   printf("aes_pmk_even_key[4]: ");
   for (i = 0; i < 4; i++) {
      printf("%08X ", in->aes_pmk_even_key[i]);
      if (i % 8 == 7) printf("\n                     ");
   }
   printf("\n");
   printf("aes_pmk_odd_key[4] : ");
   for (i = 0; i < 4; i++) {
      printf("%08X ", in->aes_pmk_odd_key[i]);
      if (i % 8 == 7) printf("\n                     ");
   }
   printf("\n");
   printf("aes_tek_even_key[4]: ");
   for (i = 0; i < 4; i++) {
      printf("%08X ", in->aes_tek_even_key[i]);
      if (i % 8 == 7) printf("\n                     ");
   }
   printf("\n");
   printf("aes_tek_odd_key[4] : ");
   for (i = 0; i < 4; i++) {
      printf("%08X ", in->aes_tek_odd_key[i]);
      if (i % 8 == 7) printf("\n                     ");
   }
   printf("\n");
   printf("== end current_keys ");
   printf(" ================================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_permanent_salt (struct moca_permanent_salt * in)
{
   uint32_t i;

   printf("permanent_salt: ");
   for (i = 0; i < 3; i++) {
      printf("%08X ", in->aes_salt[i]);
      if (i % 8 == 7) printf("\n             ");
   }
   printf("\n");
}

MOCALIB_CLI_PRINT void mocacli_print_aes_pmk_initial_key (struct moca_aes_pmk_initial_key * in)
{
   uint32_t i;

   printf("aes_pmk_initial_key: ");
   for (i = 0; i < 4; i++) {
      printf("0x%x ", in->val[i]);
      if (i % 8 == 7) printf("\n        ");
   }
   printf("\n");
}

MOCALIB_CLI_PRINT void mocacli_print_password (struct moca_password * in)
{
   uint32_t i;

   printf("password: ");
   for (i = 0; i < 32; i++) {
      printf("%c", in->password[i]);
   }
   printf("\n");
}

MOCALIB_CLI_HELP static void mocacli_privacy_en__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = disable\n");
   printf("1 = enable\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_privacy_en_help( void )
{
   printf("Enable the MoCA Link Privacy\n");

   printf("\nmocap get --privacy_en\n");
}

MOCALIB_CLI_GET static int mocacli_get_privacy_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t privacy_en;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_privacy_en_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&privacy_en, 0, sizeof(privacy_en));

      ret = moca_get_privacy_en(handle, &privacy_en);

      if (ret == 0) {
         mocacli_print_privacy_en(&privacy_en);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_privacy_en_help( void )
{
   printf("Enable the MoCA Link Privacy\n");

   printf("\nmocap set --privacy_en <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_privacy_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t privacy_en;

   if (handle != NULL)
   {
      ret = moca_get_privacy_en(handle, &privacy_en);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_privacy_en_help();
            mocacli_privacy_en__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &privacy_en);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_privacy_en__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_privacy_en(handle, privacy_en);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_pmk_exchange_interval__msec_help(void)
{
   printf("msec:\n");
   printf("=====\n");
   printf("\nValues:\n");
   printf("Units of msec \n");
   printf("Default is 11 hours\n");
   printf("Default:\n");
   printf("39600000 \n");
   printf("Minimum:\n");
   printf("20000 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_pmk_exchange_interval_help( void )
{
   printf("PMK interval time. This configuration will take effect only after the next key change.\n");

   printf("\nmocap get --pmk_exchange_interval\n");
}

MOCALIB_CLI_GET static int mocacli_get_pmk_exchange_interval_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t pmk_exchange_interval;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_pmk_exchange_interval_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&pmk_exchange_interval, 0, sizeof(pmk_exchange_interval));

      ret = moca_get_pmk_exchange_interval(handle, &pmk_exchange_interval);

      if (ret == 0) {
         mocacli_print_pmk_exchange_interval(&pmk_exchange_interval);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_pmk_exchange_interval_help( void )
{
   printf("PMK interval time. This configuration will take effect only after the next key change.\n");

   printf("\nmocap set --pmk_exchange_interval <uint32 msec>\n");
}

MOCALIB_CLI_SET static int mocacli_set_pmk_exchange_interval_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t pmk_exchange_interval;

   if (handle != NULL)
   {
      ret = moca_get_pmk_exchange_interval(handle, &pmk_exchange_interval);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_pmk_exchange_interval_help();
            mocacli_pmk_exchange_interval__msec_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &pmk_exchange_interval);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_pmk_exchange_interval__msec_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_pmk_exchange_interval(handle, pmk_exchange_interval);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_tek_exchange_interval__msec_help(void)
{
   printf("msec:\n");
   printf("=====\n");
   printf("\nValues:\n");
   printf("Units of msec \n");
   printf("Default is 9 minutes\n");
   printf("Default:\n");
   printf("540000 \n");
   printf("Minimum:\n");
   printf("20000 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_tek_exchange_interval_help( void )
{
   printf("TEK intervals time. This configuration will take effect only after the next key change.\n");

   printf("\nmocap get --tek_exchange_interval\n");
}

MOCALIB_CLI_GET static int mocacli_get_tek_exchange_interval_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t tek_exchange_interval;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_tek_exchange_interval_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&tek_exchange_interval, 0, sizeof(tek_exchange_interval));

      ret = moca_get_tek_exchange_interval(handle, &tek_exchange_interval);

      if (ret == 0) {
         mocacli_print_tek_exchange_interval(&tek_exchange_interval);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_tek_exchange_interval_help( void )
{
   printf("TEK intervals time. This configuration will take effect only after the next key change.\n");

   printf("\nmocap set --tek_exchange_interval <uint32 msec>\n");
}

MOCALIB_CLI_SET static int mocacli_set_tek_exchange_interval_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t tek_exchange_interval;

   if (handle != NULL)
   {
      ret = moca_get_tek_exchange_interval(handle, &tek_exchange_interval);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_tek_exchange_interval_help();
            mocacli_tek_exchange_interval__msec_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &tek_exchange_interval);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_tek_exchange_interval__msec_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_tek_exchange_interval(handle, tek_exchange_interval);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_aes_exchange_interval__msec_help(void)
{
   printf("msec:\n");
   printf("=====\n");
   printf("\nValues:\n");
   printf("Units of msec \n");
   printf("Default is 7 hours\n");
   printf("Default:\n");
   printf("25200000 \n");
   printf("Minimum:\n");
   printf("20000 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_aes_exchange_interval_help( void )
{
   printf("AES PMK and TEK intervals time. This configuration will take effect only after the next key change.\n");

   printf("\nmocap get --aes_exchange_interval\n");
}

MOCALIB_CLI_GET static int mocacli_get_aes_exchange_interval_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t aes_exchange_interval;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_aes_exchange_interval_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&aes_exchange_interval, 0, sizeof(aes_exchange_interval));

      ret = moca_get_aes_exchange_interval(handle, &aes_exchange_interval);

      if (ret == 0) {
         mocacli_print_aes_exchange_interval(&aes_exchange_interval);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_aes_exchange_interval_help( void )
{
   printf("AES PMK and TEK intervals time. This configuration will take effect only after the next key change.\n");

   printf("\nmocap set --aes_exchange_interval <uint32 msec>\n");
}

MOCALIB_CLI_SET static int mocacli_set_aes_exchange_interval_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t aes_exchange_interval;

   if (handle != NULL)
   {
      ret = moca_get_aes_exchange_interval(handle, &aes_exchange_interval);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_aes_exchange_interval_help();
            mocacli_aes_exchange_interval__msec_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &aes_exchange_interval);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_aes_exchange_interval__msec_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_aes_exchange_interval(handle, aes_exchange_interval);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_get_mmk_key_help( void )
{
   printf("64-bit MAC Management Key, derived from a user input of 17 ASCII character password.\n");
   printf("(derived from GCAP.16)\n");

   printf("\nmocap get --mmk_key\n");
}

MOCALIB_CLI_GET static int mocacli_get_mmk_key_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_mmk_key mmk_key;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_mmk_key_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&mmk_key, 0, sizeof(mmk_key));

      ret = moca_get_mmk_key(handle, &mmk_key);

      if (ret == 0) {
         mocacli_print_mmk_key(&mmk_key);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_get_pmk_initial_key_help( void )
{
   printf("64 bits Privacy Management Key Initial, derived from a user input of 17 ASCII chars password.\n");
   printf("(derived from GCAP.16)\n");

   printf("\nmocap get --pmk_initial_key\n");
}

MOCALIB_CLI_GET static int mocacli_get_pmk_initial_key_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_pmk_initial_key pmk_initial_key;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_pmk_initial_key_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&pmk_initial_key, 0, sizeof(pmk_initial_key));

      ret = moca_get_pmk_initial_key(handle, &pmk_initial_key);

      if (ret == 0) {
         mocacli_print_pmk_initial_key(&pmk_initial_key);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_aes_mm_key__val_help(void)
{
   printf("val[4]:\n");
   printf("=======\n");
   printf("\nValues:\n");
   printf("This is a static 128-bit key to be generated by the Host according to MoCA 2.0 specification rules.\n");
}

MOCALIB_CLI_HELP static void mocacli_get_aes_mm_key_help( void )
{
   printf("AES MAC Management Key\n");

   printf("\nmocap get --aes_mm_key\n");
}

MOCALIB_CLI_GET static int mocacli_get_aes_mm_key_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_aes_mm_key aes_mm_key;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_aes_mm_key_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&aes_mm_key, 0, sizeof(aes_mm_key));

      ret = moca_get_aes_mm_key(handle, &aes_mm_key);

      if (ret == 0) {
         mocacli_print_aes_mm_key(&aes_mm_key);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_aes_mm_key_help( void )
{
   printf("AES MAC Management Key\n");

   printf("\nmocap set --aes_mm_key <options>\n");
   printf("options:\n");
   printf("   val   <uint32 value> <index> <end index (optional)>\n");
}

MOCALIB_CLI_SET static int mocacli_set_aes_mm_key_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_aes_mm_key aes_mm_key;

   if (handle != NULL)
   {
      ret = moca_get_aes_mm_key(handle, &aes_mm_key);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "val"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_aes_mm_key__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32_array(&pp_parms, &num_parms, &aes_mm_key.val[0], 1);
            if (ret != 0)
            {
               mocacli_aes_mm_key__val_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_aes_mm_key_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_aes_mm_key(handle, &aes_mm_key);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_aes_pm_key__val_help(void)
{
   printf("val[4]:\n");
   printf("=======\n");
   printf("\nValues:\n");
   printf("This is a static 128-bit key to be generated by the Host according to MoCA 2.0 specification rules.\n");
}

MOCALIB_CLI_HELP static void mocacli_get_aes_pm_key_help( void )
{
   printf("AES Privacy Management Key\n");

   printf("\nmocap get --aes_pm_key\n");
}

MOCALIB_CLI_GET static int mocacli_get_aes_pm_key_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_aes_pm_key aes_pm_key;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_aes_pm_key_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&aes_pm_key, 0, sizeof(aes_pm_key));

      ret = moca_get_aes_pm_key(handle, &aes_pm_key);

      if (ret == 0) {
         mocacli_print_aes_pm_key(&aes_pm_key);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_aes_pm_key_help( void )
{
   printf("AES Privacy Management Key\n");

   printf("\nmocap set --aes_pm_key <options>\n");
   printf("options:\n");
   printf("   val   <uint32 value> <index> <end index (optional)>\n");
}

MOCALIB_CLI_SET static int mocacli_set_aes_pm_key_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_aes_pm_key aes_pm_key;

   if (handle != NULL)
   {
      ret = moca_get_aes_pm_key(handle, &aes_pm_key);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "val"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_aes_pm_key__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32_array(&pp_parms, &num_parms, &aes_pm_key.val[0], 1);
            if (ret != 0)
            {
               mocacli_aes_pm_key__val_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_aes_pm_key_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_aes_pm_key(handle, &aes_pm_key);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_get_current_keys_help( void )
{
   printf("Retrieve the various current MoCA key values of this device.\n");

   printf("\nmocap get --current_keys\n");
}

MOCALIB_CLI_GET static int mocacli_get_current_keys_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_current_keys current_keys;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_current_keys_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&current_keys, 0, sizeof(current_keys));

      ret = moca_get_current_keys(handle, &current_keys);

      if (ret == 0) {
         mocacli_print_current_keys(&current_keys);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_get_permanent_salt_help( void )
{
   printf("Retrieve the AES permanent salt of this device.\n");

   printf("\nmocap get --permanent_salt\n");
}

MOCALIB_CLI_GET static int mocacli_get_permanent_salt_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_permanent_salt permanent_salt;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_permanent_salt_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&permanent_salt, 0, sizeof(permanent_salt));

      ret = moca_get_permanent_salt(handle, &permanent_salt);

      if (ret == 0) {
         mocacli_print_permanent_salt(&permanent_salt);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_aes_pmk_initial_key__val_help(void)
{
   printf("val[4]:\n");
   printf("=======\n");
}

MOCALIB_CLI_HELP static void mocacli_get_aes_pmk_initial_key_help( void )
{
   printf("128-bit Privacy Management Key Initial.\n");

   printf("\nmocap get --aes_pmk_initial_key\n");
}

MOCALIB_CLI_GET static int mocacli_get_aes_pmk_initial_key_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_aes_pmk_initial_key aes_pmk_initial_key;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_aes_pmk_initial_key_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&aes_pmk_initial_key, 0, sizeof(aes_pmk_initial_key));

      ret = moca_get_aes_pmk_initial_key(handle, &aes_pmk_initial_key);

      if (ret == 0) {
         mocacli_print_aes_pmk_initial_key(&aes_pmk_initial_key);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_aes_pmk_initial_key_help( void )
{
   printf("128-bit Privacy Management Key Initial.\n");

   printf("\nmocap set --aes_pmk_initial_key <options>\n");
   printf("options:\n");
   printf("   val   <uint32 value> <index> <end index (optional)>\n");
}

MOCALIB_CLI_SET static int mocacli_set_aes_pmk_initial_key_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_aes_pmk_initial_key aes_pmk_initial_key;

   if (handle != NULL)
   {
      ret = moca_get_aes_pmk_initial_key(handle, &aes_pmk_initial_key);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "val"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_aes_pmk_initial_key__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32_array(&pp_parms, &num_parms, &aes_pmk_initial_key.val[0], 1);
            if (ret != 0)
            {
               mocacli_aes_pmk_initial_key__val_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_aes_pmk_initial_key_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_aes_pmk_initial_key(handle, &aes_pmk_initial_key);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_password__password_help(void)
{
   printf("password[32]:\n");
   printf("=============\n");
   printf("The network password used to generate privacy keys. This string must be between 12 and 17 characters long with each character being a decimal number (0-9).\n");
   printf("\nValues:\n");
   printf("Defaults: string 99999999988888888\n");
   printf("password[0..8] = 0x39 \n");
   printf("password[9..16] = 0x38 \n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_password_help( void )
{

   printf("\nmocap get --password\n");
}

MOCALIB_CLI_GET static int mocacli_get_password_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_password password;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_password_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&password, 0, sizeof(password));

      ret = moca_get_password(handle, &password);

      if (ret == 0) {
         mocacli_print_password(&password);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_password_help( void )
{

   printf("\nmocap set --password <char_array password>\n");
}

MOCALIB_CLI_SET static int mocacli_set_password_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_password password;

   if (handle != NULL)
   {
      ret = moca_get_password(handle, &password);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_password_help();
            mocacli_password__password_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_char_array(*pp_parms, (password.password), sizeof(password.password));
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_password__password_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_password(handle, &password);
   }

   return(ret);
}

MOCALIB_CLI_GET static int mocacli_get_security_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   char **tmpPtr = pp_parms; 
   int nump = num_parms; 

   while (nump > 0)
   {
      if ((nump != 0) && !strcmp(*tmpPtr, "help"))
      {
         printf("The Security group of parameters.\n");
         printf("IE list for this group: \n"); 
         printf("======================= \n"); 
         printf("privacy_en\n"); 
         printf("pmk_exchange_interval\n"); 
         printf("tek_exchange_interval\n"); 
         printf("aes_exchange_interval\n"); 
         printf("mmk_key\n"); 
         printf("pmk_initial_key\n"); 
         printf("aes_mm_key\n"); 
         printf("aes_pm_key\n"); 
         printf("current_keys\n"); 
         printf("permanent_salt\n"); 
         printf("aes_pmk_initial_key\n"); 
         printf("password\n"); 
         return(0); 
      }
      tmpPtr++;
      nump--;
  }

   if (handle != NULL)
   {
      ret = mocacli_get_privacy_en_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_pmk_exchange_interval_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_tek_exchange_interval_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_aes_exchange_interval_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_mmk_key_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_pmk_initial_key_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_aes_mm_key_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_aes_pm_key_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_current_keys_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_permanent_salt_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_aes_pmk_initial_key_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_password_handler(handle, pp_parms, num_parms );

   }
   return(ret);
}

MOCALIB_CLI_PRINT void mocacli_print_mtm_en (uint32_t * in)
{
   printf("mtm_en: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_const_rx_submode (uint32_t * in)
{
   printf("const_rx_submode: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_cir_prints (uint32_t * in)
{
   printf("cir_prints: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_snr_prints (uint32_t * in)
{
   printf("snr_prints: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_sigma2_prints (uint32_t * in)
{
   printf("sigma2_prints: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_bad_probe_prints (uint32_t * in)
{
   printf("bad_probe_prints: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_const_tx_params (struct moca_const_tx_params * in)
{
   uint32_t i;

   printf("== const_tx_params ");
   printf(" =================================== \n");
   printf("const_tx_submode : %u  ( 0x%x )\n", in->const_tx_submode, in->const_tx_submode);
   printf("const_tx_sc1     : %u  ( 0x%x )\n", in->const_tx_sc1, in->const_tx_sc1);
   printf("const_tx_sc2     : %u  ( 0x%x )\n", in->const_tx_sc2, in->const_tx_sc2);
   printf("const_tx_band[16]: ");
   for (i = 0; i < 16; i++) {
      printf("%08x ", in->const_tx_band[i]);
      if (i % 8 == 7) printf("\n                   ");
   }
   printf("\n");
   printf("== end const_tx_params ");
   printf(" =============================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_led_status (uint32_t * in)
{
   printf("led_status: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_moca_core_trace_enable (uint32_t * in)
{
   printf("moca_core_trace_enable: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_error_to_mask (struct moca_error_to_mask * in)
{
   printf("== error_to_mask ");
   printf(" ===================================== \n");
   printf("error1: 0x%x  ( %d )\n", in->error1, in->error1);
   printf("error2: 0x%x  ( %d )\n", in->error2, in->error2);
   printf("error3: 0x%x  ( %d )\n", in->error3, in->error3);
   printf("== end error_to_mask ");
   printf(" ================================= \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_verbose (uint32_t * in)
{
   printf("verbose: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_dont_start_moca (uint32_t * in)
{
   printf("dont_start_moca: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_mocad_printf (struct moca_mocad_printf_out * in)
{
   uint32_t i;

   printf("mocad_printf: ");
   for (i = 0; i < 240; i++) {
      printf("%d ", in->msg[i]);
      if (i % 8 == 7) printf("\n          ");
   }
   printf("\n");
}

MOCALIB_CLI_HELP static void mocacli_mtm_en__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = Disable \n");
   printf("1 = Enable\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_mtm_en_help( void )
{
   printf("Enable/Disable (manufacturing Test Mode)\n");

   printf("\nmocap get --mtm_en\n");
}

MOCALIB_CLI_GET static int mocacli_get_mtm_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t mtm_en;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_mtm_en_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&mtm_en, 0, sizeof(mtm_en));

      ret = moca_get_mtm_en(handle, &mtm_en);

      if (ret == 0) {
         mocacli_print_mtm_en(&mtm_en);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_mtm_en_help( void )
{
   printf("Enable/Disable (manufacturing Test Mode)\n");

   printf("\nmocap set --mtm_en <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_mtm_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t mtm_en;

   if (handle != NULL)
   {
      ret = moca_get_mtm_en(handle, &mtm_en);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_mtm_en_help();
            mocacli_mtm_en__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &mtm_en);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_mtm_en__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_mtm_en(handle, mtm_en);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_const_rx_submode__submode_help(void)
{
   printf("submode:\n");
   printf("========\n");
   printf("\nValues:\n");
   printf("0 = Non-stop RX \n");
   printf("1 = Periodic beacon RX\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_const_rx_submode_help( void )
{
   printf("Additional mode setting for continuous RX mode.\n");

   printf("\nmocap get --const_rx_submode\n");
}

MOCALIB_CLI_GET static int mocacli_get_const_rx_submode_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t const_rx_submode;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_const_rx_submode_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&const_rx_submode, 0, sizeof(const_rx_submode));

      ret = __moca_get_const_rx_submode(handle, &const_rx_submode);

      if (ret == 0) {
         mocacli_print_const_rx_submode(&const_rx_submode);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_const_rx_submode_help( void )
{
   printf("Additional mode setting for continuous RX mode.\n");

   printf("\nmocap set --const_rx_submode <uint32 submode>\n");
}

MOCALIB_CLI_SET static int mocacli_set_const_rx_submode_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t const_rx_submode;

   if (handle != NULL)
   {
      ret = __moca_get_const_rx_submode(handle, &const_rx_submode);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_const_rx_submode_help();
            mocacli_const_rx_submode__submode_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &const_rx_submode);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_const_rx_submode__submode_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_const_rx_submode(handle, const_rx_submode);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_cir_prints__bool_val_help(void)
{
   printf("bool_val:\n");
   printf("=========\n");
   printf("\nValues:\n");
   printf("0 = Disable \n");
   printf("1 = Enable\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_cir_prints_help( void )
{
   printf("Enabling or disabling the CIR prints. \n");
   printf("To enable these prints moca_core_trace_enable must also be set to 1.\n");

   printf("\nmocap get --cir_prints\n");
}

MOCALIB_CLI_GET static int mocacli_get_cir_prints_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t cir_prints;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_cir_prints_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&cir_prints, 0, sizeof(cir_prints));

      ret = moca_get_cir_prints(handle, &cir_prints);

      if (ret == 0) {
         mocacli_print_cir_prints(&cir_prints);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_cir_prints_help( void )
{
   printf("Enabling or disabling the CIR prints. \n");
   printf("To enable these prints moca_core_trace_enable must also be set to 1.\n");

   printf("\nmocap set --cir_prints <uint32 bool_val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_cir_prints_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t cir_prints;

   if (handle != NULL)
   {
      ret = moca_get_cir_prints(handle, &cir_prints);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_cir_prints_help();
            mocacli_cir_prints__bool_val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &cir_prints);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_cir_prints__bool_val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_cir_prints(handle, cir_prints);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_snr_prints__bool_val_help(void)
{
   printf("bool_val:\n");
   printf("=========\n");
   printf("\nValues:\n");
   printf("0 = Disable \n");
   printf("1 = Enable\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_snr_prints_help( void )
{
   printf("Enabling or disabling the SNR prints. \n");
   printf("To enable these prints moca_core_trace_enable must also be set to 1.\n");

   printf("\nmocap get --snr_prints\n");
}

MOCALIB_CLI_GET static int mocacli_get_snr_prints_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t snr_prints;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_snr_prints_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&snr_prints, 0, sizeof(snr_prints));

      ret = moca_get_snr_prints(handle, &snr_prints);

      if (ret == 0) {
         mocacli_print_snr_prints(&snr_prints);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_snr_prints_help( void )
{
   printf("Enabling or disabling the SNR prints. \n");
   printf("To enable these prints moca_core_trace_enable must also be set to 1.\n");

   printf("\nmocap set --snr_prints <uint32 bool_val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_snr_prints_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t snr_prints;

   if (handle != NULL)
   {
      ret = moca_get_snr_prints(handle, &snr_prints);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_snr_prints_help();
            mocacli_snr_prints__bool_val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &snr_prints);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_snr_prints__bool_val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_snr_prints(handle, snr_prints);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_sigma2_prints__bool_val_help(void)
{
   printf("bool_val:\n");
   printf("=========\n");
   printf("\nValues:\n");
   printf("0 = Disable \n");
   printf("1 = Enable\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_sigma2_prints_help( void )
{
   printf("Enabling or disabling the Sigma II prints of Probe I results. \n");
   printf("To enable these prints moca_core_trace_enable must also be set to 1.\n");

   printf("\nmocap get --sigma2_prints\n");
}

MOCALIB_CLI_GET static int mocacli_get_sigma2_prints_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t sigma2_prints;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_sigma2_prints_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&sigma2_prints, 0, sizeof(sigma2_prints));

      ret = moca_get_sigma2_prints(handle, &sigma2_prints);

      if (ret == 0) {
         mocacli_print_sigma2_prints(&sigma2_prints);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_sigma2_prints_help( void )
{
   printf("Enabling or disabling the Sigma II prints of Probe I results. \n");
   printf("To enable these prints moca_core_trace_enable must also be set to 1.\n");

   printf("\nmocap set --sigma2_prints <uint32 bool_val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_sigma2_prints_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t sigma2_prints;

   if (handle != NULL)
   {
      ret = moca_get_sigma2_prints(handle, &sigma2_prints);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_sigma2_prints_help();
            mocacli_sigma2_prints__bool_val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &sigma2_prints);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_sigma2_prints__bool_val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_sigma2_prints(handle, sigma2_prints);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_bad_probe_prints__bool_val_help(void)
{
   printf("bool_val:\n");
   printf("=========\n");
   printf("\nValues:\n");
   printf("0 = Disable \n");
   printf("1 = Enable\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_bad_probe_prints_help( void )
{
   printf("Print bad Probe results. \n");
   printf("To enable these prints moca_core_trace_enable must also be set to 1.\n");

   printf("\nmocap get --bad_probe_prints\n");
}

MOCALIB_CLI_GET static int mocacli_get_bad_probe_prints_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t bad_probe_prints;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_bad_probe_prints_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&bad_probe_prints, 0, sizeof(bad_probe_prints));

      ret = moca_get_bad_probe_prints(handle, &bad_probe_prints);

      if (ret == 0) {
         mocacli_print_bad_probe_prints(&bad_probe_prints);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_bad_probe_prints_help( void )
{
   printf("Print bad Probe results. \n");
   printf("To enable these prints moca_core_trace_enable must also be set to 1.\n");

   printf("\nmocap set --bad_probe_prints <uint32 bool_val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_bad_probe_prints_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t bad_probe_prints;

   if (handle != NULL)
   {
      ret = moca_get_bad_probe_prints(handle, &bad_probe_prints);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_bad_probe_prints_help();
            mocacli_bad_probe_prints__bool_val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &bad_probe_prints);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_bad_probe_prints__bool_val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_bad_probe_prints(handle, bad_probe_prints);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_const_tx_params__const_tx_submode_help(void)
{
   printf("const_tx_submode:\n");
   printf("=================\n");
   printf("\nValues:\n");
   printf("0 = Single tone \n");
   printf("1 = Normal probe I \n");
   printf("2 = Continuous wave mode \n");
   printf("3 = Band mode\n");
   printf("Default:\n");
   printf("1 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("3 \n");
}

MOCALIB_CLI_HELP static void mocacli_const_tx_params__const_tx_sc1_help(void)
{
   printf("const_tx_sc1:\n");
   printf("=============\n");
   printf("The first SC tone for single tone only\n");
}

MOCALIB_CLI_HELP static void mocacli_const_tx_params__const_tx_sc2_help(void)
{
   printf("const_tx_sc2:\n");
   printf("=============\n");
   printf("The second SC tone for single tone only\n");
}

MOCALIB_CLI_HELP static void mocacli_const_tx_params__const_tx_band_help(void)
{
   printf("const_tx_band[16]:\n");
   printf("==================\n");
   printf("Bitmask of the valid 0 - 511 sub-carriers \n");
   printf("E.g. const_tx_band[0] corresponds to SCs 0-31 \n");
   printf("Setting const_tx_band[0] to 0x8000000F will enable SCs 0,28-31 \n");
   printf("Setting const_tx_band[15] to 0x00000001 will enable SC 511\n");
}

MOCALIB_CLI_HELP static void mocacli_get_const_tx_params_help( void )
{
   printf("Continuous TX mode debug parameters\n");

   printf("\nmocap get --const_tx_params\n");
}

MOCALIB_CLI_GET static int mocacli_get_const_tx_params_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_const_tx_params const_tx_params;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_const_tx_params_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&const_tx_params, 0, sizeof(const_tx_params));

      ret = moca_get_const_tx_params(handle, &const_tx_params);

      if (ret == 0) {
         mocacli_print_const_tx_params(&const_tx_params);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_const_tx_params_help( void )
{
   printf("Continuous TX mode debug parameters\n");

   printf("\nmocap set --const_tx_params <options>\n");
   printf("options:\n");
   printf("   const_tx_sc1       <uint32>\n");
   printf("   const_tx_sc2       <uint32>\n");
   printf("   const_tx_band      <bits (format \"w,x,y-z\")>\n");
   printf("   const_tx_submode   <uint32>\n");
}

MOCALIB_CLI_SET static int mocacli_set_const_tx_params_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_const_tx_params const_tx_params;

   if (handle != NULL)
   {
      ret = moca_get_const_tx_params(handle, &const_tx_params);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "const_tx_sc1"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_const_tx_params__const_tx_sc1_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &const_tx_params.const_tx_sc1);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_const_tx_params__const_tx_sc1_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "const_tx_sc2"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_const_tx_params__const_tx_sc2_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &const_tx_params.const_tx_sc2);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_const_tx_params__const_tx_sc2_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "const_tx_band"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_const_tx_params__const_tx_band_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_bits(*pp_parms, (uint32_t *)(&const_tx_params.const_tx_band), sizeof(const_tx_params.const_tx_band));
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_const_tx_params__const_tx_band_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "const_tx_submode"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_const_tx_params__const_tx_submode_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &const_tx_params.const_tx_submode);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_const_tx_params__const_tx_submode_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_const_tx_params_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_const_tx_params(handle, &const_tx_params);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_gmii_trap_header__dest_mac_help(void)
{
   printf("dest_mac[6]:\n");
   printf("============\n");
   printf("Destination MAC address\n");
}

MOCALIB_CLI_HELP static void mocacli_gmii_trap_header__source_mac_help(void)
{
   printf("source_mac[6]:\n");
   printf("==============\n");
   printf("Source MAC address\n");
}

MOCALIB_CLI_HELP static void mocacli_gmii_trap_header__dscp_ecn_help(void)
{
   printf("dscp_ecn:\n");
   printf("=========\n");
   printf("Differentiated Services Code Point and Explicit Congestion Notification fields\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_gmii_trap_header__id_help(void)
{
   printf("id:\n");
   printf("===\n");
   printf("Identification field.\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_gmii_trap_header__ttl_help(void)
{
   printf("ttl:\n");
   printf("====\n");
   printf("Time to live field.\n");
   printf("Default:\n");
   printf("32 \n");
}

MOCALIB_CLI_HELP static void mocacli_gmii_trap_header__prot_help(void)
{
   printf("prot:\n");
   printf("=====\n");
   printf("Protocol field.\n");
   printf("\nValues:\n");
   printf("This should be set to 17 for UDP\n");
   printf("Default:\n");
   printf("17 \n");
}

MOCALIB_CLI_HELP static void mocacli_gmii_trap_header__ip_checksum_help(void)
{
   printf("ip_checksum:\n");
   printf("============\n");
   printf("IP checksum, to be initialized by the host using an IP length of zero.\n");
}

MOCALIB_CLI_HELP static void mocacli_gmii_trap_header__src_ip_addr_help(void)
{
   printf("src_ip_addr[4]:\n");
   printf("===============\n");
   printf("Source IP address.\n");
}

MOCALIB_CLI_HELP static void mocacli_gmii_trap_header__dst_ip_addr_help(void)
{
   printf("dst_ip_addr[4]:\n");
   printf("===============\n");
   printf("Destination IP address.\n");
}

MOCALIB_CLI_HELP static void mocacli_gmii_trap_header__src_port_help(void)
{
   printf("src_port:\n");
   printf("=========\n");
   printf("Source UDP port.\n");
}

MOCALIB_CLI_HELP static void mocacli_gmii_trap_header__dst_port_help(void)
{
   printf("dst_port:\n");
   printf("=========\n");
   printf("Destination UDP port.\n");
}

MOCALIB_CLI_HELP static void mocacli_set_gmii_trap_header_help( void )
{
   printf("GMII Trap Header.\n");
   printf("\n");
   printf("This structure allows the host to configure the GMII trap buffer Ethernet, IP and UDP headers. When the destination MACaddress is non-zero, the firmware will send certain traps over the GMII interface using the specified header. \n");
   printf("\n");
   printf("The host is responsible for ensuring that the header contains valid fields. The firmware will update the length fieldsand checksum values. \n");
   printf("\n");
   printf("To disable GMII traps, the host should set this structure to all zeroes.\n");

   printf("\nmocap set --gmii_trap_header <options>\n");
   printf("options:\n");
   printf("   ttl           <uint8>\n");
   printf("   src_ip_addr   <uint8 value> <index> <end index (optional)>\n");
   printf("   id            <uint16>\n");
   printf("   dscp_ecn      <uint8>\n");
   printf("   src_port      <uint16>\n");
   printf("   dest_mac      <uint8 value> <index> <end index (optional)>\n");
   printf("   dst_port      <uint16>\n");
   printf("   prot          <uint8>\n");
   printf("   source_mac    <uint8 value> <index> <end index (optional)>\n");
   printf("   ip_checksum   <uint16>\n");
   printf("   dst_ip_addr   <uint8 value> <index> <end index (optional)>\n");
}

MOCALIB_CLI_SET static int mocacli_set_gmii_trap_header_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_gmii_trap_header gmii_trap_header;

   memset(&gmii_trap_header, 0, sizeof(gmii_trap_header));

   gmii_trap_header.dscp_ecn = MOCA_GMII_TRAP_HEADER_DSCP_ECN_DEF;

   gmii_trap_header.id = MOCA_GMII_TRAP_HEADER_ID_DEF;

   gmii_trap_header.ttl = MOCA_GMII_TRAP_HEADER_TTL_DEF;

   gmii_trap_header.prot = MOCA_GMII_TRAP_HEADER_PROT_DEF;

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "ttl"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_gmii_trap_header__ttl_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint8(*pp_parms, &gmii_trap_header.ttl);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_gmii_trap_header__ttl_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "src_ip_addr"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_gmii_trap_header__src_ip_addr_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint8_array(&pp_parms, &num_parms, &gmii_trap_header.src_ip_addr[0], 1);
            if (ret != 0)
            {
               mocacli_gmii_trap_header__src_ip_addr_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "id"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_gmii_trap_header__id_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint16(*pp_parms, &gmii_trap_header.id);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_gmii_trap_header__id_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "dscp_ecn"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_gmii_trap_header__dscp_ecn_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint8(*pp_parms, &gmii_trap_header.dscp_ecn);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_gmii_trap_header__dscp_ecn_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "src_port"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_gmii_trap_header__src_port_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint16(*pp_parms, &gmii_trap_header.src_port);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_gmii_trap_header__src_port_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "dest_mac"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_gmii_trap_header__dest_mac_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint8_array(&pp_parms, &num_parms, &gmii_trap_header.dest_mac[0], 1);
            if (ret != 0)
            {
               mocacli_gmii_trap_header__dest_mac_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "dst_port"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_gmii_trap_header__dst_port_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint16(*pp_parms, &gmii_trap_header.dst_port);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_gmii_trap_header__dst_port_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "prot"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_gmii_trap_header__prot_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint8(*pp_parms, &gmii_trap_header.prot);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_gmii_trap_header__prot_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "source_mac"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_gmii_trap_header__source_mac_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint8_array(&pp_parms, &num_parms, &gmii_trap_header.source_mac[0], 1);
            if (ret != 0)
            {
               mocacli_gmii_trap_header__source_mac_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "ip_checksum"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_gmii_trap_header__ip_checksum_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint16(*pp_parms, &gmii_trap_header.ip_checksum);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_gmii_trap_header__ip_checksum_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "dst_ip_addr"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_gmii_trap_header__dst_ip_addr_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint8_array(&pp_parms, &num_parms, &gmii_trap_header.dst_ip_addr[0], 1);
            if (ret != 0)
            {
               mocacli_gmii_trap_header__dst_ip_addr_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_gmii_trap_header_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_gmii_trap_header(handle, &gmii_trap_header);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_get_led_status_help( void )
{
   printf("Retrieve the current status of the MoCA LED.\n");

   printf("\nmocap get --led_status\n");
}

MOCALIB_CLI_GET static int mocacli_get_led_status_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t led_status;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_led_status_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&led_status, 0, sizeof(led_status));

      ret = moca_get_led_status(handle, &led_status);

      if (ret == 0) {
         mocacli_print_led_status(&led_status);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_moca_core_trace_enable__bool_val_help(void)
{
   printf("bool_val:\n");
   printf("=========\n");
   printf("\nValues:\n");
   printf("0 = Disable \n");
   printf("1 = Enable\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_moca_core_trace_enable_help( void )
{
   printf("Enabling or disabling the MoCA core trace to the host via MMP traps. \n");
   printf("When measuring performance, the trace should be turned off.\n");

   printf("\nmocap get --moca_core_trace_enable\n");
}

MOCALIB_CLI_GET static int mocacli_get_moca_core_trace_enable_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t moca_core_trace_enable;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_moca_core_trace_enable_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&moca_core_trace_enable, 0, sizeof(moca_core_trace_enable));

      ret = moca_get_moca_core_trace_enable(handle, &moca_core_trace_enable);

      if (ret == 0) {
         mocacli_print_moca_core_trace_enable(&moca_core_trace_enable);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_moca_core_trace_enable_help( void )
{
   printf("Enabling or disabling the MoCA core trace to the host via MMP traps. \n");
   printf("When measuring performance, the trace should be turned off.\n");

   printf("\nmocap set --moca_core_trace_enable <uint32 bool_val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_moca_core_trace_enable_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t moca_core_trace_enable;

   if (handle != NULL)
   {
      ret = moca_get_moca_core_trace_enable(handle, &moca_core_trace_enable);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_moca_core_trace_enable_help();
            mocacli_moca_core_trace_enable__bool_val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &moca_core_trace_enable);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_moca_core_trace_enable__bool_val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_moca_core_trace_enable(handle, moca_core_trace_enable);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_error_to_mask__error1_help(void)
{
   printf("error1:\n");
   printf("=======\n");
}

MOCALIB_CLI_HELP static void mocacli_error_to_mask__error2_help(void)
{
   printf("error2:\n");
   printf("=======\n");
}

MOCALIB_CLI_HELP static void mocacli_error_to_mask__error3_help(void)
{
   printf("error3:\n");
   printf("=======\n");
}

MOCALIB_CLI_HELP static void mocacli_get_error_to_mask_help( void )
{

   printf("\nmocap get --error_to_mask\n");
}

MOCALIB_CLI_GET static int mocacli_get_error_to_mask_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_error_to_mask error_to_mask;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_error_to_mask_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&error_to_mask, 0, sizeof(error_to_mask));

      ret = moca_get_error_to_mask(handle, &error_to_mask);

      if (ret == 0) {
         mocacli_print_error_to_mask(&error_to_mask);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_error_to_mask_help( void )
{

   printf("\nmocap set --error_to_mask <options>\n");
   printf("options:\n");
   printf("   error1   <int32>\n");
   printf("   error2   <int32>\n");
   printf("   error3   <int32>\n");
}

MOCALIB_CLI_SET static int mocacli_set_error_to_mask_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_error_to_mask error_to_mask;

   if (handle != NULL)
   {
      ret = moca_get_error_to_mask(handle, &error_to_mask);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "error1"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_error_to_mask__error1_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_int32(*pp_parms, &error_to_mask.error1);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_error_to_mask__error1_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "error2"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_error_to_mask__error2_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_int32(*pp_parms, &error_to_mask.error2);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_error_to_mask__error2_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "error3"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_error_to_mask__error3_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_int32(*pp_parms, &error_to_mask.error3);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_error_to_mask__error3_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_error_to_mask_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_error_to_mask(handle, &error_to_mask);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_verbose__level_help(void)
{
   printf("level:\n");
   printf("======\n");
   printf("\nValues:\n");
   printf("Bit 0 = Debug messages \n");
   printf("Bit 1 = Verbose messages \n");
   printf("Bit 2 = Informational messages \n");
   printf("Bit 3 = Warning messages \n");
   printf("Bit 4 = Error messages \n");
   printf("Bit 5 = Trap messages \n");
   printf("Bit 6 = MMP messages \n");
   printf("Bit 7 = RTT printouts to console \n");
   printf("Bit 8 = MoCA Core Warning messages \n");
   printf("Bit 9 = Power State event messages \n");
   printf("Bit 10= RTT Dump to file \n");
   printf("Bit 11= Direct all mocad output to IE_MOCAD_PRINTF trap\n");
}

MOCALIB_CLI_HELP static void mocacli_get_verbose_help( void )
{
   printf("This parameter controls which prints are displayed by the moca daemon.This is a bit field where each bit enables or disables the printingsof a specific log level. \n");
   printf("By default, Error, Warning and Informational messages are printed.\n");

   printf("\nmocap get --verbose\n");
}

MOCALIB_CLI_GET static int mocacli_get_verbose_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t verbose;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_verbose_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&verbose, 0, sizeof(verbose));

      ret = moca_get_verbose(handle, &verbose);

      if (ret == 0) {
         mocacli_print_verbose(&verbose);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_verbose_help( void )
{
   printf("This parameter controls which prints are displayed by the moca daemon.This is a bit field where each bit enables or disables the printingsof a specific log level. \n");
   printf("By default, Error, Warning and Informational messages are printed.\n");

   printf("\nmocap set --verbose <uint32 level>\n");
}

MOCALIB_CLI_SET static int mocacli_set_verbose_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t verbose;

   if (handle != NULL)
   {
      ret = moca_get_verbose(handle, &verbose);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_verbose_help();
            mocacli_verbose__level_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &verbose);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_verbose__level_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_verbose(handle, verbose);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_dont_start_moca__dont_start_moca_help(void)
{
   printf("dont_start_moca:\n");
   printf("================\n");
   printf("\nValues:\n");
   printf("0 = Start MoCA\n");
   printf("1 = Don't start MoCA\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_dont_start_moca_help( void )
{
   printf("This parameter is used to tell the MoCA Daemon not to boot the MoCA core upon start-up. The MoCA daemon will wait for this field to be set to 0 before startingthe MoCA core after it has been set to 1.\n");

   printf("\nmocap get --dont_start_moca\n");
}

MOCALIB_CLI_GET static int mocacli_get_dont_start_moca_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t dont_start_moca;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_dont_start_moca_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&dont_start_moca, 0, sizeof(dont_start_moca));

      ret = moca_get_dont_start_moca(handle, &dont_start_moca);

      if (ret == 0) {
         mocacli_print_dont_start_moca(&dont_start_moca);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_dont_start_moca_help( void )
{
   printf("This parameter is used to tell the MoCA Daemon not to boot the MoCA core upon start-up. The MoCA daemon will wait for this field to be set to 0 before startingthe MoCA core after it has been set to 1.\n");

   printf("\nmocap set --dont_start_moca <uint32 dont_start_moca>\n");
}

MOCALIB_CLI_SET static int mocacli_set_dont_start_moca_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t dont_start_moca;

   if (handle != NULL)
   {
      ret = moca_get_dont_start_moca(handle, &dont_start_moca);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_dont_start_moca_help();
            mocacli_dont_start_moca__dont_start_moca_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &dont_start_moca);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_dont_start_moca__dont_start_moca_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_dont_start_moca(handle, dont_start_moca);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_no_rtt_help( void )
{
   printf("This parameter is used to disable RTT prints by turning off bit 7 of the verbose field.\n");

   printf("\nmocap set --no_rtt\n");
}

MOCALIB_CLI_SET static int mocacli_set_no_rtt_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;


   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_set_no_rtt_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   if (handle != NULL)
   {
      ret = moca_set_no_rtt(handle);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_do_mocad_printf_help( void )
{
   printf("One trap is sent for every core trace\n");

   printf("\nmocap do --mocad_printf\n");
}

MOCALIB_CLI_DO static int mocacli_do_mocad_printf_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_mocad_printf_out mocad_printf;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_do_mocad_printf_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&mocad_printf, 0, sizeof(mocad_printf));

      ret = moca_do_mocad_printf(handle, &mocad_printf);

      if (ret == 0)
         mocacli_print_mocad_printf(&mocad_printf);
      else
         printf("Error %d\n", ret);
   }

   return(ret);
}

MOCALIB_CLI_GET static int mocacli_get_debug_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   char **tmpPtr = pp_parms; 
   int nump = num_parms; 

   while (nump > 0)
   {
      if ((nump != 0) && !strcmp(*tmpPtr, "help"))
      {
         printf("The Debug group of parameters is used for testing by advanced users only.\n");
         printf("IE list for this group: \n"); 
         printf("======================= \n"); 
         printf("mtm_en\n"); 
         printf("const_rx_submode\n"); 
         printf("cir_prints\n"); 
         printf("snr_prints\n"); 
         printf("sigma2_prints\n"); 
         printf("bad_probe_prints\n"); 
         printf("const_tx_params\n"); 
         printf("led_status\n"); 
         printf("moca_core_trace_enable\n"); 
         printf("error_to_mask\n"); 
         printf("verbose\n"); 
         printf("dont_start_moca\n"); 
         return(0); 
      }
      tmpPtr++;
      nump--;
  }

   if (handle != NULL)
   {
      ret = mocacli_get_mtm_en_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_const_rx_submode_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_cir_prints_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_snr_prints_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_sigma2_prints_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_bad_probe_prints_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_const_tx_params_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_led_status_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_moca_core_trace_enable_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_error_to_mask_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_verbose_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_dont_start_moca_handler(handle, pp_parms, num_parms );

   }
   return(ret);
}

MOCALIB_CLI_PRINT void mocacli_print_lab_mode (uint32_t * in)
{
   printf("lab_mode: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_nc_mode (uint32_t * in)
{
   printf("nc_mode: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_rx_tx_packets_per_qm (uint32_t * in)
{
   printf("rx_tx_packets_per_qm: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_extra_rx_packets_per_qm (uint32_t * in)
{
   printf("extra_rx_packets_per_qm: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_target_phy_rate_20 (uint32_t * in)
{
   printf("target_phy_rate_20: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_target_phy_rate_20_turbo (uint32_t * in)
{
   printf("target_phy_rate_20_turbo: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_turbo_en (uint32_t * in)
{
   printf("turbo_en: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_res1 (uint32_t * in)
{
   printf("res1: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_res2 (uint32_t * in)
{
   printf("res2: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_res3 (uint32_t * in)
{
   printf("res3: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_res4 (uint32_t * in)
{
   printf("res4: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_res5 (uint32_t * in)
{
   printf("res5: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_res6 (uint32_t * in)
{
   printf("res6: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_res7 (uint32_t * in)
{
   printf("res7: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_res8 (uint32_t * in)
{
   printf("res8: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_res9 (uint32_t * in)
{
   printf("res9: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_init1 (uint32_t * in)
{
   printf("init1: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_init2 (uint32_t * in)
{
   printf("init2: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_init3 (uint32_t * in)
{
   printf("init3: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_init4 (uint32_t * in)
{
   printf("init4: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_init5 (uint32_t * in)
{
   printf("init5: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_init6 (uint32_t * in)
{
   printf("init6: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_init7 (uint32_t * in)
{
   printf("init7: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_init8 (uint32_t * in)
{
   printf("init8: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_init9 (uint32_t * in)
{
   printf("init9: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_lab_snr_graph_set (uint32_t * in)
{
   printf("lab_snr_graph_set: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_block_nack_rate (uint32_t * in)
{
   printf("block_nack_rate: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_res10 (uint32_t * in)
{
   printf("res10: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_res11 (uint32_t * in)
{
   printf("res11: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_res12 (uint32_t * in)
{
   printf("res12: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_res13 (uint32_t * in)
{
   printf("res13: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_res14 (uint32_t * in)
{
   printf("res14: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_res15 (uint32_t * in)
{
   printf("res15: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_res16 (uint32_t * in)
{
   printf("res16: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_res17 (uint32_t * in)
{
   printf("res17: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_res18 (uint32_t * in)
{
   printf("res18: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_res19 (uint32_t * in)
{
   printf("res19: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_res20 (uint32_t * in)
{
   printf("res20: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_target_phy_rate_20_turbo_vlper (uint32_t * in)
{
   printf("target_phy_rate_20_turbo_vlper: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_target_phy_rate_20_sec_ch (uint32_t * in)
{
   printf("target_phy_rate_20_sec_ch: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_target_phy_rate_20_turbo_sec_ch (uint32_t * in)
{
   printf("target_phy_rate_20_turbo_sec_ch: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_target_phy_rate_20_turbo_vlper_sec_ch (uint32_t * in)
{
   printf("target_phy_rate_20_turbo_vlper_sec_ch: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_cap_phy_rate_en (uint32_t * in)
{
   printf("cap_phy_rate_en: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_cap_target_phy_rate (uint32_t * in)
{
   printf("cap_target_phy_rate: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_cap_snr_base_margin (uint32_t * in)
{
   printf("cap_snr_base_margin: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_map_capture (uint32_t * in)
{
   printf("map_capture: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_lab_register (uint32_t * in)
{
   printf("lab_register: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_lab_cmd (uint32_t * in)
{
   printf("lab_cmd: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_host_pool (struct moca_host_pool * in)
{
   printf("== host_pool ");
   printf(" ========================================= \n");
   printf("isr_start    : %u  ( 0x%x )\n", in->isr_start, in->isr_start);
   printf("isr_end      : %u  ( 0x%x )\n", in->isr_end, in->isr_end);
   printf("isr_head     : %u  ( 0x%x )\n", in->isr_head, in->isr_head);
   printf("isr_head_msg : %u  ( 0x%x )\n", in->isr_head_msg, in->isr_head_msg);
   printf("isr_head_len : %u  ( 0x%x )\n", in->isr_head_len, in->isr_head_len);
   printf("isr_tail     : %u  ( 0x%x )\n", in->isr_tail, in->isr_tail);
   printf("isr_tail_msg : %u  ( 0x%x )\n", in->isr_tail_msg, in->isr_tail_msg);
   printf("isr_tail_len : %u  ( 0x%x )\n", in->isr_tail_len, in->isr_tail_len);
   printf("task_start   : %u  ( 0x%x )\n", in->task_start, in->task_start);
   printf("task_end     : %u  ( 0x%x )\n", in->task_end, in->task_end);
   printf("task_head    : %u  ( 0x%x )\n", in->task_head, in->task_head);
   printf("task_head_msg: %u  ( 0x%x )\n", in->task_head_msg, in->task_head_msg);
   printf("task_head_len: %u  ( 0x%x )\n", in->task_head_len, in->task_head_len);
   printf("task_tail    : %u  ( 0x%x )\n", in->task_tail, in->task_tail);
   printf("task_tail_msg: %u  ( 0x%x )\n", in->task_tail_msg, in->task_tail_msg);
   printf("task_tail_len: %u  ( 0x%x )\n", in->task_tail_len, in->task_tail_len);
   printf("== end host_pool ");
   printf(" ===================================== \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_tpcap_capture_time (uint32_t * in)
{
   printf("tpcap_capture_time: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_cir_data (struct moca_cir_data * in)
{
   uint32_t i;

   printf("cir_data: ");
   for (i = 0; i < 256; i++) {
      printf("%04d %04d;", (int16_t)(in->data[i] >> 16), (int16_t)(in->data[i] & 0xFFFF));
   }
   printf("\n");
}

MOCALIB_CLI_PRINT void mocacli_print_assert_restart (uint32_t * in)
{
   printf("assert_restart: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_moca_cpu_freq (uint32_t * in)
{
   printf("moca_cpu_freq: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_HELP static void mocacli_lab_mode__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 - normal mode\n");
   printf("1 - lab mode\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_lab_mode_help( void )
{
   printf("Turning on the lab mode will enable SNR , I/Q and CIR graphs in BBS.\n");

   printf("\nmocap get --lab_mode\n");
}

MOCALIB_CLI_GET static int mocacli_get_lab_mode_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t lab_mode;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_lab_mode_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&lab_mode, 0, sizeof(lab_mode));

      ret = moca_get_lab_mode(handle, &lab_mode);

      if (ret == 0) {
         mocacli_print_lab_mode(&lab_mode);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_lab_mode_help( void )
{
   printf("Turning on the lab mode will enable SNR , I/Q and CIR graphs in BBS.\n");

   printf("\nmocap set --lab_mode <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_lab_mode_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t lab_mode;

   if (handle != NULL)
   {
      ret = moca_get_lab_mode(handle, &lab_mode);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_lab_mode_help();
            mocacli_lab_mode__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &lab_mode);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_lab_mode__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_lab_mode(handle, lab_mode);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_nc_mode__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = auto negotiate for NC \n");
   printf("1 = always NC \n");
   printf(" 2 = never NC \n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_nc_mode_help( void )
{
   printf("Setting how the MoCA Core should behave during network admission: \n");
   printf("- Auto negotiate for NC \n");
   printf("- Always be the NC \n");
   printf("- Never be the NC.\n");

   printf("\nmocap get --nc_mode\n");
}

MOCALIB_CLI_GET static int mocacli_get_nc_mode_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t nc_mode;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_nc_mode_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&nc_mode, 0, sizeof(nc_mode));

      ret = moca_get_nc_mode(handle, &nc_mode);

      if (ret == 0) {
         mocacli_print_nc_mode(&nc_mode);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_nc_mode_help( void )
{
   printf("Setting how the MoCA Core should behave during network admission: \n");
   printf("- Auto negotiate for NC \n");
   printf("- Always be the NC \n");
   printf("- Never be the NC.\n");

   printf("\nmocap set --nc_mode <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_nc_mode_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t nc_mode;

   if (handle != NULL)
   {
      ret = moca_get_nc_mode(handle, &nc_mode);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_nc_mode_help();
            mocacli_nc_mode__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &nc_mode);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_nc_mode__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_nc_mode(handle, nc_mode);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_rx_tx_packets_per_qm__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("18 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_rx_tx_packets_per_qm_help( void )
{
   printf("A tuning parameter for the packets per second (PPS) optimizations\n");

   printf("\nmocap get --rx_tx_packets_per_qm\n");
}

MOCALIB_CLI_GET static int mocacli_get_rx_tx_packets_per_qm_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t rx_tx_packets_per_qm;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_rx_tx_packets_per_qm_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&rx_tx_packets_per_qm, 0, sizeof(rx_tx_packets_per_qm));

      ret = moca_get_rx_tx_packets_per_qm(handle, &rx_tx_packets_per_qm);

      if (ret == 0) {
         mocacli_print_rx_tx_packets_per_qm(&rx_tx_packets_per_qm);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_rx_tx_packets_per_qm_help( void )
{
   printf("A tuning parameter for the packets per second (PPS) optimizations\n");

   printf("\nmocap set --rx_tx_packets_per_qm <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_rx_tx_packets_per_qm_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t rx_tx_packets_per_qm;

   if (handle != NULL)
   {
      ret = moca_get_rx_tx_packets_per_qm(handle, &rx_tx_packets_per_qm);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_rx_tx_packets_per_qm_help();
            mocacli_rx_tx_packets_per_qm__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &rx_tx_packets_per_qm);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_rx_tx_packets_per_qm__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_rx_tx_packets_per_qm(handle, rx_tx_packets_per_qm);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_extra_rx_packets_per_qm__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("6 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_extra_rx_packets_per_qm_help( void )
{
   printf("A tuning parameter for the packets per second (PPS) optimizations\n");

   printf("\nmocap get --extra_rx_packets_per_qm\n");
}

MOCALIB_CLI_GET static int mocacli_get_extra_rx_packets_per_qm_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t extra_rx_packets_per_qm;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_extra_rx_packets_per_qm_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&extra_rx_packets_per_qm, 0, sizeof(extra_rx_packets_per_qm));

      ret = moca_get_extra_rx_packets_per_qm(handle, &extra_rx_packets_per_qm);

      if (ret == 0) {
         mocacli_print_extra_rx_packets_per_qm(&extra_rx_packets_per_qm);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_extra_rx_packets_per_qm_help( void )
{
   printf("A tuning parameter for the packets per second (PPS) optimizations\n");

   printf("\nmocap set --extra_rx_packets_per_qm <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_extra_rx_packets_per_qm_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t extra_rx_packets_per_qm;

   if (handle != NULL)
   {
      ret = moca_get_extra_rx_packets_per_qm(handle, &extra_rx_packets_per_qm);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_extra_rx_packets_per_qm_help();
            mocacli_extra_rx_packets_per_qm__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &extra_rx_packets_per_qm);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_extra_rx_packets_per_qm__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_extra_rx_packets_per_qm(handle, extra_rx_packets_per_qm);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_target_phy_rate_20__mbps_help(void)
{
   printf("mbps:\n");
   printf("=====\n");
   printf("\nValues:\n");
   printf("Units of Mbps\n");
   printf("Default:\n");
   printf("630 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_target_phy_rate_20_help( void )
{
   printf("Phy rate in MoCA 2.0 mode\n");

   printf("\nmocap get --target_phy_rate_20\n");
}

MOCALIB_CLI_GET static int mocacli_get_target_phy_rate_20_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t target_phy_rate_20;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_target_phy_rate_20_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&target_phy_rate_20, 0, sizeof(target_phy_rate_20));

      ret = moca_get_target_phy_rate_20(handle, &target_phy_rate_20);

      if (ret == 0) {
         mocacli_print_target_phy_rate_20(&target_phy_rate_20);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_target_phy_rate_20_help( void )
{
   printf("Phy rate in MoCA 2.0 mode\n");

   printf("\nmocap set --target_phy_rate_20 <uint32 mbps>\n");
}

MOCALIB_CLI_SET static int mocacli_set_target_phy_rate_20_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t target_phy_rate_20;

   if (handle != NULL)
   {
      ret = moca_get_target_phy_rate_20(handle, &target_phy_rate_20);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_target_phy_rate_20_help();
            mocacli_target_phy_rate_20__mbps_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &target_phy_rate_20);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_target_phy_rate_20__mbps_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_target_phy_rate_20(handle, target_phy_rate_20);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_target_phy_rate_20_turbo__mbps_help(void)
{
   printf("mbps:\n");
   printf("=====\n");
   printf("\nValues:\n");
   printf("Units of Mbps\n");
   printf("Default:\n");
   printf("670 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_target_phy_rate_20_turbo_help( void )
{
   printf("Phy rate in MoCA 2.0 turbo mode\n");

   printf("\nmocap get --target_phy_rate_20_turbo\n");
}

MOCALIB_CLI_GET static int mocacli_get_target_phy_rate_20_turbo_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t target_phy_rate_20_turbo;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_target_phy_rate_20_turbo_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&target_phy_rate_20_turbo, 0, sizeof(target_phy_rate_20_turbo));

      ret = moca_get_target_phy_rate_20_turbo(handle, &target_phy_rate_20_turbo);

      if (ret == 0) {
         mocacli_print_target_phy_rate_20_turbo(&target_phy_rate_20_turbo);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_target_phy_rate_20_turbo_help( void )
{
   printf("Phy rate in MoCA 2.0 turbo mode\n");

   printf("\nmocap set --target_phy_rate_20_turbo <uint32 mbps>\n");
}

MOCALIB_CLI_SET static int mocacli_set_target_phy_rate_20_turbo_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t target_phy_rate_20_turbo;

   if (handle != NULL)
   {
      ret = moca_get_target_phy_rate_20_turbo(handle, &target_phy_rate_20_turbo);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_target_phy_rate_20_turbo_help();
            mocacli_target_phy_rate_20_turbo__mbps_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &target_phy_rate_20_turbo);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_target_phy_rate_20_turbo__mbps_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_target_phy_rate_20_turbo(handle, target_phy_rate_20_turbo);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_turbo_en__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 = Disable \n");
   printf("1 = Enable\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_turbo_en_help( void )
{
   printf("Enables/Disables Turbo\n");

   printf("\nmocap get --turbo_en\n");
}

MOCALIB_CLI_GET static int mocacli_get_turbo_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t turbo_en;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_turbo_en_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&turbo_en, 0, sizeof(turbo_en));

      ret = moca_get_turbo_en(handle, &turbo_en);

      if (ret == 0) {
         mocacli_print_turbo_en(&turbo_en);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_turbo_en_help( void )
{
   printf("Enables/Disables Turbo\n");

   printf("\nmocap set --turbo_en <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_turbo_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t turbo_en;

   if (handle != NULL)
   {
      ret = moca_get_turbo_en(handle, &turbo_en);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_turbo_en_help();
            mocacli_turbo_en__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &turbo_en);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_turbo_en__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_turbo_en(handle, turbo_en);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_res1__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_res1_help( void )
{
   printf("Reserved lab parameter 1\n");

   printf("\nmocap get --res1\n");
}

MOCALIB_CLI_GET static int mocacli_get_res1_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res1;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_res1_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&res1, 0, sizeof(res1));

      ret = __moca_get_res1(handle, &res1);

      if (ret == 0) {
         mocacli_print_res1(&res1);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_res1_help( void )
{
   printf("Reserved lab parameter 1\n");

   printf("\nmocap set --res1 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_res1_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res1;

   if (handle != NULL)
   {
      ret = __moca_get_res1(handle, &res1);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_res1_help();
            mocacli_res1__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &res1);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_res1__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_res1(handle, res1);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_res2__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_res2_help( void )
{
   printf("Reserved lab parameter 2\n");

   printf("\nmocap get --res2\n");
}

MOCALIB_CLI_GET static int mocacli_get_res2_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res2;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_res2_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&res2, 0, sizeof(res2));

      ret = __moca_get_res2(handle, &res2);

      if (ret == 0) {
         mocacli_print_res2(&res2);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_res2_help( void )
{
   printf("Reserved lab parameter 2\n");

   printf("\nmocap set --res2 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_res2_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res2;

   if (handle != NULL)
   {
      ret = __moca_get_res2(handle, &res2);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_res2_help();
            mocacli_res2__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &res2);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_res2__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_res2(handle, res2);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_res3__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_res3_help( void )
{
   printf("Reserved lab parameter 3\n");

   printf("\nmocap get --res3\n");
}

MOCALIB_CLI_GET static int mocacli_get_res3_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res3;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_res3_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&res3, 0, sizeof(res3));

      ret = __moca_get_res3(handle, &res3);

      if (ret == 0) {
         mocacli_print_res3(&res3);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_res3_help( void )
{
   printf("Reserved lab parameter 3\n");

   printf("\nmocap set --res3 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_res3_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res3;

   if (handle != NULL)
   {
      ret = __moca_get_res3(handle, &res3);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_res3_help();
            mocacli_res3__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &res3);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_res3__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_res3(handle, res3);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_res4__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_res4_help( void )
{
   printf("Reserved lab parameter 4\n");

   printf("\nmocap get --res4\n");
}

MOCALIB_CLI_GET static int mocacli_get_res4_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res4;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_res4_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&res4, 0, sizeof(res4));

      ret = __moca_get_res4(handle, &res4);

      if (ret == 0) {
         mocacli_print_res4(&res4);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_res4_help( void )
{
   printf("Reserved lab parameter 4\n");

   printf("\nmocap set --res4 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_res4_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res4;

   if (handle != NULL)
   {
      ret = __moca_get_res4(handle, &res4);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_res4_help();
            mocacli_res4__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &res4);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_res4__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_res4(handle, res4);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_res5__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_res5_help( void )
{
   printf("Reserved lab parameter 5\n");

   printf("\nmocap get --res5\n");
}

MOCALIB_CLI_GET static int mocacli_get_res5_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res5;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_res5_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&res5, 0, sizeof(res5));

      ret = __moca_get_res5(handle, &res5);

      if (ret == 0) {
         mocacli_print_res5(&res5);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_res5_help( void )
{
   printf("Reserved lab parameter 5\n");

   printf("\nmocap set --res5 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_res5_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res5;

   if (handle != NULL)
   {
      ret = __moca_get_res5(handle, &res5);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_res5_help();
            mocacli_res5__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &res5);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_res5__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_res5(handle, res5);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_res6__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_res6_help( void )
{
   printf("Reserved lab parameter 6\n");

   printf("\nmocap get --res6\n");
}

MOCALIB_CLI_GET static int mocacli_get_res6_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res6;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_res6_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&res6, 0, sizeof(res6));

      ret = __moca_get_res6(handle, &res6);

      if (ret == 0) {
         mocacli_print_res6(&res6);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_res6_help( void )
{
   printf("Reserved lab parameter 6\n");

   printf("\nmocap set --res6 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_res6_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res6;

   if (handle != NULL)
   {
      ret = __moca_get_res6(handle, &res6);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_res6_help();
            mocacli_res6__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &res6);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_res6__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_res6(handle, res6);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_res7__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_res7_help( void )
{
   printf("Reserved lab parameter 7\n");

   printf("\nmocap get --res7\n");
}

MOCALIB_CLI_GET static int mocacli_get_res7_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res7;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_res7_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&res7, 0, sizeof(res7));

      ret = __moca_get_res7(handle, &res7);

      if (ret == 0) {
         mocacli_print_res7(&res7);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_res7_help( void )
{
   printf("Reserved lab parameter 7\n");

   printf("\nmocap set --res7 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_res7_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res7;

   if (handle != NULL)
   {
      ret = __moca_get_res7(handle, &res7);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_res7_help();
            mocacli_res7__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &res7);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_res7__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_res7(handle, res7);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_res8__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_res8_help( void )
{
   printf("Reserved lab parameter 8\n");

   printf("\nmocap get --res8\n");
}

MOCALIB_CLI_GET static int mocacli_get_res8_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res8;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_res8_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&res8, 0, sizeof(res8));

      ret = __moca_get_res8(handle, &res8);

      if (ret == 0) {
         mocacli_print_res8(&res8);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_res8_help( void )
{
   printf("Reserved lab parameter 8\n");

   printf("\nmocap set --res8 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_res8_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res8;

   if (handle != NULL)
   {
      ret = __moca_get_res8(handle, &res8);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_res8_help();
            mocacli_res8__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &res8);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_res8__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_res8(handle, res8);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_res9__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_res9_help( void )
{
   printf("Reserved lab parameter 9\n");

   printf("\nmocap get --res9\n");
}

MOCALIB_CLI_GET static int mocacli_get_res9_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res9;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_res9_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&res9, 0, sizeof(res9));

      ret = __moca_get_res9(handle, &res9);

      if (ret == 0) {
         mocacli_print_res9(&res9);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_res9_help( void )
{
   printf("Reserved lab parameter 9\n");

   printf("\nmocap set --res9 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_res9_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res9;

   if (handle != NULL)
   {
      ret = __moca_get_res9(handle, &res9);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_res9_help();
            mocacli_res9__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &res9);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_res9__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_res9(handle, res9);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_init1__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_init1_help( void )
{
   printf("Reserved init-time lab parameter 1\n");

   printf("\nmocap get --init1\n");
}

MOCALIB_CLI_GET static int mocacli_get_init1_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t init1;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_init1_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&init1, 0, sizeof(init1));

      ret = __moca_get_init1(handle, &init1);

      if (ret == 0) {
         mocacli_print_init1(&init1);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_init1_help( void )
{
   printf("Reserved init-time lab parameter 1\n");

   printf("\nmocap set --init1 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_init1_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t init1;

   if (handle != NULL)
   {
      ret = __moca_get_init1(handle, &init1);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_init1_help();
            mocacli_init1__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &init1);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_init1__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_init1(handle, init1);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_init2__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_init2_help( void )
{
   printf("Reserved init-time lab parameter 2\n");

   printf("\nmocap get --init2\n");
}

MOCALIB_CLI_GET static int mocacli_get_init2_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t init2;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_init2_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&init2, 0, sizeof(init2));

      ret = __moca_get_init2(handle, &init2);

      if (ret == 0) {
         mocacli_print_init2(&init2);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_init2_help( void )
{
   printf("Reserved init-time lab parameter 2\n");

   printf("\nmocap set --init2 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_init2_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t init2;

   if (handle != NULL)
   {
      ret = __moca_get_init2(handle, &init2);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_init2_help();
            mocacli_init2__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &init2);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_init2__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_init2(handle, init2);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_init3__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_init3_help( void )
{
   printf("Reserved init-time lab parameter 3\n");

   printf("\nmocap get --init3\n");
}

MOCALIB_CLI_GET static int mocacli_get_init3_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t init3;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_init3_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&init3, 0, sizeof(init3));

      ret = __moca_get_init3(handle, &init3);

      if (ret == 0) {
         mocacli_print_init3(&init3);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_init3_help( void )
{
   printf("Reserved init-time lab parameter 3\n");

   printf("\nmocap set --init3 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_init3_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t init3;

   if (handle != NULL)
   {
      ret = __moca_get_init3(handle, &init3);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_init3_help();
            mocacli_init3__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &init3);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_init3__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_init3(handle, init3);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_init4__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_init4_help( void )
{
   printf("Reserved init-time lab parameter 4\n");

   printf("\nmocap get --init4\n");
}

MOCALIB_CLI_GET static int mocacli_get_init4_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t init4;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_init4_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&init4, 0, sizeof(init4));

      ret = __moca_get_init4(handle, &init4);

      if (ret == 0) {
         mocacli_print_init4(&init4);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_init4_help( void )
{
   printf("Reserved init-time lab parameter 4\n");

   printf("\nmocap set --init4 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_init4_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t init4;

   if (handle != NULL)
   {
      ret = __moca_get_init4(handle, &init4);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_init4_help();
            mocacli_init4__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &init4);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_init4__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_init4(handle, init4);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_init5__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_init5_help( void )
{
   printf("Reserved init-time lab parameter 5\n");

   printf("\nmocap get --init5\n");
}

MOCALIB_CLI_GET static int mocacli_get_init5_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t init5;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_init5_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&init5, 0, sizeof(init5));

      ret = __moca_get_init5(handle, &init5);

      if (ret == 0) {
         mocacli_print_init5(&init5);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_init5_help( void )
{
   printf("Reserved init-time lab parameter 5\n");

   printf("\nmocap set --init5 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_init5_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t init5;

   if (handle != NULL)
   {
      ret = __moca_get_init5(handle, &init5);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_init5_help();
            mocacli_init5__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &init5);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_init5__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_init5(handle, init5);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_init6__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_init6_help( void )
{
   printf("Reserved init-time lab parameter 6\n");

   printf("\nmocap get --init6\n");
}

MOCALIB_CLI_GET static int mocacli_get_init6_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t init6;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_init6_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&init6, 0, sizeof(init6));

      ret = __moca_get_init6(handle, &init6);

      if (ret == 0) {
         mocacli_print_init6(&init6);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_init6_help( void )
{
   printf("Reserved init-time lab parameter 6\n");

   printf("\nmocap set --init6 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_init6_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t init6;

   if (handle != NULL)
   {
      ret = __moca_get_init6(handle, &init6);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_init6_help();
            mocacli_init6__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &init6);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_init6__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_init6(handle, init6);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_init7__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_init7_help( void )
{
   printf("Reserved init-time lab parameter 7\n");

   printf("\nmocap get --init7\n");
}

MOCALIB_CLI_GET static int mocacli_get_init7_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t init7;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_init7_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&init7, 0, sizeof(init7));

      ret = __moca_get_init7(handle, &init7);

      if (ret == 0) {
         mocacli_print_init7(&init7);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_init7_help( void )
{
   printf("Reserved init-time lab parameter 7\n");

   printf("\nmocap set --init7 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_init7_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t init7;

   if (handle != NULL)
   {
      ret = __moca_get_init7(handle, &init7);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_init7_help();
            mocacli_init7__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &init7);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_init7__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_init7(handle, init7);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_init8__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_init8_help( void )
{
   printf("Reserved init-time lab parameter 8\n");

   printf("\nmocap get --init8\n");
}

MOCALIB_CLI_GET static int mocacli_get_init8_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t init8;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_init8_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&init8, 0, sizeof(init8));

      ret = __moca_get_init8(handle, &init8);

      if (ret == 0) {
         mocacli_print_init8(&init8);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_init8_help( void )
{
   printf("Reserved init-time lab parameter 8\n");

   printf("\nmocap set --init8 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_init8_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t init8;

   if (handle != NULL)
   {
      ret = __moca_get_init8(handle, &init8);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_init8_help();
            mocacli_init8__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &init8);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_init8__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_init8(handle, init8);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_init9__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_init9_help( void )
{
   printf("Reserved init-time lab parameter 9\n");

   printf("\nmocap get --init9\n");
}

MOCALIB_CLI_GET static int mocacli_get_init9_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t init9;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_init9_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&init9, 0, sizeof(init9));

      ret = __moca_get_init9(handle, &init9);

      if (ret == 0) {
         mocacli_print_init9(&init9);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_init9_help( void )
{
   printf("Reserved init-time lab parameter 9\n");

   printf("\nmocap set --init9 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_init9_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t init9;

   if (handle != NULL)
   {
      ret = __moca_get_init9(handle, &init9);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_init9_help();
            mocacli_init9__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &init9);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_init9__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_init9(handle, init9);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_lab_snr_graph_set__node_id_help(void)
{
   printf("node_id:\n");
   printf("========\n");
   printf("Default:\n");
   printf("0xff \n");
}

MOCALIB_CLI_HELP static void mocacli_get_lab_snr_graph_set_help( void )
{
   printf("Initiating the production of SNR graph data in the MoCA core. The data is a result of Probe I received during LMO.\n");

   printf("\nmocap get --lab_snr_graph_set\n");
}

MOCALIB_CLI_GET static int mocacli_get_lab_snr_graph_set_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t lab_snr_graph_set;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_lab_snr_graph_set_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&lab_snr_graph_set, 0, sizeof(lab_snr_graph_set));

      ret = __moca_get_lab_snr_graph_set(handle, &lab_snr_graph_set);

      if (ret == 0) {
         mocacli_print_lab_snr_graph_set(&lab_snr_graph_set);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_lab_snr_graph_set_help( void )
{
   printf("Initiating the production of SNR graph data in the MoCA core. The data is a result of Probe I received during LMO.\n");

   printf("\nmocap set --lab_snr_graph_set <uint32 node_id>\n");
}

MOCALIB_CLI_SET static int mocacli_set_lab_snr_graph_set_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t lab_snr_graph_set;

   if (handle != NULL)
   {
      ret = __moca_get_lab_snr_graph_set(handle, &lab_snr_graph_set);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_lab_snr_graph_set_help();
            mocacli_lab_snr_graph_set__node_id_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &lab_snr_graph_set);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_lab_snr_graph_set__node_id_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_lab_snr_graph_set(handle, lab_snr_graph_set);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_block_nack_rate__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("The value corresponds to X where one MSDU in X is NACKed.\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_block_nack_rate_help( void )
{
   printf("For GCAP.133, set the node to drop 1 out every Nth MSDU and provide NACK in BlockAck to transmitter.\n");

   printf("\nmocap get --block_nack_rate\n");
}

MOCALIB_CLI_GET static int mocacli_get_block_nack_rate_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t block_nack_rate;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_block_nack_rate_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&block_nack_rate, 0, sizeof(block_nack_rate));

      ret = __moca_get_block_nack_rate(handle, &block_nack_rate);

      if (ret == 0) {
         mocacli_print_block_nack_rate(&block_nack_rate);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_block_nack_rate_help( void )
{
   printf("For GCAP.133, set the node to drop 1 out every Nth MSDU and provide NACK in BlockAck to transmitter.\n");

   printf("\nmocap set --block_nack_rate <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_block_nack_rate_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t block_nack_rate;

   if (handle != NULL)
   {
      ret = __moca_get_block_nack_rate(handle, &block_nack_rate);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_block_nack_rate_help();
            mocacli_block_nack_rate__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &block_nack_rate);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_block_nack_rate__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_block_nack_rate(handle, block_nack_rate);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_res10__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_res10_help( void )
{
   printf("Reserved lab parameter 10\n");

   printf("\nmocap get --res10\n");
}

MOCALIB_CLI_GET static int mocacli_get_res10_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res10;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_res10_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&res10, 0, sizeof(res10));

      ret = __moca_get_res10(handle, &res10);

      if (ret == 0) {
         mocacli_print_res10(&res10);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_res10_help( void )
{
   printf("Reserved lab parameter 10\n");

   printf("\nmocap set --res10 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_res10_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res10;

   if (handle != NULL)
   {
      ret = __moca_get_res10(handle, &res10);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_res10_help();
            mocacli_res10__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &res10);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_res10__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_res10(handle, res10);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_res11__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_res11_help( void )
{
   printf("Reserved lab parameter 11\n");

   printf("\nmocap get --res11\n");
}

MOCALIB_CLI_GET static int mocacli_get_res11_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res11;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_res11_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&res11, 0, sizeof(res11));

      ret = __moca_get_res11(handle, &res11);

      if (ret == 0) {
         mocacli_print_res11(&res11);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_res11_help( void )
{
   printf("Reserved lab parameter 11\n");

   printf("\nmocap set --res11 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_res11_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res11;

   if (handle != NULL)
   {
      ret = __moca_get_res11(handle, &res11);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_res11_help();
            mocacli_res11__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &res11);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_res11__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_res11(handle, res11);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_res12__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_res12_help( void )
{
   printf("Reserved lab parameter 12\n");

   printf("\nmocap get --res12\n");
}

MOCALIB_CLI_GET static int mocacli_get_res12_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res12;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_res12_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&res12, 0, sizeof(res12));

      ret = __moca_get_res12(handle, &res12);

      if (ret == 0) {
         mocacli_print_res12(&res12);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_res12_help( void )
{
   printf("Reserved lab parameter 12\n");

   printf("\nmocap set --res12 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_res12_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res12;

   if (handle != NULL)
   {
      ret = __moca_get_res12(handle, &res12);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_res12_help();
            mocacli_res12__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &res12);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_res12__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_res12(handle, res12);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_res13__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_res13_help( void )
{
   printf("Reserved lab parameter 13\n");

   printf("\nmocap get --res13\n");
}

MOCALIB_CLI_GET static int mocacli_get_res13_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res13;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_res13_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&res13, 0, sizeof(res13));

      ret = __moca_get_res13(handle, &res13);

      if (ret == 0) {
         mocacli_print_res13(&res13);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_res13_help( void )
{
   printf("Reserved lab parameter 13\n");

   printf("\nmocap set --res13 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_res13_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res13;

   if (handle != NULL)
   {
      ret = __moca_get_res13(handle, &res13);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_res13_help();
            mocacli_res13__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &res13);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_res13__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_res13(handle, res13);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_res14__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_res14_help( void )
{
   printf("Reserved lab parameter 14\n");

   printf("\nmocap get --res14\n");
}

MOCALIB_CLI_GET static int mocacli_get_res14_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res14;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_res14_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&res14, 0, sizeof(res14));

      ret = __moca_get_res14(handle, &res14);

      if (ret == 0) {
         mocacli_print_res14(&res14);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_res14_help( void )
{
   printf("Reserved lab parameter 14\n");

   printf("\nmocap set --res14 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_res14_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res14;

   if (handle != NULL)
   {
      ret = __moca_get_res14(handle, &res14);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_res14_help();
            mocacli_res14__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &res14);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_res14__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_res14(handle, res14);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_res15__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_res15_help( void )
{
   printf("Reserved lab parameter 15\n");

   printf("\nmocap get --res15\n");
}

MOCALIB_CLI_GET static int mocacli_get_res15_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res15;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_res15_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&res15, 0, sizeof(res15));

      ret = __moca_get_res15(handle, &res15);

      if (ret == 0) {
         mocacli_print_res15(&res15);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_res15_help( void )
{
   printf("Reserved lab parameter 15\n");

   printf("\nmocap set --res15 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_res15_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res15;

   if (handle != NULL)
   {
      ret = __moca_get_res15(handle, &res15);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_res15_help();
            mocacli_res15__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &res15);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_res15__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_res15(handle, res15);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_res16__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_res16_help( void )
{
   printf("Reserved lab parameter 16\n");

   printf("\nmocap get --res16\n");
}

MOCALIB_CLI_GET static int mocacli_get_res16_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res16;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_res16_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&res16, 0, sizeof(res16));

      ret = __moca_get_res16(handle, &res16);

      if (ret == 0) {
         mocacli_print_res16(&res16);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_res16_help( void )
{
   printf("Reserved lab parameter 16\n");

   printf("\nmocap set --res16 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_res16_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res16;

   if (handle != NULL)
   {
      ret = __moca_get_res16(handle, &res16);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_res16_help();
            mocacli_res16__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &res16);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_res16__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_res16(handle, res16);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_res17__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_res17_help( void )
{
   printf("Reserved lab parameter 17\n");

   printf("\nmocap get --res17\n");
}

MOCALIB_CLI_GET static int mocacli_get_res17_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res17;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_res17_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&res17, 0, sizeof(res17));

      ret = __moca_get_res17(handle, &res17);

      if (ret == 0) {
         mocacli_print_res17(&res17);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_res17_help( void )
{
   printf("Reserved lab parameter 17\n");

   printf("\nmocap set --res17 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_res17_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res17;

   if (handle != NULL)
   {
      ret = __moca_get_res17(handle, &res17);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_res17_help();
            mocacli_res17__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &res17);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_res17__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_res17(handle, res17);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_res18__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_res18_help( void )
{
   printf("Reserved lab parameter 18\n");

   printf("\nmocap get --res18\n");
}

MOCALIB_CLI_GET static int mocacli_get_res18_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res18;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_res18_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&res18, 0, sizeof(res18));

      ret = __moca_get_res18(handle, &res18);

      if (ret == 0) {
         mocacli_print_res18(&res18);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_res18_help( void )
{
   printf("Reserved lab parameter 18\n");

   printf("\nmocap set --res18 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_res18_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res18;

   if (handle != NULL)
   {
      ret = __moca_get_res18(handle, &res18);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_res18_help();
            mocacli_res18__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &res18);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_res18__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_res18(handle, res18);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_res19__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_res19_help( void )
{
   printf("Reserved lab parameter 19\n");

   printf("\nmocap get --res19\n");
}

MOCALIB_CLI_GET static int mocacli_get_res19_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res19;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_res19_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&res19, 0, sizeof(res19));

      ret = __moca_get_res19(handle, &res19);

      if (ret == 0) {
         mocacli_print_res19(&res19);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_res19_help( void )
{
   printf("Reserved lab parameter 19\n");

   printf("\nmocap set --res19 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_res19_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res19;

   if (handle != NULL)
   {
      ret = __moca_get_res19(handle, &res19);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_res19_help();
            mocacli_res19__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &res19);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_res19__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_res19(handle, res19);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_res20__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_res20_help( void )
{
   printf("Reserved lab parameter 20\n");

   printf("\nmocap get --res20\n");
}

MOCALIB_CLI_GET static int mocacli_get_res20_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res20;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_res20_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&res20, 0, sizeof(res20));

      ret = __moca_get_res20(handle, &res20);

      if (ret == 0) {
         mocacli_print_res20(&res20);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_res20_help( void )
{
   printf("Reserved lab parameter 20\n");

   printf("\nmocap set --res20 <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_res20_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t res20;

   if (handle != NULL)
   {
      ret = __moca_get_res20(handle, &res20);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_res20_help();
            mocacli_res20__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &res20);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_res20__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_res20(handle, res20);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_target_phy_rate_20_turbo_vlper__mbps_help(void)
{
   printf("mbps:\n");
   printf("=====\n");
   printf("\nValues:\n");
   printf("Units of Mbps\n");
   printf("Default:\n");
   printf("650 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_target_phy_rate_20_turbo_vlper_help( void )
{
   printf("Phy rate in MoCA 2.0 turbo mode for VLPER PHY profiles\n");

   printf("\nmocap get --target_phy_rate_20_turbo_vlper\n");
}

MOCALIB_CLI_GET static int mocacli_get_target_phy_rate_20_turbo_vlper_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t target_phy_rate_20_turbo_vlper;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_target_phy_rate_20_turbo_vlper_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&target_phy_rate_20_turbo_vlper, 0, sizeof(target_phy_rate_20_turbo_vlper));

      ret = moca_get_target_phy_rate_20_turbo_vlper(handle, &target_phy_rate_20_turbo_vlper);

      if (ret == 0) {
         mocacli_print_target_phy_rate_20_turbo_vlper(&target_phy_rate_20_turbo_vlper);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_target_phy_rate_20_turbo_vlper_help( void )
{
   printf("Phy rate in MoCA 2.0 turbo mode for VLPER PHY profiles\n");

   printf("\nmocap set --target_phy_rate_20_turbo_vlper <uint32 mbps>\n");
}

MOCALIB_CLI_SET static int mocacli_set_target_phy_rate_20_turbo_vlper_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t target_phy_rate_20_turbo_vlper;

   if (handle != NULL)
   {
      ret = moca_get_target_phy_rate_20_turbo_vlper(handle, &target_phy_rate_20_turbo_vlper);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_target_phy_rate_20_turbo_vlper_help();
            mocacli_target_phy_rate_20_turbo_vlper__mbps_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &target_phy_rate_20_turbo_vlper);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_target_phy_rate_20_turbo_vlper__mbps_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_target_phy_rate_20_turbo_vlper(handle, target_phy_rate_20_turbo_vlper);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_target_phy_rate_20_sec_ch__mbps_help(void)
{
   printf("mbps:\n");
   printf("=====\n");
   printf("\nValues:\n");
   printf("Units of Mbps\n");
   printf("Default:\n");
   printf("630 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_target_phy_rate_20_sec_ch_help( void )
{
   printf("Secondary phy rate in MoCA 2.0 mode\n");

   printf("\nmocap get --target_phy_rate_20_sec_ch\n");
}

MOCALIB_CLI_GET static int mocacli_get_target_phy_rate_20_sec_ch_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t target_phy_rate_20_sec_ch;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_target_phy_rate_20_sec_ch_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&target_phy_rate_20_sec_ch, 0, sizeof(target_phy_rate_20_sec_ch));

      ret = moca_get_target_phy_rate_20_sec_ch(handle, &target_phy_rate_20_sec_ch);

      if (ret == 0) {
         mocacli_print_target_phy_rate_20_sec_ch(&target_phy_rate_20_sec_ch);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_target_phy_rate_20_sec_ch_help( void )
{
   printf("Secondary phy rate in MoCA 2.0 mode\n");

   printf("\nmocap set --target_phy_rate_20_sec_ch <uint32 mbps>\n");
}

MOCALIB_CLI_SET static int mocacli_set_target_phy_rate_20_sec_ch_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t target_phy_rate_20_sec_ch;

   if (handle != NULL)
   {
      ret = moca_get_target_phy_rate_20_sec_ch(handle, &target_phy_rate_20_sec_ch);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_target_phy_rate_20_sec_ch_help();
            mocacli_target_phy_rate_20_sec_ch__mbps_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &target_phy_rate_20_sec_ch);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_target_phy_rate_20_sec_ch__mbps_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_target_phy_rate_20_sec_ch(handle, target_phy_rate_20_sec_ch);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_target_phy_rate_20_turbo_sec_ch__mbps_help(void)
{
   printf("mbps:\n");
   printf("=====\n");
   printf("\nValues:\n");
   printf("Units of Mbps\n");
   printf("Default:\n");
   printf("670 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_target_phy_rate_20_turbo_sec_ch_help( void )
{
   printf("Secondary phy rate in MoCA 2.0 turbo mode\n");

   printf("\nmocap get --target_phy_rate_20_turbo_sec_ch\n");
}

MOCALIB_CLI_GET static int mocacli_get_target_phy_rate_20_turbo_sec_ch_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t target_phy_rate_20_turbo_sec_ch;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_target_phy_rate_20_turbo_sec_ch_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&target_phy_rate_20_turbo_sec_ch, 0, sizeof(target_phy_rate_20_turbo_sec_ch));

      ret = moca_get_target_phy_rate_20_turbo_sec_ch(handle, &target_phy_rate_20_turbo_sec_ch);

      if (ret == 0) {
         mocacli_print_target_phy_rate_20_turbo_sec_ch(&target_phy_rate_20_turbo_sec_ch);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_target_phy_rate_20_turbo_sec_ch_help( void )
{
   printf("Secondary phy rate in MoCA 2.0 turbo mode\n");

   printf("\nmocap set --target_phy_rate_20_turbo_sec_ch <uint32 mbps>\n");
}

MOCALIB_CLI_SET static int mocacli_set_target_phy_rate_20_turbo_sec_ch_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t target_phy_rate_20_turbo_sec_ch;

   if (handle != NULL)
   {
      ret = moca_get_target_phy_rate_20_turbo_sec_ch(handle, &target_phy_rate_20_turbo_sec_ch);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_target_phy_rate_20_turbo_sec_ch_help();
            mocacli_target_phy_rate_20_turbo_sec_ch__mbps_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &target_phy_rate_20_turbo_sec_ch);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_target_phy_rate_20_turbo_sec_ch__mbps_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_target_phy_rate_20_turbo_sec_ch(handle, target_phy_rate_20_turbo_sec_ch);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_target_phy_rate_20_turbo_vlper_sec_ch__mbps_help(void)
{
   printf("mbps:\n");
   printf("=====\n");
   printf("\nValues:\n");
   printf("Units of Mbps\n");
   printf("Default:\n");
   printf("650 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_target_phy_rate_20_turbo_vlper_sec_ch_help( void )
{
   printf("Secondary phy rate in MoCA 2.0 turbo mode for VLPER PHY profiles\n");

   printf("\nmocap get --target_phy_rate_20_turbo_vlper_sec_ch\n");
}

MOCALIB_CLI_GET static int mocacli_get_target_phy_rate_20_turbo_vlper_sec_ch_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t target_phy_rate_20_turbo_vlper_sec_ch;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_target_phy_rate_20_turbo_vlper_sec_ch_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&target_phy_rate_20_turbo_vlper_sec_ch, 0, sizeof(target_phy_rate_20_turbo_vlper_sec_ch));

      ret = moca_get_target_phy_rate_20_turbo_vlper_sec_ch(handle, &target_phy_rate_20_turbo_vlper_sec_ch);

      if (ret == 0) {
         mocacli_print_target_phy_rate_20_turbo_vlper_sec_ch(&target_phy_rate_20_turbo_vlper_sec_ch);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_target_phy_rate_20_turbo_vlper_sec_ch_help( void )
{
   printf("Secondary phy rate in MoCA 2.0 turbo mode for VLPER PHY profiles\n");

   printf("\nmocap set --target_phy_rate_20_turbo_vlper_sec_ch <uint32 mbps>\n");
}

MOCALIB_CLI_SET static int mocacli_set_target_phy_rate_20_turbo_vlper_sec_ch_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t target_phy_rate_20_turbo_vlper_sec_ch;

   if (handle != NULL)
   {
      ret = moca_get_target_phy_rate_20_turbo_vlper_sec_ch(handle, &target_phy_rate_20_turbo_vlper_sec_ch);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_target_phy_rate_20_turbo_vlper_sec_ch_help();
            mocacli_target_phy_rate_20_turbo_vlper_sec_ch__mbps_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &target_phy_rate_20_turbo_vlper_sec_ch);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_target_phy_rate_20_turbo_vlper_sec_ch__mbps_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_target_phy_rate_20_turbo_vlper_sec_ch(handle, target_phy_rate_20_turbo_vlper_sec_ch);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_cap_phy_rate_en__bool_val_help(void)
{
   printf("bool_val:\n");
   printf("=========\n");
   printf("\nValues:\n");
   printf("0 = Disable \n");
   printf("1 = Enable\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_cap_phy_rate_en_help( void )
{
   printf("Enables capping of target phy rate and SNR base margin for channels {1400 MHz}. Relevant for bonding mode only.\n");

   printf("\nmocap get --cap_phy_rate_en\n");
}

MOCALIB_CLI_GET static int mocacli_get_cap_phy_rate_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t cap_phy_rate_en;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_cap_phy_rate_en_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&cap_phy_rate_en, 0, sizeof(cap_phy_rate_en));

      ret = moca_get_cap_phy_rate_en(handle, &cap_phy_rate_en);

      if (ret == 0) {
         mocacli_print_cap_phy_rate_en(&cap_phy_rate_en);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_cap_phy_rate_en_help( void )
{
   printf("Enables capping of target phy rate and SNR base margin for channels {1400 MHz}. Relevant for bonding mode only.\n");

   printf("\nmocap set --cap_phy_rate_en <uint32 bool_val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_cap_phy_rate_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t cap_phy_rate_en;

   if (handle != NULL)
   {
      ret = moca_get_cap_phy_rate_en(handle, &cap_phy_rate_en);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_cap_phy_rate_en_help();
            mocacli_cap_phy_rate_en__bool_val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &cap_phy_rate_en);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_cap_phy_rate_en__bool_val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_cap_phy_rate_en(handle, cap_phy_rate_en);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_cap_target_phy_rate__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("Units of Mbps\n");
   printf("Default:\n");
   printf("670 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_cap_target_phy_rate_help( void )
{
   printf("Upper bound of target phy rate at capped channels {1400 MHz}. Relevant for bonding mode only.\n");

   printf("\nmocap get --cap_target_phy_rate\n");
}

MOCALIB_CLI_GET static int mocacli_get_cap_target_phy_rate_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t cap_target_phy_rate;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_cap_target_phy_rate_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&cap_target_phy_rate, 0, sizeof(cap_target_phy_rate));

      ret = moca_get_cap_target_phy_rate(handle, &cap_target_phy_rate);

      if (ret == 0) {
         mocacli_print_cap_target_phy_rate(&cap_target_phy_rate);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_cap_target_phy_rate_help( void )
{
   printf("Upper bound of target phy rate at capped channels {1400 MHz}. Relevant for bonding mode only.\n");

   printf("\nmocap set --cap_target_phy_rate <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_cap_target_phy_rate_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t cap_target_phy_rate;

   if (handle != NULL)
   {
      ret = moca_get_cap_target_phy_rate(handle, &cap_target_phy_rate);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_cap_target_phy_rate_help();
            mocacli_cap_target_phy_rate__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &cap_target_phy_rate);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_cap_target_phy_rate__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_cap_target_phy_rate(handle, cap_target_phy_rate);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_cap_snr_base_margin__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("Units of 1/256 dB\n");
   printf("Default:\n");
   printf("400 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_cap_snr_base_margin_help( void )
{
   printf("Lower bound of LDPC SNR base margin at capped channels {1400 MHz}. Relevant for bonding mode only.\n");

   printf("\nmocap get --cap_snr_base_margin\n");
}

MOCALIB_CLI_GET static int mocacli_get_cap_snr_base_margin_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t cap_snr_base_margin;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_cap_snr_base_margin_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&cap_snr_base_margin, 0, sizeof(cap_snr_base_margin));

      ret = moca_get_cap_snr_base_margin(handle, &cap_snr_base_margin);

      if (ret == 0) {
         mocacli_print_cap_snr_base_margin(&cap_snr_base_margin);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_cap_snr_base_margin_help( void )
{
   printf("Lower bound of LDPC SNR base margin at capped channels {1400 MHz}. Relevant for bonding mode only.\n");

   printf("\nmocap set --cap_snr_base_margin <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_cap_snr_base_margin_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t cap_snr_base_margin;

   if (handle != NULL)
   {
      ret = moca_get_cap_snr_base_margin(handle, &cap_snr_base_margin);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_cap_snr_base_margin_help();
            mocacli_cap_snr_base_margin__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &cap_snr_base_margin);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_cap_snr_base_margin__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_cap_snr_base_margin(handle, cap_snr_base_margin);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_map_capture__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("Turns on MAP forwarding to ethernet\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_map_capture_help( void )
{
   printf("Forward maps over ethernet for debug.\n");

   printf("\nmocap get --map_capture\n");
}

MOCALIB_CLI_GET static int mocacli_get_map_capture_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t map_capture;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_map_capture_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&map_capture, 0, sizeof(map_capture));

      ret = __moca_get_map_capture(handle, &map_capture);

      if (ret == 0) {
         mocacli_print_map_capture(&map_capture);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_map_capture_help( void )
{
   printf("Forward maps over ethernet for debug.\n");

   printf("\nmocap set --map_capture <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_map_capture_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t map_capture;

   if (handle != NULL)
   {
      ret = __moca_get_map_capture(handle, &map_capture);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_map_capture_help();
            mocacli_map_capture__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &map_capture);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_map_capture__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_map_capture(handle, map_capture);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_lab_iq_diagram_set__nodeid_help(void)
{
   printf("nodeid:\n");
   printf("=======\n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("15 \n");
}

MOCALIB_CLI_HELP static void mocacli_lab_iq_diagram_set__bursttype_help(void)
{
   printf("bursttype:\n");
   printf("==========\n");
   printf("\nValues:\n");
   printf("1 = Beacon \n");
   printf("6 = MAP \n");
   printf("7 = Unicast \n");
   printf("8 = Broadcast \n");
   printf("0,2,3,4,5 = Reserved\n");
}

MOCALIB_CLI_HELP static void mocacli_lab_iq_diagram_set__acmtsymnum_help(void)
{
   printf("acmtsymnum:\n");
   printf("===========\n");
   printf("\nValues:\n");
   printf("1 = last sym \n");
   printf("2 = sym before last. \n");
   printf("3..10 = prev sym\n");
}

MOCALIB_CLI_HELP static void mocacli_set_lab_iq_diagram_set_help( void )
{
   printf("Initiating the production of IQ constellation diagram in the MoCA core, for RX bursts.\n");

   printf("\nmocap set --lab_iq_diagram_set <options>\n");
   printf("options:\n");
   printf("   nodeid       <uint32>\n");
   printf("   bursttype    <uint32>\n");
   printf("   acmtsymnum   <uint32>\n");
}

MOCALIB_CLI_SET static int mocacli_set_lab_iq_diagram_set_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_lab_iq_diagram_set lab_iq_diagram_set;

   memset(&lab_iq_diagram_set, 0, sizeof(lab_iq_diagram_set));

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "nodeid"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_lab_iq_diagram_set__nodeid_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &lab_iq_diagram_set.nodeid);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_lab_iq_diagram_set__nodeid_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "bursttype"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_lab_iq_diagram_set__bursttype_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &lab_iq_diagram_set.bursttype);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_lab_iq_diagram_set__bursttype_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "acmtsymnum"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_lab_iq_diagram_set__acmtsymnum_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &lab_iq_diagram_set.acmtsymnum);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_lab_iq_diagram_set__acmtsymnum_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_lab_iq_diagram_set_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_lab_iq_diagram_set(handle, &lab_iq_diagram_set);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_lab_register__address_help(void)
{
   printf("address:\n");
   printf("========\n");
   printf("\nValues:\n");
   printf("Address 32 bit from the allowed memory map of the MoCA CPU\n");
}

MOCALIB_CLI_HELP static void mocacli_get_lab_register_help( void )
{
   printf("Reading or writing a register or a memory address by using the MoCA CPU.The input parameter is a 32 bits address.\n");

   printf("\nmocap get --lab_register <uint32 address>\n");
}

MOCALIB_CLI_GET static int mocacli_get_lab_register_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t lab_register;
   int found_address = 0;
   uint32_t address;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_lab_register_help();
      mocacli_lab_register__address_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_lab_register__address_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &address);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_lab_register__address_help();
               return(ret);
            }
            found_address = 1;
         }
   }

   if (!found_address)
   {
      printf("Missing address parameter.\n");
      return(0);
   }

   if (handle != NULL)
   {
      memset(&lab_register, 0, sizeof(lab_register));

      ret = moca_get_lab_register(handle, address, &lab_register);

      if (ret == 0) {
         mocacli_print_lab_register(&lab_register);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_lab_register__len_help(void)
{
   printf("len:\n");
   printf("====\n");
}

MOCALIB_CLI_HELP static void mocacli_lab_register__value_help(void)
{
   printf("value[48]:\n");
   printf("==========\n");
}

MOCALIB_CLI_HELP static void mocacli_set_lab_register_help( void )
{
   printf("Reading or writing a register or a memory address by using the MoCA CPU.The input parameter is a 32 bits address.\n");

   printf("\nmocap set --lab_register <options>\n");
   printf("options:\n");
   printf("   len       <uint32>\n");
   printf("   address   <uint32>\n");
   printf("   value     <uint32 value> <index> <end index (optional)>\n");
}

MOCALIB_CLI_SET static int mocacli_set_lab_register_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_lab_register lab_register;

   memset(&lab_register, 0, sizeof(lab_register));

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "len"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_lab_register__len_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &lab_register.len);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_lab_register__len_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "address"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_lab_register__address_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &lab_register.address);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_lab_register__address_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "value"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_lab_register__value_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32_array(&pp_parms, &num_parms, &lab_register.value[0], 1);
            if (ret != 0)
            {
               mocacli_lab_register__value_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_lab_register_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_lab_register(handle, &lab_register);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_lab_cmd__index_help(void)
{
   printf("index:\n");
   printf("======\n");
}

MOCALIB_CLI_HELP static void mocacli_get_lab_cmd_help( void )
{
   printf("Invoking a function of the MoCA CPU software.\n");

   printf("\nmocap get --lab_cmd <uint32 index>\n");
}

MOCALIB_CLI_GET static int mocacli_get_lab_cmd_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t lab_cmd;
   int found_index = 0;
   uint32_t index;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_lab_cmd_help();
      mocacli_lab_cmd__index_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_lab_cmd__index_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &index);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_lab_cmd__index_help();
               return(ret);
            }
            found_index = 1;
         }
   }

   if (!found_index)
   {
      printf("Missing index parameter.\n");
      return(0);
   }

   if (handle != NULL)
   {
      memset(&lab_cmd, 0, sizeof(lab_cmd));

      ret = __moca_get_lab_cmd(handle, index, &lab_cmd);

      if (ret == 0) {
         mocacli_print_lab_cmd(&lab_cmd);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_lab_cmd__params_help(void)
{
   printf("params[32]:\n");
   printf("===========\n");
}

MOCALIB_CLI_HELP static void mocacli_set_lab_cmd_help( void )
{
   printf("Invoking a function of the MoCA CPU software.\n");

   printf("\nmocap set --lab_cmd <options>\n");
   printf("options:\n");
   printf("   params   <uint32 value1> <uint32 value2> ...\n");
   printf("   index    <uint32>\n");
}

MOCALIB_CLI_SET static int mocacli_set_lab_cmd_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_lab_cmd lab_cmd;

   memset(&lab_cmd, 0, sizeof(lab_cmd));

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "params"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_lab_cmd__params_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32_var_array(&pp_parms, &num_parms, &lab_cmd.params[0], sizeof(lab_cmd.params));
            if (ret != 0)
            {
               mocacli_lab_cmd__params_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "index"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_lab_cmd__index_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &lab_cmd.index);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_lab_cmd__index_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_lab_cmd_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = __moca_set_lab_cmd(handle, &lab_cmd);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_get_host_pool_help( void )
{
   printf("Debug feature to obtain current Host pool settings.\n");

   printf("\nmocap get --host_pool\n");
}

MOCALIB_CLI_GET static int mocacli_get_host_pool_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_host_pool host_pool;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_host_pool_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&host_pool, 0, sizeof(host_pool));

      ret = moca_get_host_pool(handle, &host_pool);

      if (ret == 0) {
         mocacli_print_host_pool(&host_pool);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_force_handoff__nextNc_help(void)
{
   printf("nextNc:\n");
   printf("=======\n");
}

MOCALIB_CLI_HELP static void mocacli_force_handoff__nextBackup_help(void)
{
   printf("nextBackup:\n");
   printf("===========\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_set_force_handoff_help( void )
{
   printf("Debug feature to force an NC handoff operation.\n");

   printf("\nmocap set --force_handoff <options>\n");
   printf("options:\n");
   printf("   nextBackup   <uint32>\n");
   printf("   nextNc       <uint32>\n");
}

MOCALIB_CLI_SET static int mocacli_set_force_handoff_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_force_handoff force_handoff;

   memset(&force_handoff, 0, sizeof(force_handoff));

   force_handoff.nextBackup = MOCA_FORCE_HANDOFF_NEXTBACKUP_DEF;

   while ((ret == 0) && (num_parms > 0))
   {
      if (!strcmp(*pp_parms, "nextBackup"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_force_handoff__nextBackup_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &force_handoff.nextBackup);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_force_handoff__nextBackup_help();
               return(ret);
            }
         }
      }
      else if (!strcmp(*pp_parms, "nextNc"))
      {
         pp_parms++;
         num_parms--;

         if (num_parms == 0) continue;

         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_force_handoff__nextNc_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &force_handoff.nextNc);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_force_handoff__nextNc_help();
               return(ret);
            }
         }
      }
      else
      {
         mocacli_set_force_handoff_help();
         return(0);
      }

   }
   if (handle != NULL)
   {
      ret = moca_set_force_handoff(handle, &force_handoff);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_get_tpcap_capture_time_help( void )
{
   printf("This function returns the time of the burst that is captured\n");

   printf("\nmocap get --tpcap_capture_time\n");
}

MOCALIB_CLI_GET static int mocacli_get_tpcap_capture_time_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t tpcap_capture_time;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_tpcap_capture_time_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&tpcap_capture_time, 0, sizeof(tpcap_capture_time));

      ret = moca_get_tpcap_capture_time(handle, &tpcap_capture_time);

      if (ret == 0) {
         mocacli_print_tpcap_capture_time(&tpcap_capture_time);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_cir_data__node_help(void)
{
   printf("node:\n");
   printf("=====\n");
}

MOCALIB_CLI_HELP static void mocacli_get_cir_data_help( void )
{
   printf("This function returns the CIR data for the specified node. The parameter 'lab_mode' must be enabled.\n");

   printf("\nmocap get --cir_data <uint32 node>\n");
}

MOCALIB_CLI_GET static int mocacli_get_cir_data_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_cir_data cir_data;
   int found_node = 0;
   uint32_t node;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_cir_data_help();
      mocacli_cir_data__node_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_cir_data__node_help();
            pp_parms++;
            num_parms--;
            return(0);
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &node);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_cir_data__node_help();
               return(ret);
            }
            found_node = 1;
         }
   }

   if (!found_node)
   {
      printf("Missing node parameter.\n");
      return(0);
   }

   if (handle != NULL)
   {
      memset(&cir_data, 0, sizeof(cir_data));

      ret = __moca_get_cir_data(handle, node, &cir_data);

      if (ret == 0) {
         mocacli_print_cir_data(&cir_data);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_assert_restart__enable_help(void)
{
   printf("enable:\n");
   printf("=======\n");
   printf("Default:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_assert_restart_help( void )
{

   printf("\nmocap get --assert_restart\n");
}

MOCALIB_CLI_GET static int mocacli_get_assert_restart_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t assert_restart;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_assert_restart_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&assert_restart, 0, sizeof(assert_restart));

      ret = __moca_get_assert_restart(handle, &assert_restart);

      if (ret == 0) {
         mocacli_print_assert_restart(&assert_restart);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_assert_restart_help( void )
{

   printf("\nmocap set --assert_restart <uint32 enable>\n");
}

MOCALIB_CLI_SET static int mocacli_set_assert_restart_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t assert_restart;

   if (handle != NULL)
   {
      ret = __moca_get_assert_restart(handle, &assert_restart);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_assert_restart_help();
            mocacli_assert_restart__enable_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &assert_restart);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_assert_restart__enable_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_assert_restart(handle, assert_restart);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_moca_cpu_freq__hz_help(void)
{
   printf("hz:\n");
   printf("===\n");
   printf("\nValues:\n");
   printf("Frequency in MHz\n");
   printf("Default:\n");
   printf("0 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_moca_cpu_freq_help( void )
{
   printf("This parameter is used configure the MoCA CPU clock in certain chip types.\n");

   printf("\nmocap get --moca_cpu_freq\n");
}

MOCALIB_CLI_GET static int mocacli_get_moca_cpu_freq_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t moca_cpu_freq;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_moca_cpu_freq_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&moca_cpu_freq, 0, sizeof(moca_cpu_freq));

      ret = __moca_get_moca_cpu_freq(handle, &moca_cpu_freq);

      if (ret == 0) {
         mocacli_print_moca_cpu_freq(&moca_cpu_freq);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_moca_cpu_freq_help( void )
{
   printf("This parameter is used configure the MoCA CPU clock in certain chip types.\n");

   printf("\nmocap set --moca_cpu_freq <uint32 hz>\n");
}

MOCALIB_CLI_SET static int mocacli_set_moca_cpu_freq_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t moca_cpu_freq;

   if (handle != NULL)
   {
      ret = __moca_get_moca_cpu_freq(handle, &moca_cpu_freq);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_moca_cpu_freq_help();
            mocacli_moca_cpu_freq__hz_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &moca_cpu_freq);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_moca_cpu_freq__hz_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = __moca_set_moca_cpu_freq(handle, moca_cpu_freq);
   }

   return(ret);
}

MOCALIB_CLI_GET static int mocacli_get_lab_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   char **tmpPtr = pp_parms; 
   int nump = num_parms; 

   while (nump > 0)
   {
      if ((nump != 0) && !strcmp(*tmpPtr, "help"))
      {
         printf("The Lab group of parameters is used for internal testing only.\n");
         printf("IE list for this group: \n"); 
         printf("======================= \n"); 
         printf("lab_mode\n"); 
         printf("nc_mode\n"); 
         printf("rx_tx_packets_per_qm\n"); 
         printf("extra_rx_packets_per_qm\n"); 
         printf("target_phy_rate_20\n"); 
         printf("target_phy_rate_20_turbo\n"); 
         printf("turbo_en\n"); 
         printf("res1\n"); 
         printf("res2\n"); 
         printf("res3\n"); 
         printf("res4\n"); 
         printf("res5\n"); 
         printf("res6\n"); 
         printf("res7\n"); 
         printf("res8\n"); 
         printf("res9\n"); 
         printf("init1\n"); 
         printf("init2\n"); 
         printf("init3\n"); 
         printf("init4\n"); 
         printf("init5\n"); 
         printf("init6\n"); 
         printf("init7\n"); 
         printf("init8\n"); 
         printf("init9\n"); 
         printf("lab_snr_graph_set\n"); 
         printf("block_nack_rate\n"); 
         printf("res10\n"); 
         printf("res11\n"); 
         printf("res12\n"); 
         printf("res13\n"); 
         printf("res14\n"); 
         printf("res15\n"); 
         printf("res16\n"); 
         printf("res17\n"); 
         printf("res18\n"); 
         printf("res19\n"); 
         printf("res20\n"); 
         printf("target_phy_rate_20_turbo_vlper\n"); 
         printf("target_phy_rate_20_sec_ch\n"); 
         printf("target_phy_rate_20_turbo_sec_ch\n"); 
         printf("target_phy_rate_20_turbo_vlper_sec_ch\n"); 
         printf("cap_phy_rate_en\n"); 
         printf("cap_target_phy_rate\n"); 
         printf("cap_snr_base_margin\n"); 
         printf("map_capture\n"); 
         printf("lab_register\n"); 
         printf("lab_cmd\n"); 
         printf("host_pool\n"); 
         printf("tpcap_capture_time\n"); 
         printf("cir_data\n"); 
         printf("assert_restart\n"); 
         printf("moca_cpu_freq\n"); 
         return(0); 
      }
      tmpPtr++;
      nump--;
  }

   if (handle != NULL)
   {
      ret = mocacli_get_lab_mode_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_nc_mode_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_rx_tx_packets_per_qm_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_extra_rx_packets_per_qm_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_target_phy_rate_20_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_target_phy_rate_20_turbo_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_turbo_en_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_res1_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_res2_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_res3_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_res4_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_res5_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_res6_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_res7_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_res8_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_res9_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_init1_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_init2_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_init3_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_init4_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_init5_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_init6_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_init7_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_init8_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_init9_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_lab_snr_graph_set_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_block_nack_rate_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_res10_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_res11_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_res12_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_res13_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_res14_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_res15_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_res16_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_res17_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_res18_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_res19_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_res20_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_target_phy_rate_20_turbo_vlper_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_target_phy_rate_20_sec_ch_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_target_phy_rate_20_turbo_sec_ch_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_target_phy_rate_20_turbo_vlper_sec_ch_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_cap_phy_rate_en_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_cap_target_phy_rate_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_cap_snr_base_margin_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_map_capture_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_host_pool_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_tpcap_capture_time_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_assert_restart_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_moca_cpu_freq_handler(handle, pp_parms, num_parms );

   }
   return(ret);
}

MOCALIB_CLI_PRINT void mocacli_print_mps_en (uint32_t * in)
{
   printf("mps_en: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_mps_privacy_receive (uint32_t * in)
{
   printf("mps_privacy_receive: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_mps_privacy_down (uint32_t * in)
{
   printf("mps_privacy_down: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_mps_walk_time (uint32_t * in)
{
   printf("mps_walk_time: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_mps_unpaired_time (uint32_t * in)
{
   printf("mps_unpaired_time: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_mps_state (uint32_t * in)
{
   printf("mps_state: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_PRINT void mocacli_print_mps_init_scan_payload (struct moca_mps_init_scan_payload * in)
{
   uint32_t i;

   printf("== mps_init_scan_payload ");
   printf(" ============================= \n");
   printf("channel         : %2d - %d MHz\n", in->channel, in->channel * 25);
   printf("nc_moca_version : %u  ( 0x%x )\n", in->nc_moca_version, in->nc_moca_version);
   printf("mps_code        : %u  ( 0x%x )\n", in->mps_code, in->mps_code);
   printf("mps_parameters  : Privacy Enabled: %x Receive Privacy: %x Privacy Downgrade: %x;\n", (in->mps_parameters & 0x4), (in->mps_parameters & 0x2), (in->mps_parameters & 0x1));
   printf("network_name[16]: ");
   for (i = 0; i < 16; i++) {
      printf("%c", in->network_name[i]);
   }
   printf("\n");
   printf("== end mps_init_scan_payload ");
   printf(" ========================= \n\n");
}

MOCALIB_CLI_PRINT void mocacli_print_privacy_defaults (uint32_t * in)
{
   printf("privacy_defaults: %u  ( 0x%x )\n", *in, *in);
}

MOCALIB_CLI_HELP static void mocacli_mps_en__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 - Disabled\n");
   printf("1 - Enabled\n");
   printf("Default:\n");
   printf("1 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_mps_en_help( void )
{
   printf("Enable or disable MPS support on this node.\n");

   printf("\nmocap get --mps_en\n");
}

MOCALIB_CLI_GET static int mocacli_get_mps_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t mps_en;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_mps_en_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&mps_en, 0, sizeof(mps_en));

      ret = moca_get_mps_en(handle, &mps_en);

      if (ret == 0) {
         mocacli_print_mps_en(&mps_en);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_mps_en_help( void )
{
   printf("Enable or disable MPS support on this node.\n");

   printf("\nmocap set --mps_en <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_mps_en_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t mps_en;

   if (handle != NULL)
   {
      ret = moca_get_mps_en(handle, &mps_en);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_mps_en_help();
            mocacli_mps_en__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &mps_en);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_mps_en__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_mps_en(handle, mps_en);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_mps_privacy_receive__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 - Disabled\n");
   printf("1 - Enabled\n");
   printf("Default:\n");
   printf("1 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_mps_privacy_receive_help( void )
{
   printf("Controls whether the Node, during its MPS session, is allowed to accept\n");
   printf("privacy settings (Privacy Enabled / Disabled and Network Password) from another Node.\n");

   printf("\nmocap get --mps_privacy_receive\n");
}

MOCALIB_CLI_GET static int mocacli_get_mps_privacy_receive_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t mps_privacy_receive;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_mps_privacy_receive_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&mps_privacy_receive, 0, sizeof(mps_privacy_receive));

      ret = moca_get_mps_privacy_receive(handle, &mps_privacy_receive);

      if (ret == 0) {
         mocacli_print_mps_privacy_receive(&mps_privacy_receive);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_mps_privacy_receive_help( void )
{
   printf("Controls whether the Node, during its MPS session, is allowed to accept\n");
   printf("privacy settings (Privacy Enabled / Disabled and Network Password) from another Node.\n");

   printf("\nmocap set --mps_privacy_receive <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_mps_privacy_receive_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t mps_privacy_receive;

   if (handle != NULL)
   {
      ret = moca_get_mps_privacy_receive(handle, &mps_privacy_receive);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_mps_privacy_receive_help();
            mocacli_mps_privacy_receive__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &mps_privacy_receive);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_mps_privacy_receive__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_mps_privacy_receive(handle, mps_privacy_receive);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_mps_privacy_down__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 - Disabled\n");
   printf("1 - Enabled\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_mps_privacy_down_help( void )
{
   printf("Controls whether the Node, during its MPS session, is allowed to accept\n");
   printf(" privacy setting of Privacy Disabled from another Node when its own setting\n");
   printf("is Privacy Enabled. This parameter is valid only when mps_privacy_receive is Enabled.\n");

   printf("\nmocap get --mps_privacy_down\n");
}

MOCALIB_CLI_GET static int mocacli_get_mps_privacy_down_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t mps_privacy_down;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_mps_privacy_down_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&mps_privacy_down, 0, sizeof(mps_privacy_down));

      ret = moca_get_mps_privacy_down(handle, &mps_privacy_down);

      if (ret == 0) {
         mocacli_print_mps_privacy_down(&mps_privacy_down);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_mps_privacy_down_help( void )
{
   printf("Controls whether the Node, during its MPS session, is allowed to accept\n");
   printf(" privacy setting of Privacy Disabled from another Node when its own setting\n");
   printf("is Privacy Enabled. This parameter is valid only when mps_privacy_receive is Enabled.\n");

   printf("\nmocap set --mps_privacy_down <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_mps_privacy_down_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t mps_privacy_down;

   if (handle != NULL)
   {
      ret = moca_get_mps_privacy_down(handle, &mps_privacy_down);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_mps_privacy_down_help();
            mocacli_mps_privacy_down__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &mps_privacy_down);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_mps_privacy_down__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_mps_privacy_down(handle, mps_privacy_down);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_mps_walk_time__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("Walk time in seconds.\n");
   printf("Default:\n");
   printf("120 \n");
   printf("Minimum:\n");
   printf("12 \n");
   printf("Maximum:\n");
   printf("1200 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_mps_walk_time_help( void )
{
   printf("The allowed time interval to trigger MPS on two Nodes.\n");

   printf("\nmocap get --mps_walk_time\n");
}

MOCALIB_CLI_GET static int mocacli_get_mps_walk_time_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t mps_walk_time;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_mps_walk_time_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&mps_walk_time, 0, sizeof(mps_walk_time));

      ret = moca_get_mps_walk_time(handle, &mps_walk_time);

      if (ret == 0) {
         mocacli_print_mps_walk_time(&mps_walk_time);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_mps_walk_time_help( void )
{
   printf("The allowed time interval to trigger MPS on two Nodes.\n");

   printf("\nmocap set --mps_walk_time <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_mps_walk_time_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t mps_walk_time;

   if (handle != NULL)
   {
      ret = moca_get_mps_walk_time(handle, &mps_walk_time);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_mps_walk_time_help();
            mocacli_mps_walk_time__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &mps_walk_time);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_mps_walk_time__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_mps_walk_time(handle, mps_walk_time);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_mps_unpaired_time__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("Unpaired time in seconds.\n");
   printf("Default:\n");
   printf("300 \n");
   printf("Minimum:\n");
   printf("120 \n");
   printf("Maximum:\n");
   printf("7200 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_mps_unpaired_time_help( void )
{
   printf("The minimum time the Node is required to stay in the un-Paired state after it\n");
   printf("starts network search if the Node creates or joins a network without using MPS\n");

   printf("\nmocap get --mps_unpaired_time\n");
}

MOCALIB_CLI_GET static int mocacli_get_mps_unpaired_time_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t mps_unpaired_time;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_mps_unpaired_time_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&mps_unpaired_time, 0, sizeof(mps_unpaired_time));

      ret = moca_get_mps_unpaired_time(handle, &mps_unpaired_time);

      if (ret == 0) {
         mocacli_print_mps_unpaired_time(&mps_unpaired_time);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_mps_unpaired_time_help( void )
{
   printf("The minimum time the Node is required to stay in the un-Paired state after it\n");
   printf("starts network search if the Node creates or joins a network without using MPS\n");

   printf("\nmocap set --mps_unpaired_time <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_mps_unpaired_time_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t mps_unpaired_time;

   if (handle != NULL)
   {
      ret = moca_get_mps_unpaired_time(handle, &mps_unpaired_time);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_mps_unpaired_time_help();
            mocacli_mps_unpaired_time__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &mps_unpaired_time);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_mps_unpaired_time__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_mps_unpaired_time(handle, mps_unpaired_time);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_get_mps_state_help( void )
{
   printf("Reports the MPS state of the Node.\n");

   printf("\nmocap get --mps_state\n");
}

MOCALIB_CLI_GET static int mocacli_get_mps_state_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t mps_state;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_mps_state_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&mps_state, 0, sizeof(mps_state));

      ret = moca_get_mps_state(handle, &mps_state);

      if (ret == 0) {
         mocacli_print_mps_state(&mps_state);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_get_mps_init_scan_payload_help( void )
{
   printf("Reports the channel number, NC's MoCA version, Network MPS trigger, and Network \n");
   printf("MPS parameters (if any) of the latest MoCA network found during Initial MPS Scanning.\n");

   printf("\nmocap get --mps_init_scan_payload\n");
}

MOCALIB_CLI_GET static int mocacli_get_mps_init_scan_payload_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   struct moca_mps_init_scan_payload mps_init_scan_payload;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_mps_init_scan_payload_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&mps_init_scan_payload, 0, sizeof(mps_init_scan_payload));

      ret = moca_get_mps_init_scan_payload(handle, &mps_init_scan_payload);

      if (ret == 0) {
         mocacli_print_mps_init_scan_payload(&mps_init_scan_payload);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_mps_button_press_help( void )
{
   printf("When the MPS button is pressed, this function should be called to \n");
   printf("initiate the MPS protocol on this node.\n");

   printf("\nmocap set --mps_button_press\n");
}

MOCALIB_CLI_SET static int mocacli_set_mps_button_press_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;


   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_set_mps_button_press_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   if (handle != NULL)
   {
      ret = moca_set_mps_button_press(handle);
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_mps_reset_help( void )
{
   printf("Resets the MPS state of the node to unpaired and reinitialize \n");
   printf("MPS local variables and relevant parameters.\n");

   printf("\nmocap set --mps_reset\n");
}

MOCALIB_CLI_SET static int mocacli_set_mps_reset_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;


   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_set_mps_reset_help();
      pp_parms++;
      num_parms--;
      return(0);
   }
   if (handle != NULL)
   {
      ret = moca_set_mps_reset(handle);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_privacy_defaults__val_help(void)
{
   printf("val:\n");
   printf("====\n");
   printf("\nValues:\n");
   printf("0 - Legacy: Use Privacy Disabled and Password 99999999988888888\n");
   printf("1 - MPS: Use Privacy Enabled and a random Password\n");
   printf("Default:\n");
   printf("0 \n");
   printf("Minimum:\n");
   printf("0 \n");
   printf("Maximum:\n");
   printf("1 \n");
}

MOCALIB_CLI_HELP static void mocacli_get_privacy_defaults_help( void )
{
   printf("Sets which defaults should be used for Privacy settings\n");

   printf("\nmocap get --privacy_defaults\n");
}

MOCALIB_CLI_GET static int mocacli_get_privacy_defaults_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t privacy_defaults;

   if ((num_parms != 0) && !strcmp(*pp_parms, "help"))
   {
      mocacli_get_privacy_defaults_help();
      pp_parms++;
      num_parms--;
      return(0);
   }

   if (handle != NULL)
   {
      memset(&privacy_defaults, 0, sizeof(privacy_defaults));

      ret = moca_get_privacy_defaults(handle, &privacy_defaults);

      if (ret == 0) {
         mocacli_print_privacy_defaults(&privacy_defaults);
      } else {
         printf("Error %d\n", ret);
      }

   }
   return(ret);
}

MOCALIB_CLI_HELP static void mocacli_set_privacy_defaults_help( void )
{
   printf("Sets which defaults should be used for Privacy settings\n");

   printf("\nmocap set --privacy_defaults <uint32 val>\n");
}

MOCALIB_CLI_SET static int mocacli_set_privacy_defaults_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   uint32_t privacy_defaults;

   if (handle != NULL)
   {
      ret = moca_get_privacy_defaults(handle, &privacy_defaults);

      if (ret != 0)
         printf("Error %d\n", ret);
   }

   while ((ret == 0) && (num_parms > 0))
   {
         if (!strcmp(*pp_parms, "help"))
         {
            mocacli_set_privacy_defaults_help();
            mocacli_privacy_defaults__val_help();
            pp_parms++;
            num_parms--;

            if (num_parms == 0) continue;
         }
         else
         {
            ret = mocacli_get_uint32(*pp_parms, &privacy_defaults);
            pp_parms++;
            num_parms--;
            if (ret != 0)
            {
               mocacli_privacy_defaults__val_help();
               return(ret);
            }
         }
   }
   if (handle != NULL)
   {
      ret = moca_set_privacy_defaults(handle, privacy_defaults);

      gCheckinit = 1;
   }

   return(ret);
}

MOCALIB_CLI_GET static int mocacli_get_mps_handler( void * handle, char ** pp_parms, int num_parms )
{
   int ret = 0;
   char **tmpPtr = pp_parms; 
   int nump = num_parms; 

   while (nump > 0)
   {
      if ((nump != 0) && !strcmp(*tmpPtr, "help"))
      {
         printf("The MPS group of parameters is used for MoCA Protected Setup only.\n");
         printf("IE list for this group: \n"); 
         printf("======================= \n"); 
         printf("mps_en\n"); 
         printf("mps_privacy_receive\n"); 
         printf("mps_privacy_down\n"); 
         printf("mps_walk_time\n"); 
         printf("mps_unpaired_time\n"); 
         printf("mps_state\n"); 
         printf("mps_init_scan_payload\n"); 
         printf("privacy_defaults\n"); 
         return(0); 
      }
      tmpPtr++;
      nump--;
  }

   if (handle != NULL)
   {
      ret = mocacli_get_mps_en_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_mps_privacy_receive_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_mps_privacy_down_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_mps_walk_time_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_mps_unpaired_time_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_mps_state_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_mps_init_scan_payload_handler(handle, pp_parms, num_parms );

      ret = mocacli_get_privacy_defaults_handler(handle, pp_parms, num_parms );

   }
   return(ret);
}

#define NUM_GET_GROUP 11

#define NUM_GET_INITCFG 258

static struct handler_info get_initcfg[NUM_GET_INITCFG] = {
   {"--ac_cc_shift", mocacli_get_ac_cc_shift_handler, 0, 1, "phy"},
   {"--adc_mode", mocacli_get_adc_mode_handler, 1, 0, "phy"},
   {"--adm_stats", mocacli_get_adm_stats_handler, 0, 0, "network"},
   {"--aes_exchange_interval", mocacli_get_aes_exchange_interval_handler, 0, 1, "security"},
   {"--aes_mm_key", mocacli_get_aes_mm_key_handler, 1, 0, "security"},
   {"--aes_pm_key", mocacli_get_aes_pm_key_handler, 1, 0, "security"},
   {"--aes_pmk_initial_key", mocacli_get_aes_pmk_initial_key_handler, 1, 0, "security"},
   {"--agc_const_address", mocacli_get_agc_const_address_handler, 1, 0, "phy"},
   {"--agc_const_en", mocacli_get_agc_const_en_handler, 1, 0, "phy"},
   {"--aif_mode", mocacli_get_aif_mode_handler, 1, 0, "node"},
   {"--amp_reg", mocacli_get_amp_reg_handler, 0, 1, "phy"},
   {"--amp_type", mocacli_get_amp_type_handler, 1, 0, "node"},
   {"--arpl_th_100", mocacli_get_arpl_th_100_handler, 0, 1, "phy"},
   {"--arpl_th_50", mocacli_get_arpl_th_50_handler, 0, 1, "phy"},
   {"--assertText", mocacli_get_assertText_handler, 0, 1, "node"},
   {"--assert_restart", mocacli_get_assert_restart_handler, 0, 1, "lab"},
   {"--bad_probe_prints", mocacli_get_bad_probe_prints_handler, 0, 1, "debug"},
   {"--bandwidth", mocacli_get_bandwidth_handler, 1, 0, "phy"},
   {"--beacon_pwr_reduction", mocacli_get_beacon_pwr_reduction_handler, 1, 0, "phy"},
   {"--beacon_pwr_reduction_en", mocacli_get_beacon_pwr_reduction_en_handler, 1, 0, "phy"},
   {"--block_nack_rate", mocacli_get_block_nack_rate_handler, 0, 1, "lab"},
   {"--bo_mode", mocacli_get_bo_mode_handler, 1, 0, "phy"},
   {"--bonding", mocacli_get_bonding_handler, 1, 0, "node"},
   {"--brcmtag_enable", mocacli_get_brcmtag_enable_handler, 0, 1, "forwarding"},
   {"--c4_moca20_en", mocacli_get_c4_moca20_en_handler, 1, 0, "node"},
   {"--cap_phy_rate_en", mocacli_get_cap_phy_rate_en_handler, 1, 0, "lab"},
   {"--cap_snr_base_margin", mocacli_get_cap_snr_base_margin_handler, 1, 0, "lab"},
   {"--cap_target_phy_rate", mocacli_get_cap_target_phy_rate_handler, 1, 0, "lab"},
   {"--cir_data", mocacli_get_cir_data_handler, 0, 0, "lab"},
   {"--cir_prints", mocacli_get_cir_prints_handler, 0, 1, "debug"},
   {"--const_rx_submode", mocacli_get_const_rx_submode_handler, 1, 0, "debug"},
   {"--const_tx_params", mocacli_get_const_tx_params_handler, 1, 0, "debug"},
   {"--continuous_power_tx_mode", mocacli_get_continuous_power_tx_mode_handler, 1, 0, "node"},
   {"--continuous_rx_mode_attn", mocacli_get_continuous_rx_mode_attn_handler, 1, 0, "node"},
   {"--cp_const", mocacli_get_cp_const_handler, 0, 1, "phy"},
   {"--cp_margin_increase", mocacli_get_cp_margin_increase_handler, 0, 1, "phy"},
   {"--current_keys", mocacli_get_current_keys_handler, 0, 0, "security"},
   {"--dont_start_moca", mocacli_get_dont_start_moca_handler, 0, 1, "debug"},
   {"--drv_info", mocacli_get_drv_info_handler, 0, 0, "node"},
   {"--egr_mc_filter_en", mocacli_get_egr_mc_filter_en_handler, 1, 0, "forwarding"},
   {"--en_capable", mocacli_get_en_capable_handler, 0, 1, "node"},
   {"--error_stats", mocacli_get_error_stats_handler, 0, 0, "network"},
   {"--error_to_mask", mocacli_get_error_to_mask_handler, 0, 1, "debug"},
   {"--extra_rx_packets_per_qm", mocacli_get_extra_rx_packets_per_qm_handler, 0, 1, "lab"},
   {"--fc_mode", mocacli_get_fc_mode_handler, 1, 0, "forwarding"},
   {"--filter_m2_data_wakeUp", mocacli_get_filter_m2_data_wakeUp_handler, 0, 1, "power_mgmt"},
   {"--fragmentation", mocacli_get_fragmentation_handler, 0, 1, "mac_layer"},
   {"--freq_shift", mocacli_get_freq_shift_handler, 0, 1, "phy"},
   {"--fw_version", mocacli_get_fw_version_handler, 0, 0, "node"},
   {"--gen_node_ext_status", mocacli_get_gen_node_ext_status_handler, 0, 0, "network"},
   {"--gen_node_status", mocacli_get_gen_node_status_handler, 0, 0, "network"},
   {"--gen_stats", mocacli_get_gen_stats_handler, 0, 0, "intfc"},
   {"--host_pool", mocacli_get_host_pool_handler, 0, 0, "lab"},
   {"--host_qos", mocacli_get_host_qos_handler, 0, 1, "forwarding"},
   {"--if_access_en", mocacli_get_if_access_en_handler, 0, 1, "intfc"},
   {"--if_access_table", mocacli_get_if_access_table_handler, 0, 1, "intfc"},
   {"--ifg_moca20", mocacli_get_ifg_moca20_handler, 1, 0, "mac_layer"},
   {"--impedance_mode_bonding", mocacli_get_impedance_mode_bonding_handler, 1, 0, "node"},
   {"--init1", mocacli_get_init1_handler, 1, 0, "lab"},
   {"--init2", mocacli_get_init2_handler, 1, 0, "lab"},
   {"--init3", mocacli_get_init3_handler, 1, 0, "lab"},
   {"--init4", mocacli_get_init4_handler, 1, 0, "lab"},
   {"--init5", mocacli_get_init5_handler, 1, 0, "lab"},
   {"--init6", mocacli_get_init6_handler, 1, 0, "lab"},
   {"--init7", mocacli_get_init7_handler, 1, 0, "lab"},
   {"--init8", mocacli_get_init8_handler, 1, 0, "lab"},
   {"--init9", mocacli_get_init9_handler, 1, 0, "lab"},
   {"--interface_status", mocacli_get_interface_status_handler, 0, 0, "intfc"},
   {"--lab_cmd", mocacli_get_lab_cmd_handler, 0, 0, "lab"},
   {"--lab_mode", mocacli_get_lab_mode_handler, 1, 0, "lab"},
   {"--lab_register", mocacli_get_lab_register_handler, 0, 0, "lab"},
   {"--lab_snr_graph_set", mocacli_get_lab_snr_graph_set_handler, 0, 1, "lab"},
   {"--last_mr_events", mocacli_get_last_mr_events_handler, 0, 0, "network"},
   {"--last_ps_event_code", mocacli_get_last_ps_event_code_handler, 0, 0, "power_mgmt"},
   {"--led_mode", mocacli_get_led_mode_handler, 1, 0, "intfc"},
   {"--led_status", mocacli_get_led_status_handler, 0, 0, "debug"},
   {"--limit_traffic", mocacli_get_limit_traffic_handler, 1, 0, "node"},
   {"--listening_duration", mocacli_get_listening_duration_handler, 1, 0, "node"},
   {"--listening_freq_mask", mocacli_get_listening_freq_mask_handler, 1, 0, "node"},
   {"--lof", mocacli_get_lof_handler, 0, 1, "node"},
   {"--lof_update", mocacli_get_lof_update_handler, 0, 1, "node"},
   {"--loopback_en", mocacli_get_loopback_en_handler, 0, 1, "forwarding"},
   {"--low_pri_q_num", mocacli_get_low_pri_q_num_handler, 1, 0, "forwarding"},
   {"--m1_tx_power_variation", mocacli_get_m1_tx_power_variation_handler, 0, 1, "power_mgmt"},
   {"--mac_addr", mocacli_get_mac_addr_handler, 1, 0, "node"},
   {"--mac_aging", mocacli_get_mac_aging_handler, 0, 1, "forwarding"},
   {"--map_capture", mocacli_get_map_capture_handler, 0, 1, "lab"},
   {"--map_seed", mocacli_get_map_seed_handler, 1, 0, "mac_layer"},
   {"--max_constellation", mocacli_get_max_constellation_handler, 0, 1, "phy"},
   {"--max_constellation_all", mocacli_get_max_constellation_all_handler, 1, 0, "phy"},
   {"--max_frame_size", mocacli_get_max_frame_size_handler, 0, 1, "mac_layer"},
   {"--max_nbas_primary", mocacli_get_max_nbas_primary_handler, 1, 0, "node"},
   {"--max_nbas_secondary", mocacli_get_max_nbas_secondary_handler, 1, 0, "node"},
   {"--max_phy_rate", mocacli_get_max_phy_rate_handler, 0, 1, "phy"},
   {"--max_phy_rate_50M", mocacli_get_max_phy_rate_50M_handler, 0, 1, "phy"},
   {"--max_phy_rate_turbo", mocacli_get_max_phy_rate_turbo_handler, 0, 1, "phy"},
   {"--max_pkt_aggr", mocacli_get_max_pkt_aggr_handler, 0, 1, "mac_layer"},
   {"--max_pkt_aggr_bonding", mocacli_get_max_pkt_aggr_bonding_handler, 0, 1, "mac_layer"},
   {"--max_transmit_time", mocacli_get_max_transmit_time_handler, 0, 1, "mac_layer"},
   {"--max_tx_power", mocacli_get_max_tx_power_handler, 1, 0, "phy"},
   {"--max_tx_power_tune", mocacli_get_max_tx_power_tune_handler, 1, 0, "node"},
   {"--max_tx_power_tune_sec_ch", mocacli_get_max_tx_power_tune_sec_ch_handler, 1, 0, "node"},
   {"--mcfilter_enable", mocacli_get_mcfilter_enable_handler, 0, 1, "forwarding"},
   {"--mcfilter_table", mocacli_get_mcfilter_table_handler, 0, 0, "forwarding"},
   {"--mfc_th_increase", mocacli_get_mfc_th_increase_handler, 0, 1, "phy"},
   {"--min_bo_insert_2_bfm_lock", mocacli_get_min_bo_insert_2_bfm_lock_handler, 1, 0, "phy"},
   {"--min_bw_alarm_threshold", mocacli_get_min_bw_alarm_threshold_handler, 0, 1, "phy"},
   {"--min_snr_avg_db_2_bfm_lock", mocacli_get_min_snr_avg_db_2_bfm_lock_handler, 1, 0, "phy"},
   {"--mmk_key", mocacli_get_mmk_key_handler, 0, 0, "security"},
   {"--moca_core_trace_enable", mocacli_get_moca_core_trace_enable_handler, 0, 1, "debug"},
   {"--moca_cpu_freq", mocacli_get_moca_cpu_freq_handler, 0, 1, "lab"},
   {"--mocad_version", mocacli_get_mocad_version_handler, 0, 0, "node"},
   {"--mps_en", mocacli_get_mps_en_handler, 0, 1, "mps"},
   {"--mps_init_scan_payload", mocacli_get_mps_init_scan_payload_handler, 0, 0, "mps"},
   {"--mps_privacy_down", mocacli_get_mps_privacy_down_handler, 0, 1, "mps"},
   {"--mps_privacy_receive", mocacli_get_mps_privacy_receive_handler, 0, 1, "mps"},
   {"--mps_state", mocacli_get_mps_state_handler, 0, 0, "mps"},
   {"--mps_unpaired_time", mocacli_get_mps_unpaired_time_handler, 0, 1, "mps"},
   {"--mps_walk_time", mocacli_get_mps_walk_time_handler, 0, 1, "mps"},
   {"--mr_seq_num", mocacli_get_mr_seq_num_handler, 0, 1, "node"},
   {"--mtm_en", mocacli_get_mtm_en_handler, 1, 0, "debug"},
   {"--multicast_mode", mocacli_get_multicast_mode_handler, 1, 0, "forwarding"},
   {"--nc_heartbeat_interval", mocacli_get_nc_heartbeat_interval_handler, 1, 0, "power_mgmt"},
   {"--nc_listening_interval", mocacli_get_nc_listening_interval_handler, 1, 0, "power_mgmt"},
   {"--nc_mode", mocacli_get_nc_mode_handler, 1, 0, "lab"},
   {"--network_status", mocacli_get_network_status_handler, 0, 0, "network"},
   {"--node_power_state", mocacli_get_node_power_state_handler, 0, 0, "power_mgmt"},
   {"--node_stats", mocacli_get_node_stats_handler, 0, 0, "network"},
   {"--node_stats_ext", mocacli_get_node_stats_ext_handler, 0, 0, "network"},
   {"--node_status", mocacli_get_node_status_handler, 0, 0, "node"},
   {"--nv_cal_enable", mocacli_get_nv_cal_enable_handler, 0, 1, "phy"},
   {"--ofdma_assignment_table", mocacli_get_ofdma_assignment_table_handler, 0, 0, "network"},
   {"--ofdma_definition_table", mocacli_get_ofdma_definition_table_handler, 0, 0, "network"},
   {"--ofdma_en", mocacli_get_ofdma_en_handler, 1, 0, "phy"},
   {"--ooo_lmo_threshold", mocacli_get_ooo_lmo_threshold_handler, 0, 1, "network"},
   {"--orr_en", mocacli_get_orr_en_handler, 0, 1, "forwarding"},
   {"--otf_en", mocacli_get_otf_en_handler, 1, 0, "phy"},
   {"--password", mocacli_get_password_handler, 0, 1, "security"},
   {"--pause_fc_en", mocacli_get_pause_fc_en_handler, 0, 1, "forwarding"},
   {"--per_mode", mocacli_get_per_mode_handler, 0, 1, "forwarding"},
   {"--permanent_salt", mocacli_get_permanent_salt_handler, 0, 0, "security"},
   {"--phy_clock", mocacli_get_phy_clock_handler, 1, 0, "node"},
   {"--phy_status", mocacli_get_phy_status_handler, 0, 0, "phy"},
   {"--pm_restore_on_link_down", mocacli_get_pm_restore_on_link_down_handler, 0, 1, "power_mgmt"},
   {"--pmk_exchange_interval", mocacli_get_pmk_exchange_interval_handler, 0, 1, "security"},
   {"--pmk_initial_key", mocacli_get_pmk_initial_key_handler, 0, 0, "security"},
   {"--policing_en", mocacli_get_policing_en_handler, 0, 1, "forwarding"},
   {"--power_save_mechanism_dis", mocacli_get_power_save_mechanism_dis_handler, 0, 1, "node"},
   {"--power_state", mocacli_get_power_state_handler, 0, 0, "power_mgmt"},
   {"--power_state_capabilities", mocacli_get_power_state_capabilities_handler, 0, 0, "power_mgmt"},
   {"--pqos_egress_numflows", mocacli_get_pqos_egress_numflows_handler, 0, 0, "forwarding"},
   {"--pqos_max_packet_size", mocacli_get_pqos_max_packet_size_handler, 0, 1, "forwarding"},
   {"--preamble_uc_const", mocacli_get_preamble_uc_const_handler, 0, 1, "phy"},
   {"--preferred_nc", mocacli_get_preferred_nc_handler, 1, 0, "node"},
   {"--primary_ch_offset", mocacli_get_primary_ch_offset_handler, 1, 0, "node"},
   {"--priority_allocations", mocacli_get_priority_allocations_handler, 0, 1, "forwarding"},
   {"--privacy_defaults", mocacli_get_privacy_defaults_handler, 1, 0, "mps"},
   {"--privacy_en", mocacli_get_privacy_en_handler, 1, 0, "security"},
   {"--prof_pad_ctrl_deg_6802c0_bonding", mocacli_get_prof_pad_ctrl_deg_6802c0_bonding_handler, 1, 0, "node"},
   {"--prof_pad_ctrl_deg_6802c0_single", mocacli_get_prof_pad_ctrl_deg_6802c0_single_handler, 1, 0, "node"},
   {"--prop_bonding_compatibility_mode", mocacli_get_prop_bonding_compatibility_mode_handler, 1, 0, "node"},
   {"--ps_swch_rx1", mocacli_get_ps_swch_rx1_handler, 1, 0, "node"},
   {"--ps_swch_rx2", mocacli_get_ps_swch_rx2_handler, 1, 0, "node"},
   {"--ps_swch_rx3", mocacli_get_ps_swch_rx3_handler, 1, 0, "node"},
   {"--ps_swch_tx1", mocacli_get_ps_swch_tx1_handler, 1, 0, "node"},
   {"--ps_swch_tx2", mocacli_get_ps_swch_tx2_handler, 1, 0, "node"},
   {"--psm_config", mocacli_get_psm_config_handler, 1, 0, "node"},
   {"--qam256_capability", mocacli_get_qam256_capability_handler, 1, 0, "phy"},
   {"--rdeg_3450", mocacli_get_rdeg_3450_handler, 1, 0, "node"},
   {"--remote_man", mocacli_get_remote_man_handler, 1, 0, "node"},
   {"--res1", mocacli_get_res1_handler, 0, 1, "lab"},
   {"--res10", mocacli_get_res10_handler, 0, 1, "lab"},
   {"--res11", mocacli_get_res11_handler, 0, 1, "lab"},
   {"--res12", mocacli_get_res12_handler, 0, 1, "lab"},
   {"--res13", mocacli_get_res13_handler, 0, 1, "lab"},
   {"--res14", mocacli_get_res14_handler, 0, 1, "lab"},
   {"--res15", mocacli_get_res15_handler, 0, 1, "lab"},
   {"--res16", mocacli_get_res16_handler, 0, 1, "lab"},
   {"--res17", mocacli_get_res17_handler, 0, 1, "lab"},
   {"--res18", mocacli_get_res18_handler, 0, 1, "lab"},
   {"--res19", mocacli_get_res19_handler, 0, 1, "lab"},
   {"--res2", mocacli_get_res2_handler, 0, 1, "lab"},
   {"--res20", mocacli_get_res20_handler, 0, 1, "lab"},
   {"--res3", mocacli_get_res3_handler, 0, 1, "lab"},
   {"--res4", mocacli_get_res4_handler, 0, 1, "lab"},
   {"--res5", mocacli_get_res5_handler, 0, 1, "lab"},
   {"--res6", mocacli_get_res6_handler, 0, 1, "lab"},
   {"--res7", mocacli_get_res7_handler, 0, 1, "lab"},
   {"--res8", mocacli_get_res8_handler, 0, 1, "lab"},
   {"--res9", mocacli_get_res9_handler, 0, 1, "lab"},
   {"--rework_6802", mocacli_get_rework_6802_handler, 1, 0, "node"},
   {"--rf_band", mocacli_get_rf_band_handler, 1, 0, "intfc"},
   {"--rf_switch", mocacli_get_rf_switch_handler, 1, 0, "intfc"},
   {"--rlapm_cap_100", mocacli_get_rlapm_cap_100_handler, 0, 1, "phy"},
   {"--rlapm_cap_50", mocacli_get_rlapm_cap_50_handler, 0, 1, "phy"},
   {"--rlapm_en", mocacli_get_rlapm_en_handler, 0, 1, "phy"},
   {"--rlapm_table_100", mocacli_get_rlapm_table_100_handler, 0, 1, "phy"},
   {"--rlapm_table_50", mocacli_get_rlapm_table_50_handler, 0, 1, "phy"},
   {"--rtr_config", mocacli_get_rtr_config_handler, 0, 1, "mac_layer"},
   {"--rx_gain_agc_table", mocacli_get_rx_gain_agc_table_handler, 0, 0, "phy"},
   {"--rx_gain_params", mocacli_get_rx_gain_params_handler, 0, 0, "phy"},
   {"--rx_power_tune", mocacli_get_rx_power_tune_handler, 0, 1, "node"},
   {"--rx_tx_packets_per_qm", mocacli_get_rx_tx_packets_per_qm_handler, 0, 1, "lab"},
   {"--sapm_en", mocacli_get_sapm_en_handler, 0, 1, "phy"},
   {"--sapm_table_100", mocacli_get_sapm_table_100_handler, 0, 1, "phy"},
   {"--sapm_table_50", mocacli_get_sapm_table_50_handler, 0, 1, "phy"},
   {"--sapm_table_sec", mocacli_get_sapm_table_sec_handler, 0, 1, "phy"},
   {"--secondary_ch_offset", mocacli_get_secondary_ch_offset_handler, 1, 0, "node"},
   {"--selective_rr", mocacli_get_selective_rr_handler, 0, 1, "mac_layer"},
   {"--sigma2_prints", mocacli_get_sigma2_prints_handler, 0, 1, "debug"},
   {"--single_channel_operation", mocacli_get_single_channel_operation_handler, 1, 0, "node"},
   {"--snr_margin_ldpc", mocacli_get_snr_margin_ldpc_handler, 1, 0, "phy"},
   {"--snr_margin_ldpc_pre5", mocacli_get_snr_margin_ldpc_pre5_handler, 1, 0, "phy"},
   {"--snr_margin_ldpc_pri_ch", mocacli_get_snr_margin_ldpc_pri_ch_handler, 1, 0, "phy"},
   {"--snr_margin_ldpc_sec_ch", mocacli_get_snr_margin_ldpc_sec_ch_handler, 1, 0, "phy"},
   {"--snr_margin_ofdma", mocacli_get_snr_margin_ofdma_handler, 1, 0, "phy"},
   {"--snr_margin_pre5_pri_ch", mocacli_get_snr_margin_pre5_pri_ch_handler, 1, 0, "phy"},
   {"--snr_margin_pre5_sec_ch", mocacli_get_snr_margin_pre5_sec_ch_handler, 1, 0, "phy"},
   {"--snr_margin_rs", mocacli_get_snr_margin_rs_handler, 1, 0, "phy"},
   {"--snr_margin_table_ldpc", mocacli_get_snr_margin_table_ldpc_handler, 1, 0, "phy"},
   {"--snr_margin_table_ldpc_pre5", mocacli_get_snr_margin_table_ldpc_pre5_handler, 1, 0, "phy"},
   {"--snr_margin_table_ldpc_pri_ch", mocacli_get_snr_margin_table_ldpc_pri_ch_handler, 1, 0, "phy"},
   {"--snr_margin_table_ldpc_sec_ch", mocacli_get_snr_margin_table_ldpc_sec_ch_handler, 1, 0, "phy"},
   {"--snr_margin_table_ofdma", mocacli_get_snr_margin_table_ofdma_handler, 1, 0, "phy"},
   {"--snr_margin_table_pre5_pri_ch", mocacli_get_snr_margin_table_pre5_pri_ch_handler, 1, 0, "phy"},
   {"--snr_margin_table_pre5_sec_ch", mocacli_get_snr_margin_table_pre5_sec_ch_handler, 1, 0, "phy"},
   {"--snr_margin_table_rs", mocacli_get_snr_margin_table_rs_handler, 1, 0, "phy"},
   {"--snr_prints", mocacli_get_snr_prints_handler, 0, 1, "debug"},
   {"--src_addr", mocacli_get_src_addr_handler, 0, 0, "forwarding"},
   {"--stag_priority", mocacli_get_stag_priority_handler, 0, 1, "forwarding"},
   {"--stag_removal", mocacli_get_stag_removal_handler, 0, 1, "forwarding"},
   {"--standby_power_state", mocacli_get_standby_power_state_handler, 0, 1, "power_mgmt"},
   {"--star_topology_en", mocacli_get_star_topology_en_handler, 1, 0, "phy"},
   {"--start_ulmo", mocacli_get_start_ulmo_handler, 0, 1, "network"},
   {"--taboo_channels", mocacli_get_taboo_channels_handler, 1, 0, "network"},
   {"--target_phy_rate_20", mocacli_get_target_phy_rate_20_handler, 0, 1, "lab"},
   {"--target_phy_rate_20_sec_ch", mocacli_get_target_phy_rate_20_sec_ch_handler, 0, 1, "lab"},
   {"--target_phy_rate_20_turbo", mocacli_get_target_phy_rate_20_turbo_handler, 0, 1, "lab"},
   {"--target_phy_rate_20_turbo_sec_ch", mocacli_get_target_phy_rate_20_turbo_sec_ch_handler, 0, 1, "lab"},
   {"--target_phy_rate_20_turbo_vlper", mocacli_get_target_phy_rate_20_turbo_vlper_handler, 0, 1, "lab"},
   {"--target_phy_rate_20_turbo_vlper_sec_ch", mocacli_get_target_phy_rate_20_turbo_vlper_sec_ch_handler, 0, 1, "lab"},
   {"--target_phy_rate_qam128", mocacli_get_target_phy_rate_qam128_handler, 0, 1, "phy"},
   {"--target_phy_rate_qam256", mocacli_get_target_phy_rate_qam256_handler, 0, 1, "phy"},
   {"--tek_exchange_interval", mocacli_get_tek_exchange_interval_handler, 0, 1, "security"},
   {"--tlp_mode", mocacli_get_tlp_mode_handler, 0, 1, "mac_layer"},
   {"--tpc_en", mocacli_get_tpc_en_handler, 1, 0, "phy"},
   {"--tpcap_capture_time", mocacli_get_tpcap_capture_time_handler, 0, 0, "lab"},
   {"--turbo_en", mocacli_get_turbo_en_handler, 1, 0, "lab"},
   {"--tx_power_params", mocacli_get_tx_power_params_handler, 0, 0, "phy"},
   {"--uc_fwd", mocacli_get_uc_fwd_handler, 0, 0, "forwarding"},
   {"--use_ext_data_mem", mocacli_get_use_ext_data_mem_handler, 1, 0, "node"},
   {"--verbose", mocacli_get_verbose_handler, 0, 1, "debug"},
   {"--wdog_enable", mocacli_get_wdog_enable_handler, 0, 1, "node"},
   {"--wom_ip", mocacli_get_wom_ip_handler, 0, 0, "power_mgmt"},
   {"--wom_magic_enable", mocacli_get_wom_magic_enable_handler, 0, 1, "power_mgmt"},
   {"--wom_magic_mac", mocacli_get_wom_magic_mac_handler, 0, 1, "power_mgmt"},
   {"--wom_mode", mocacli_get_wom_mode_handler, 0, 1, "power_mgmt"},
   {"--wom_pattern", mocacli_get_wom_pattern_handler, 0, 0, "power_mgmt"},
};

static struct handler_entry getgrp_options[NUM_GET_GROUP] = {
   {"debug", NULL, mocacli_get_debug_handler, NULL, NULL},
   {"forwarding", NULL, mocacli_get_forwarding_handler, NULL, NULL},
   {"intfc", NULL, mocacli_get_intfc_handler, NULL, NULL},
   {"lab", NULL, mocacli_get_lab_handler, NULL, NULL},
   {"mac_layer", NULL, mocacli_get_mac_layer_handler, NULL, NULL},
   {"mps", NULL, mocacli_get_mps_handler, NULL, NULL},
   {"network", NULL, mocacli_get_network_handler, NULL, NULL},
   {"node", NULL, mocacli_get_node_handler, NULL, NULL},
   {"phy", NULL, mocacli_get_phy_handler, NULL, NULL},
   {"power_mgmt", NULL, mocacli_get_power_mgmt_handler, NULL, NULL},
   {"security", NULL, mocacli_get_security_handler, NULL, NULL},
};

#define NUM_CLI_OPTIONS 301

static struct handler_entry cli_options[NUM_CLI_OPTIONS] = {
   {"--ac_cc_shift", NULL, mocacli_get_ac_cc_shift_handler, mocacli_set_ac_cc_shift_handler, NULL },
   {"--aca", NULL, NULL, NULL, mocacli_do_aca_handler },
   {"--adc_mode", NULL, mocacli_get_adc_mode_handler, mocacli_set_adc_mode_handler, NULL },
   {"--adm_stats", NULL, mocacli_get_adm_stats_handler, NULL, NULL },
   {"--aes_exchange_interval", NULL, mocacli_get_aes_exchange_interval_handler, mocacli_set_aes_exchange_interval_handler, NULL },
   {"--aes_mm_key", NULL, mocacli_get_aes_mm_key_handler, mocacli_set_aes_mm_key_handler, NULL },
   {"--aes_pm_key", NULL, mocacli_get_aes_pm_key_handler, mocacli_set_aes_pm_key_handler, NULL },
   {"--aes_pmk_initial_key", NULL, mocacli_get_aes_pmk_initial_key_handler, mocacli_set_aes_pmk_initial_key_handler, NULL },
   {"--agc_const_address", NULL, mocacli_get_agc_const_address_handler, mocacli_set_agc_const_address_handler, NULL },
   {"--agc_const_en", NULL, mocacli_get_agc_const_en_handler, mocacli_set_agc_const_en_handler, NULL },
   {"--aif_mode", NULL, mocacli_get_aif_mode_handler, mocacli_set_aif_mode_handler, NULL },
   {"--amp_reg", NULL, mocacli_get_amp_reg_handler, mocacli_set_amp_reg_handler, NULL },
   {"--amp_type", NULL, mocacli_get_amp_type_handler, mocacli_set_amp_type_handler, NULL },
   {"--arpl_th_100", NULL, mocacli_get_arpl_th_100_handler, mocacli_set_arpl_th_100_handler, NULL },
   {"--arpl_th_50", NULL, mocacli_get_arpl_th_50_handler, mocacli_set_arpl_th_50_handler, NULL },
   {"--assertText", NULL, mocacli_get_assertText_handler, mocacli_set_assertText_handler, NULL },
   {"--assert_restart", NULL, mocacli_get_assert_restart_handler, mocacli_set_assert_restart_handler, NULL },
   {"--bad_probe_prints", NULL, mocacli_get_bad_probe_prints_handler, mocacli_set_bad_probe_prints_handler, NULL },
   {"--bandwidth", "--bw", mocacli_get_bandwidth_handler, mocacli_set_bandwidth_handler, NULL },
   {"--beacon_channel_set", NULL, NULL, mocacli_set_beacon_channel_set_handler, NULL },
   {"--beacon_pwr_reduction", NULL, mocacli_get_beacon_pwr_reduction_handler, mocacli_set_beacon_pwr_reduction_handler, NULL },
   {"--beacon_pwr_reduction_en", NULL, mocacli_get_beacon_pwr_reduction_en_handler, mocacli_set_beacon_pwr_reduction_en_handler, NULL },
   {"--block_nack_rate", NULL, mocacli_get_block_nack_rate_handler, mocacli_set_block_nack_rate_handler, NULL },
   {"--bo_mode", NULL, mocacli_get_bo_mode_handler, mocacli_set_bo_mode_handler, NULL },
   {"--bonding", NULL, mocacli_get_bonding_handler, mocacli_set_bonding_handler, NULL },
   {"--brcmtag_enable", NULL, mocacli_get_brcmtag_enable_handler, mocacli_set_brcmtag_enable_handler, NULL },
   {"--c4_moca20_en", NULL, mocacli_get_c4_moca20_en_handler, mocacli_set_c4_moca20_en_handler, NULL },
   {"--cap_phy_rate_en", NULL, mocacli_get_cap_phy_rate_en_handler, mocacli_set_cap_phy_rate_en_handler, NULL },
   {"--cap_snr_base_margin", NULL, mocacli_get_cap_snr_base_margin_handler, mocacli_set_cap_snr_base_margin_handler, NULL },
   {"--cap_target_phy_rate", NULL, mocacli_get_cap_target_phy_rate_handler, mocacli_set_cap_target_phy_rate_handler, NULL },
   {"--cir_data", NULL, mocacli_get_cir_data_handler, NULL, NULL },
   {"--cir_prints", NULL, mocacli_get_cir_prints_handler, mocacli_set_cir_prints_handler, NULL },
   {"--cof", NULL, NULL, mocacli_set_cof_handler, NULL },
   {"--config", NULL, mocacli_get_config_handler, NULL, NULL },
   {"--const_rx_submode", NULL, mocacli_get_const_rx_submode_handler, mocacli_set_const_rx_submode_handler, NULL },
   {"--const_tx_params", "--ctxparms", mocacli_get_const_tx_params_handler, mocacli_set_const_tx_params_handler, NULL },
   {"--continuous_power_tx_mode", "--ctx", mocacli_get_continuous_power_tx_mode_handler, mocacli_set_continuous_power_tx_mode_handler, NULL },
   {"--continuous_rx_mode_attn", NULL, mocacli_get_continuous_rx_mode_attn_handler, mocacli_set_continuous_rx_mode_attn_handler, NULL },
   {"--cp_const", NULL, mocacli_get_cp_const_handler, mocacli_set_cp_const_handler, NULL },
   {"--cp_margin_increase", NULL, mocacli_get_cp_margin_increase_handler, mocacli_set_cp_margin_increase_handler, NULL },
   {"--cplength", NULL, NULL, mocacli_set_cplength_handler, NULL },
   {"--current_keys", "--keys", mocacli_get_current_keys_handler, NULL, NULL },
   {"--dd_init", "--dd", NULL, NULL, mocacli_do_dd_init_handler },
   {"--dont_start_moca", NULL, mocacli_get_dont_start_moca_handler, mocacli_set_dont_start_moca_handler, NULL },
   {"--drv_info", NULL, mocacli_get_drv_info_handler, NULL, NULL },
   {"--egr_mc_addr_filter", NULL, NULL, mocacli_set_egr_mc_addr_filter_handler, NULL },
   {"--egr_mc_filter_en", NULL, mocacli_get_egr_mc_filter_en_handler, mocacli_set_egr_mc_filter_en_handler, NULL },
   {"--en_capable", NULL, mocacli_get_en_capable_handler, mocacli_set_en_capable_handler, NULL },
   {"--error_stats", "--errors", mocacli_get_error_stats_handler, NULL, NULL },
   {"--error_to_mask", NULL, mocacli_get_error_to_mask_handler, mocacli_set_error_to_mask_handler, NULL },
   {"--extra_rx_packets_per_qm", NULL, mocacli_get_extra_rx_packets_per_qm_handler, mocacli_set_extra_rx_packets_per_qm_handler, NULL },
   {"--fc_mode", NULL, mocacli_get_fc_mode_handler, mocacli_set_fc_mode_handler, NULL },
   {"--filter_m2_data_wakeUp", NULL, mocacli_get_filter_m2_data_wakeUp_handler, mocacli_set_filter_m2_data_wakeUp_handler, NULL },
   {"--fmr_20", NULL, NULL, NULL, mocacli_do_fmr_20_handler },
   {"--fmr_init", NULL, NULL, NULL, mocacli_do_fmr_init_handler },
   {"--force_handoff", NULL, NULL, mocacli_set_force_handoff_handler, NULL },
   {"--fragmentation", NULL, mocacli_get_fragmentation_handler, mocacli_set_fragmentation_handler, NULL },
   {"--freq_shift", NULL, mocacli_get_freq_shift_handler, mocacli_set_freq_shift_handler, NULL },
   {"--fw_version", NULL, mocacli_get_fw_version_handler, NULL, NULL },
   {"--gen_node_ext_status", "--nodephy", mocacli_get_gen_node_ext_status_handler, NULL, NULL },
   {"--gen_node_status", "--nodeinfo", mocacli_get_gen_node_status_handler, NULL, NULL },
   {"--gen_stats", "--stats", mocacli_get_gen_stats_handler, NULL, NULL },
   {"--gmii_trap_header", NULL, NULL, mocacli_set_gmii_trap_header_handler, NULL },
   {"--group", NULL, mocacli_get_group_handler, NULL, NULL },
   {"--groupall", NULL, mocacli_get_groupall_handler, NULL, NULL },
   {"--host_pool", NULL, mocacli_get_host_pool_handler, NULL, NULL },
   {"--host_qos", NULL, mocacli_get_host_qos_handler, mocacli_set_host_qos_handler, NULL },
   {"--hostless_mode", NULL, NULL, NULL, mocacli_do_hostless_mode_handler },
   {"--if_access_en", NULL, mocacli_get_if_access_en_handler, mocacli_set_if_access_en_handler, NULL },
   {"--if_access_table", NULL, mocacli_get_if_access_table_handler, mocacli_set_if_access_table_handler, NULL },
   {"--ifg_moca20", NULL, mocacli_get_ifg_moca20_handler, mocacli_set_ifg_moca20_handler, NULL },
   {"--impedance_mode_bonding", NULL, mocacli_get_impedance_mode_bonding_handler, mocacli_set_impedance_mode_bonding_handler, NULL },
   {"--init", NULL, mocacli_get_init_handler, NULL, NULL },
   {"--init1", NULL, mocacli_get_init1_handler, mocacli_set_init1_handler, NULL },
   {"--init2", NULL, mocacli_get_init2_handler, mocacli_set_init2_handler, NULL },
   {"--init3", NULL, mocacli_get_init3_handler, mocacli_set_init3_handler, NULL },
   {"--init4", NULL, mocacli_get_init4_handler, mocacli_set_init4_handler, NULL },
   {"--init5", NULL, mocacli_get_init5_handler, mocacli_set_init5_handler, NULL },
   {"--init6", NULL, mocacli_get_init6_handler, mocacli_set_init6_handler, NULL },
   {"--init7", NULL, mocacli_get_init7_handler, mocacli_set_init7_handler, NULL },
   {"--init8", NULL, mocacli_get_init8_handler, mocacli_set_init8_handler, NULL },
   {"--init9", NULL, mocacli_get_init9_handler, mocacli_set_init9_handler, NULL },
   {"--interface_status", "--link", mocacli_get_interface_status_handler, NULL, NULL },
   {"--lab_cmd", NULL, mocacli_get_lab_cmd_handler, mocacli_set_lab_cmd_handler, NULL },
   {"--lab_iq_diagram_set", NULL, NULL, mocacli_set_lab_iq_diagram_set_handler, NULL },
   {"--lab_mode", NULL, mocacli_get_lab_mode_handler, mocacli_set_lab_mode_handler, NULL },
   {"--lab_register", NULL, mocacli_get_lab_register_handler, mocacli_set_lab_register_handler, NULL },
   {"--lab_snr_graph_set", NULL, mocacli_get_lab_snr_graph_set_handler, mocacli_set_lab_snr_graph_set_handler, NULL },
   {"--last_mr_events", NULL, mocacli_get_last_mr_events_handler, NULL, NULL },
   {"--last_ps_event_code", NULL, mocacli_get_last_ps_event_code_handler, NULL, NULL },
   {"--led_mode", NULL, mocacli_get_led_mode_handler, mocacli_set_led_mode_handler, NULL },
   {"--led_status", NULL, mocacli_get_led_status_handler, NULL, NULL },
   {"--limit_traffic", NULL, mocacli_get_limit_traffic_handler, mocacli_set_limit_traffic_handler, NULL },
   {"--listening_duration", NULL, mocacli_get_listening_duration_handler, mocacli_set_listening_duration_handler, NULL },
   {"--listening_freq_mask", "--freq_mask", mocacli_get_listening_freq_mask_handler, mocacli_set_listening_freq_mask_handler, NULL },
   {"--lof", NULL, mocacli_get_lof_handler, mocacli_set_lof_handler, NULL },
   {"--lof_update", NULL, mocacli_get_lof_update_handler, mocacli_set_lof_update_handler, NULL },
   {"--loopback_en", NULL, mocacli_get_loopback_en_handler, mocacli_set_loopback_en_handler, NULL },
   {"--low_pri_q_num", NULL, mocacli_get_low_pri_q_num_handler, mocacli_set_low_pri_q_num_handler, NULL },
   {"--m1_tx_power_variation", NULL, mocacli_get_m1_tx_power_variation_handler, mocacli_set_m1_tx_power_variation_handler, NULL },
   {"--mac_addr", NULL, mocacli_get_mac_addr_handler, mocacli_set_mac_addr_handler, NULL },
   {"--mac_aging", NULL, mocacli_get_mac_aging_handler, mocacli_set_mac_aging_handler, NULL },
   {"--map_capture", NULL, mocacli_get_map_capture_handler, mocacli_set_map_capture_handler, NULL },
   {"--map_seed", NULL, mocacli_get_map_seed_handler, mocacli_set_map_seed_handler, NULL },
   {"--max_constellation", NULL, mocacli_get_max_constellation_handler, mocacli_set_max_constellation_handler, NULL },
   {"--max_constellation_all", NULL, mocacli_get_max_constellation_all_handler, mocacli_set_max_constellation_all_handler, NULL },
   {"--max_frame_size", NULL, mocacli_get_max_frame_size_handler, mocacli_set_max_frame_size_handler, NULL },
   {"--max_nbas_primary", "--max_nbas_pri_ch", mocacli_get_max_nbas_primary_handler, mocacli_set_max_nbas_primary_handler, NULL },
   {"--max_nbas_secondary", "--max_nbas_sec_ch", mocacli_get_max_nbas_secondary_handler, mocacli_set_max_nbas_secondary_handler, NULL },
   {"--max_phy_rate", NULL, mocacli_get_max_phy_rate_handler, mocacli_set_max_phy_rate_handler, NULL },
   {"--max_phy_rate_50M", NULL, mocacli_get_max_phy_rate_50M_handler, mocacli_set_max_phy_rate_50M_handler, NULL },
   {"--max_phy_rate_turbo", NULL, mocacli_get_max_phy_rate_turbo_handler, mocacli_set_max_phy_rate_turbo_handler, NULL },
   {"--max_pkt_aggr", NULL, mocacli_get_max_pkt_aggr_handler, mocacli_set_max_pkt_aggr_handler, NULL },
   {"--max_pkt_aggr_bonding", NULL, mocacli_get_max_pkt_aggr_bonding_handler, mocacli_set_max_pkt_aggr_bonding_handler, NULL },
   {"--max_transmit_time", NULL, mocacli_get_max_transmit_time_handler, mocacli_set_max_transmit_time_handler, NULL },
   {"--max_tx_power", NULL, mocacli_get_max_tx_power_handler, mocacli_set_max_tx_power_handler, NULL },
   {"--max_tx_power_tune", NULL, mocacli_get_max_tx_power_tune_handler, mocacli_set_max_tx_power_tune_handler, NULL },
   {"--max_tx_power_tune_sec_ch", NULL, mocacli_get_max_tx_power_tune_sec_ch_handler, mocacli_set_max_tx_power_tune_sec_ch_handler, NULL },
   {"--mcfilter_addentry", NULL, NULL, mocacli_set_mcfilter_addentry_handler, NULL },
   {"--mcfilter_clear_table", NULL, NULL, mocacli_set_mcfilter_clear_table_handler, NULL },
   {"--mcfilter_delentry", NULL, NULL, mocacli_set_mcfilter_delentry_handler, NULL },
   {"--mcfilter_enable", NULL, mocacli_get_mcfilter_enable_handler, mocacli_set_mcfilter_enable_handler, NULL },
   {"--mcfilter_table", NULL, mocacli_get_mcfilter_table_handler, NULL, NULL },
   {"--mfc_th_increase", NULL, mocacli_get_mfc_th_increase_handler, mocacli_set_mfc_th_increase_handler, NULL },
   {"--min_bo_insert_2_bfm_lock", NULL, mocacli_get_min_bo_insert_2_bfm_lock_handler, mocacli_set_min_bo_insert_2_bfm_lock_handler, NULL },
   {"--min_bw_alarm_threshold", NULL, mocacli_get_min_bw_alarm_threshold_handler, mocacli_set_min_bw_alarm_threshold_handler, NULL },
   {"--min_snr_avg_db_2_bfm_lock", NULL, mocacli_get_min_snr_avg_db_2_bfm_lock_handler, mocacli_set_min_snr_avg_db_2_bfm_lock_handler, NULL },
   {"--mmk_key", NULL, mocacli_get_mmk_key_handler, NULL, NULL },
   {"--moca_core_trace_enable", "--trace", mocacli_get_moca_core_trace_enable_handler, mocacli_set_moca_core_trace_enable_handler, NULL },
   {"--moca_cpu_freq", NULL, mocacli_get_moca_cpu_freq_handler, mocacli_set_moca_cpu_freq_handler, NULL },
   {"--moca_reset", "--mr", NULL, NULL, mocacli_do_moca_reset_handler },
   {"--mocad_forwarding_rx_mac", NULL, NULL, mocacli_set_mocad_forwarding_rx_mac_handler, NULL },
   {"--mocad_printf", NULL, NULL, NULL, mocacli_do_mocad_printf_handler },
   {"--mocad_version", NULL, mocacli_get_mocad_version_handler, NULL, NULL },
   {"--mps_button_press", NULL, NULL, mocacli_set_mps_button_press_handler, NULL },
   {"--mps_en", NULL, mocacli_get_mps_en_handler, mocacli_set_mps_en_handler, NULL },
   {"--mps_init_scan_payload", NULL, mocacli_get_mps_init_scan_payload_handler, NULL, NULL },
   {"--mps_privacy_down", NULL, mocacli_get_mps_privacy_down_handler, mocacli_set_mps_privacy_down_handler, NULL },
   {"--mps_privacy_receive", NULL, mocacli_get_mps_privacy_receive_handler, mocacli_set_mps_privacy_receive_handler, NULL },
   {"--mps_reset", NULL, NULL, mocacli_set_mps_reset_handler, NULL },
   {"--mps_state", NULL, mocacli_get_mps_state_handler, NULL, NULL },
   {"--mps_unpaired_time", NULL, mocacli_get_mps_unpaired_time_handler, mocacli_set_mps_unpaired_time_handler, NULL },
   {"--mps_walk_time", NULL, mocacli_get_mps_walk_time_handler, mocacli_set_mps_walk_time_handler, NULL },
   {"--mr_seq_num", NULL, mocacli_get_mr_seq_num_handler, mocacli_set_mr_seq_num_handler, NULL },
   {"--mtm_en", NULL, mocacli_get_mtm_en_handler, mocacli_set_mtm_en_handler, NULL },
   {"--multicast_mode", NULL, mocacli_get_multicast_mode_handler, mocacli_set_multicast_mode_handler, NULL },
   {"--nc_heartbeat_interval", NULL, mocacli_get_nc_heartbeat_interval_handler, mocacli_set_nc_heartbeat_interval_handler, NULL },
   {"--nc_listening_interval", NULL, mocacli_get_nc_listening_interval_handler, mocacli_set_nc_listening_interval_handler, NULL },
   {"--nc_mode", NULL, mocacli_get_nc_mode_handler, mocacli_set_nc_mode_handler, NULL },
   {"--network_status", "--net", mocacli_get_network_status_handler, NULL, NULL },
   {"--no_rtt", NULL, NULL, mocacli_set_no_rtt_handler, NULL },
   {"--node_power_state", NULL, mocacli_get_node_power_state_handler, NULL, NULL },
   {"--node_stats", NULL, mocacli_get_node_stats_handler, NULL, NULL },
   {"--node_stats_ext", NULL, mocacli_get_node_stats_ext_handler, NULL, NULL },
   {"--node_status", NULL, mocacli_get_node_status_handler, NULL, NULL },
   {"--nv_cal_clear", NULL, NULL, mocacli_set_nv_cal_clear_handler, NULL },
   {"--nv_cal_enable", NULL, mocacli_get_nv_cal_enable_handler, mocacli_set_nv_cal_enable_handler, NULL },
   {"--nvram", NULL, mocacli_get_nvram_handler, NULL, NULL },
   {"--ofdma_assignment_table", NULL, mocacli_get_ofdma_assignment_table_handler, NULL, NULL },
   {"--ofdma_definition_table", NULL, mocacli_get_ofdma_definition_table_handler, NULL, NULL },
   {"--ofdma_en", NULL, mocacli_get_ofdma_en_handler, mocacli_set_ofdma_en_handler, NULL },
   {"--ooo_lmo", NULL, NULL, mocacli_set_ooo_lmo_handler, NULL },
   {"--ooo_lmo_threshold", NULL, mocacli_get_ooo_lmo_threshold_handler, mocacli_set_ooo_lmo_threshold_handler, NULL },
   {"--orr_en", NULL, mocacli_get_orr_en_handler, mocacli_set_orr_en_handler, NULL },
   {"--otf_en", NULL, mocacli_get_otf_en_handler, mocacli_set_otf_en_handler, NULL },
   {"--password", NULL, mocacli_get_password_handler, mocacli_set_password_handler, NULL },
   {"--pause_fc_en", NULL, mocacli_get_pause_fc_en_handler, mocacli_set_pause_fc_en_handler, NULL },
   {"--per_mode", NULL, mocacli_get_per_mode_handler, mocacli_set_per_mode_handler, NULL },
   {"--permanent_salt", NULL, mocacli_get_permanent_salt_handler, NULL, NULL },
   {"--phy_clock", NULL, mocacli_get_phy_clock_handler, mocacli_set_phy_clock_handler, NULL },
   {"--phy_status", NULL, mocacli_get_phy_status_handler, NULL, NULL },
   {"--pm_restore_on_link_down", NULL, mocacli_get_pm_restore_on_link_down_handler, mocacli_set_pm_restore_on_link_down_handler, NULL },
   {"--pmk_exchange_interval", NULL, mocacli_get_pmk_exchange_interval_handler, mocacli_set_pmk_exchange_interval_handler, NULL },
   {"--pmk_initial_key", NULL, mocacli_get_pmk_initial_key_handler, NULL, NULL },
   {"--policing_en", NULL, mocacli_get_policing_en_handler, mocacli_set_policing_en_handler, NULL },
   {"--power_save_mechanism_dis", "--psm_dis", mocacli_get_power_save_mechanism_dis_handler, mocacli_set_power_save_mechanism_dis_handler, NULL },
   {"--power_state", NULL, mocacli_get_power_state_handler, NULL, NULL },
   {"--power_state_capabilities", NULL, mocacli_get_power_state_capabilities_handler, NULL, NULL },
   {"--pqos_create_flow", "--pqosc", NULL, NULL, mocacli_do_pqos_create_flow_handler },
   {"--pqos_delete_flow", "--pqosd", NULL, NULL, mocacli_do_pqos_delete_flow_handler },
   {"--pqos_egress_numflows", NULL, mocacli_get_pqos_egress_numflows_handler, NULL, NULL },
   {"--pqos_list", "--pqosl", NULL, NULL, mocacli_do_pqos_list_handler },
   {"--pqos_max_packet_size", NULL, mocacli_get_pqos_max_packet_size_handler, mocacli_set_pqos_max_packet_size_handler, NULL },
   {"--pqos_query", "--pqosq", NULL, NULL, mocacli_do_pqos_query_handler },
   {"--pqos_status", "--pqoss", NULL, NULL, mocacli_do_pqos_status_handler },
   {"--pqos_update_flow", "--pqosu", NULL, NULL, mocacli_do_pqos_update_flow_handler },
   {"--preamble_uc_const", NULL, mocacli_get_preamble_uc_const_handler, mocacli_set_preamble_uc_const_handler, NULL },
   {"--preferred_nc", NULL, mocacli_get_preferred_nc_handler, mocacli_set_preferred_nc_handler, NULL },
   {"--primary_ch_offset", "--pco", mocacli_get_primary_ch_offset_handler, mocacli_set_primary_ch_offset_handler, NULL },
   {"--priority_allocations", NULL, mocacli_get_priority_allocations_handler, mocacli_set_priority_allocations_handler, NULL },
   {"--privacy_defaults", NULL, mocacli_get_privacy_defaults_handler, mocacli_set_privacy_defaults_handler, NULL },
   {"--privacy_en", NULL, mocacli_get_privacy_en_handler, mocacli_set_privacy_en_handler, NULL },
   {"--probe_request", NULL, NULL, mocacli_set_probe_request_handler, NULL },
   {"--prof_pad_ctrl_deg_6802c0_bonding", "--pad_ctrl_bonding", mocacli_get_prof_pad_ctrl_deg_6802c0_bonding_handler, mocacli_set_prof_pad_ctrl_deg_6802c0_bonding_handler, NULL },
   {"--prof_pad_ctrl_deg_6802c0_single", "--pad_ctrl_single", mocacli_get_prof_pad_ctrl_deg_6802c0_single_handler, mocacli_set_prof_pad_ctrl_deg_6802c0_single_handler, NULL },
   {"--prop_bonding_compatibility_mode", "--prop_bond_comp_mode", mocacli_get_prop_bonding_compatibility_mode_handler, mocacli_set_prop_bonding_compatibility_mode_handler, NULL },
   {"--ps_cmd", NULL, NULL, NULL, mocacli_do_ps_cmd_handler },
   {"--ps_swch_rx1", NULL, mocacli_get_ps_swch_rx1_handler, mocacli_set_ps_swch_rx1_handler, NULL },
   {"--ps_swch_rx2", NULL, mocacli_get_ps_swch_rx2_handler, mocacli_set_ps_swch_rx2_handler, NULL },
   {"--ps_swch_rx3", NULL, mocacli_get_ps_swch_rx3_handler, mocacli_set_ps_swch_rx3_handler, NULL },
   {"--ps_swch_tx1", NULL, mocacli_get_ps_swch_tx1_handler, mocacli_set_ps_swch_tx1_handler, NULL },
   {"--ps_swch_tx2", NULL, mocacli_get_ps_swch_tx2_handler, mocacli_set_ps_swch_tx2_handler, NULL },
   {"--psm_config", NULL, mocacli_get_psm_config_handler, mocacli_set_psm_config_handler, NULL },
   {"--qam256_capability", NULL, mocacli_get_qam256_capability_handler, mocacli_set_qam256_capability_handler, NULL },
   {"--rdeg_3450", NULL, mocacli_get_rdeg_3450_handler, mocacli_set_rdeg_3450_handler, NULL },
   {"--remote_man", NULL, mocacli_get_remote_man_handler, mocacli_set_remote_man_handler, NULL },
   {"--res1", NULL, mocacli_get_res1_handler, mocacli_set_res1_handler, NULL },
   {"--res10", NULL, mocacli_get_res10_handler, mocacli_set_res10_handler, NULL },
   {"--res11", NULL, mocacli_get_res11_handler, mocacli_set_res11_handler, NULL },
   {"--res12", NULL, mocacli_get_res12_handler, mocacli_set_res12_handler, NULL },
   {"--res13", NULL, mocacli_get_res13_handler, mocacli_set_res13_handler, NULL },
   {"--res14", NULL, mocacli_get_res14_handler, mocacli_set_res14_handler, NULL },
   {"--res15", NULL, mocacli_get_res15_handler, mocacli_set_res15_handler, NULL },
   {"--res16", NULL, mocacli_get_res16_handler, mocacli_set_res16_handler, NULL },
   {"--res17", NULL, mocacli_get_res17_handler, mocacli_set_res17_handler, NULL },
   {"--res18", NULL, mocacli_get_res18_handler, mocacli_set_res18_handler, NULL },
   {"--res19", NULL, mocacli_get_res19_handler, mocacli_set_res19_handler, NULL },
   {"--res2", NULL, mocacli_get_res2_handler, mocacli_set_res2_handler, NULL },
   {"--res20", NULL, mocacli_get_res20_handler, mocacli_set_res20_handler, NULL },
   {"--res3", NULL, mocacli_get_res3_handler, mocacli_set_res3_handler, NULL },
   {"--res4", NULL, mocacli_get_res4_handler, mocacli_set_res4_handler, NULL },
   {"--res5", NULL, mocacli_get_res5_handler, mocacli_set_res5_handler, NULL },
   {"--res6", NULL, mocacli_get_res6_handler, mocacli_set_res6_handler, NULL },
   {"--res7", NULL, mocacli_get_res7_handler, mocacli_set_res7_handler, NULL },
   {"--res8", NULL, mocacli_get_res8_handler, mocacli_set_res8_handler, NULL },
   {"--res9", NULL, mocacli_get_res9_handler, mocacli_set_res9_handler, NULL },
   {"--reset_stats", NULL, NULL, mocacli_set_reset_stats_handler, NULL },
   {"--restart", NULL, NULL, mocacli_set_restart_handler, NULL },
   {"--restore_defaults", NULL, NULL, mocacli_set_restore_defaults_handler, NULL },
   {"--rework_6802", "--rework", mocacli_get_rework_6802_handler, mocacli_set_rework_6802_handler, NULL },
   {"--rf_band", NULL, mocacli_get_rf_band_handler, mocacli_set_rf_band_handler, NULL },
   {"--rf_switch", NULL, mocacli_get_rf_switch_handler, mocacli_set_rf_switch_handler, NULL },
   {"--rlapm_cap_100", NULL, mocacli_get_rlapm_cap_100_handler, mocacli_set_rlapm_cap_100_handler, NULL },
   {"--rlapm_cap_50", NULL, mocacli_get_rlapm_cap_50_handler, mocacli_set_rlapm_cap_50_handler, NULL },
   {"--rlapm_en", NULL, mocacli_get_rlapm_en_handler, mocacli_set_rlapm_en_handler, NULL },
   {"--rlapm_table_100", NULL, mocacli_get_rlapm_table_100_handler, mocacli_set_rlapm_table_100_handler, NULL },
   {"--rlapm_table_50", NULL, mocacli_get_rlapm_table_50_handler, mocacli_set_rlapm_table_50_handler, NULL },
   {"--rtr_config", NULL, mocacli_get_rtr_config_handler, mocacli_set_rtr_config_handler, NULL },
   {"--rx_gain_agc_table", NULL, mocacli_get_rx_gain_agc_table_handler, NULL, NULL },
   {"--rx_gain_params", NULL, mocacli_get_rx_gain_params_handler, NULL, NULL },
   {"--rx_power_tune", NULL, mocacli_get_rx_power_tune_handler, mocacli_set_rx_power_tune_handler, NULL },
   {"--rx_tx_packets_per_qm", NULL, mocacli_get_rx_tx_packets_per_qm_handler, mocacli_set_rx_tx_packets_per_qm_handler, NULL },
   {"--rxd_lmo_request", NULL, NULL, mocacli_set_rxd_lmo_request_handler, NULL },
   {"--sapm_en", NULL, mocacli_get_sapm_en_handler, mocacli_set_sapm_en_handler, NULL },
   {"--sapm_table_100", NULL, mocacli_get_sapm_table_100_handler, mocacli_set_sapm_table_100_handler, NULL },
   {"--sapm_table_50", NULL, mocacli_get_sapm_table_50_handler, mocacli_set_sapm_table_50_handler, NULL },
   {"--sapm_table_sec", NULL, mocacli_get_sapm_table_sec_handler, mocacli_set_sapm_table_sec_handler, NULL },
   {"--secondary_ch_offset", "--sco", mocacli_get_secondary_ch_offset_handler, mocacli_set_secondary_ch_offset_handler, NULL },
   {"--selective_rr", NULL, mocacli_get_selective_rr_handler, mocacli_set_selective_rr_handler, NULL },
   {"--sigma2_prints", NULL, mocacli_get_sigma2_prints_handler, mocacli_set_sigma2_prints_handler, NULL },
   {"--single_channel_operation", "--schop", mocacli_get_single_channel_operation_handler, mocacli_set_single_channel_operation_handler, NULL },
   {"--snr_margin_ldpc", NULL, mocacli_get_snr_margin_ldpc_handler, mocacli_set_snr_margin_ldpc_handler, NULL },
   {"--snr_margin_ldpc_pre5", NULL, mocacli_get_snr_margin_ldpc_pre5_handler, mocacli_set_snr_margin_ldpc_pre5_handler, NULL },
   {"--snr_margin_ldpc_pri_ch", NULL, mocacli_get_snr_margin_ldpc_pri_ch_handler, mocacli_set_snr_margin_ldpc_pri_ch_handler, NULL },
   {"--snr_margin_ldpc_sec_ch", NULL, mocacli_get_snr_margin_ldpc_sec_ch_handler, mocacli_set_snr_margin_ldpc_sec_ch_handler, NULL },
   {"--snr_margin_ofdma", NULL, mocacli_get_snr_margin_ofdma_handler, mocacli_set_snr_margin_ofdma_handler, NULL },
   {"--snr_margin_pre5_pri_ch", NULL, mocacli_get_snr_margin_pre5_pri_ch_handler, mocacli_set_snr_margin_pre5_pri_ch_handler, NULL },
   {"--snr_margin_pre5_sec_ch", NULL, mocacli_get_snr_margin_pre5_sec_ch_handler, mocacli_set_snr_margin_pre5_sec_ch_handler, NULL },
   {"--snr_margin_rs", NULL, mocacli_get_snr_margin_rs_handler, mocacli_set_snr_margin_rs_handler, NULL },
   {"--snr_margin_table_ldpc", NULL, mocacli_get_snr_margin_table_ldpc_handler, mocacli_set_snr_margin_table_ldpc_handler, NULL },
   {"--snr_margin_table_ldpc_pre5", NULL, mocacli_get_snr_margin_table_ldpc_pre5_handler, mocacli_set_snr_margin_table_ldpc_pre5_handler, NULL },
   {"--snr_margin_table_ldpc_pri_ch", NULL, mocacli_get_snr_margin_table_ldpc_pri_ch_handler, mocacli_set_snr_margin_table_ldpc_pri_ch_handler, NULL },
   {"--snr_margin_table_ldpc_sec_ch", NULL, mocacli_get_snr_margin_table_ldpc_sec_ch_handler, mocacli_set_snr_margin_table_ldpc_sec_ch_handler, NULL },
   {"--snr_margin_table_ofdma", NULL, mocacli_get_snr_margin_table_ofdma_handler, mocacli_set_snr_margin_table_ofdma_handler, NULL },
   {"--snr_margin_table_pre5_pri_ch", NULL, mocacli_get_snr_margin_table_pre5_pri_ch_handler, mocacli_set_snr_margin_table_pre5_pri_ch_handler, NULL },
   {"--snr_margin_table_pre5_sec_ch", NULL, mocacli_get_snr_margin_table_pre5_sec_ch_handler, mocacli_set_snr_margin_table_pre5_sec_ch_handler, NULL },
   {"--snr_margin_table_rs", NULL, mocacli_get_snr_margin_table_rs_handler, mocacli_set_snr_margin_table_rs_handler, NULL },
   {"--snr_prints", NULL, mocacli_get_snr_prints_handler, mocacli_set_snr_prints_handler, NULL },
   {"--src_addr", NULL, mocacli_get_src_addr_handler, NULL, NULL },
   {"--stag_priority", NULL, mocacli_get_stag_priority_handler, mocacli_set_stag_priority_handler, NULL },
   {"--stag_removal", NULL, mocacli_get_stag_removal_handler, mocacli_set_stag_removal_handler, NULL },
   {"--standby_power_state", NULL, mocacli_get_standby_power_state_handler, mocacli_set_standby_power_state_handler, NULL },
   {"--star_topology_en", NULL, mocacli_get_star_topology_en_handler, mocacli_set_star_topology_en_handler, NULL },
   {"--start", NULL, NULL, mocacli_set_start_handler, NULL },
   {"--start_ulmo", NULL, mocacli_get_start_ulmo_handler, mocacli_set_start_ulmo_handler, NULL },
   {"--stop", NULL, NULL, mocacli_set_stop_handler, NULL },
   {"--taboo_channels", "--taboo", mocacli_get_taboo_channels_handler, mocacli_set_taboo_channels_handler, NULL },
   {"--target_phy_rate_20", NULL, mocacli_get_target_phy_rate_20_handler, mocacli_set_target_phy_rate_20_handler, NULL },
   {"--target_phy_rate_20_sec_ch", NULL, mocacli_get_target_phy_rate_20_sec_ch_handler, mocacli_set_target_phy_rate_20_sec_ch_handler, NULL },
   {"--target_phy_rate_20_turbo", NULL, mocacli_get_target_phy_rate_20_turbo_handler, mocacli_set_target_phy_rate_20_turbo_handler, NULL },
   {"--target_phy_rate_20_turbo_sec_ch", NULL, mocacli_get_target_phy_rate_20_turbo_sec_ch_handler, mocacli_set_target_phy_rate_20_turbo_sec_ch_handler, NULL },
   {"--target_phy_rate_20_turbo_vlper", NULL, mocacli_get_target_phy_rate_20_turbo_vlper_handler, mocacli_set_target_phy_rate_20_turbo_vlper_handler, NULL },
   {"--target_phy_rate_20_turbo_vlper_sec_ch", NULL, mocacli_get_target_phy_rate_20_turbo_vlper_sec_ch_handler, mocacli_set_target_phy_rate_20_turbo_vlper_sec_ch_handler, NULL },
   {"--target_phy_rate_qam128", NULL, mocacli_get_target_phy_rate_qam128_handler, mocacli_set_target_phy_rate_qam128_handler, NULL },
   {"--target_phy_rate_qam256", NULL, mocacli_get_target_phy_rate_qam256_handler, mocacli_set_target_phy_rate_qam256_handler, NULL },
   {"--tek_exchange_interval", NULL, mocacli_get_tek_exchange_interval_handler, mocacli_set_tek_exchange_interval_handler, NULL },
   {"--tlp_mode", NULL, mocacli_get_tlp_mode_handler, mocacli_set_tlp_mode_handler, NULL },
   {"--tpc_en", NULL, mocacli_get_tpc_en_handler, mocacli_set_tpc_en_handler, NULL },
   {"--tpcap_capture_time", NULL, mocacli_get_tpcap_capture_time_handler, NULL, NULL },
   {"--turbo_en", NULL, mocacli_get_turbo_en_handler, mocacli_set_turbo_en_handler, NULL },
   {"--tx_power_params", NULL, mocacli_get_tx_power_params_handler, NULL, NULL },
   {"--uc_fwd", NULL, mocacli_get_uc_fwd_handler, NULL, NULL },
   {"--use_ext_data_mem", NULL, mocacli_get_use_ext_data_mem_handler, mocacli_set_use_ext_data_mem_handler, NULL },
   {"--verbose", NULL, mocacli_get_verbose_handler, mocacli_set_verbose_handler, NULL },
   {"--wakeup_node", NULL, NULL, NULL, mocacli_do_wakeup_node_handler },
   {"--wdog_enable", NULL, mocacli_get_wdog_enable_handler, mocacli_set_wdog_enable_handler, NULL },
   {"--wom_ip", NULL, mocacli_get_wom_ip_handler, mocacli_set_wom_ip_handler, NULL },
   {"--wom_magic_enable", NULL, mocacli_get_wom_magic_enable_handler, mocacli_set_wom_magic_enable_handler, NULL },
   {"--wom_magic_mac", NULL, mocacli_get_wom_magic_mac_handler, mocacli_set_wom_magic_mac_handler, NULL },
   {"--wom_mode", NULL, mocacli_get_wom_mode_handler, mocacli_set_wom_mode_handler, NULL },
   {"--wom_pattern", NULL, mocacli_get_wom_pattern_handler, mocacli_set_wom_pattern_handler, NULL },
};

MOCALIB_CLI_HELP static int mocacli_print_help( void )
{
   fprintf( stderr,
"\n"
      "get\n"
      "   "  "--adc_mode " "--adm_stats " "--aes_exchange_interval " "--aes_mm_key " "--aes_pm_key ""\n"
      "   "  "--aes_pmk_initial_key " "--aif_mode " "--amp_reg " "--amp_type " "--arpl_th_100 ""\n"
      "   "  "--arpl_th_50 " "--assertText " "--bad_probe_prints " "--beacon_pwr_reduction ""\n"
      "   "  "--beacon_pwr_reduction_en " "--bo_mode " "--bonding " "--brcmtag_enable " "--bw ""\n"
      "   "  "--c4_moca20_en " "--cap_phy_rate_en " "--cap_snr_base_margin " "--cap_target_phy_rate ""\n"
      "   "  "--cir_prints " "--config " "--continuous_rx_mode_attn " "--ctx " "--ctxparms ""\n"
      "   "  "--dont_start_moca " "--drv_info " "--egr_mc_filter_en " "--en_capable " "--error_to_mask ""\n"
      "   "  "--errors " "--extra_rx_packets_per_qm " "--fc_mode " "--filter_m2_data_wakeUp ""\n"
      "   "  "--freq_mask " "--freq_shift " "--fw_version " "--group " "--groupall " "--host_pool ""\n"
      "   "  "--host_qos " "--if_access_en " "--if_access_table " "--impedance_mode_bonding " "--init ""\n"
      "   "  "--keys " "--lab_mode " "--lab_register " "--last_mr_events " "--last_ps_event_code ""\n"
      "   "  "--led_mode " "--led_status " "--limit_traffic " "--link " "--listening_duration " "--lof ""\n"
      "   "  "--lof_update " "--loopback_en " "--m1_tx_power_variation " "--mac_addr " "--mac_aging ""\n"
      "   "  "--max_constellation " "--max_constellation_all " "--max_frame_size " "--max_phy_rate ""\n"
      "   "  "--max_phy_rate_50M " "--max_phy_rate_turbo " "--max_pkt_aggr " "--max_pkt_aggr_bonding ""\n"
      "   "  "--max_transmit_time " "--max_tx_power " "--max_tx_power_tune ""\n"
      "   "  "--max_tx_power_tune_sec_ch " "--mcfilter_enable " "--mcfilter_table ""\n"
      "   "  "--min_bw_alarm_threshold " "--mmk_key " "--mocad_version " "--mps_en ""\n"
      "   "  "--mps_init_scan_payload " "--mps_privacy_down " "--mps_privacy_receive " "--mps_state ""\n"
      "   "  "--mps_unpaired_time " "--mps_walk_time " "--mr_seq_num " "--mtm_en " "--multicast_mode ""\n"
      "   "  "--nc_heartbeat_interval " "--nc_listening_interval " "--nc_mode " "--net ""\n"
      "   "  "--node_power_state " "--node_stats " "--node_stats_ext " "--node_status " "--nodeinfo ""\n"
      "   "  "--nodephy " "--nv_cal_enable " "--nvram " "--ofdma_assignment_table ""\n"
      "   "  "--ofdma_definition_table " "--ofdma_en " "--orr_en " "--otf_en " "--password " "--pause_fc_en ""\n"
      "   "  "--pco " "--per_mode " "--permanent_salt " "--phy_clock " "--phy_status ""\n"
      "   "  "--pm_restore_on_link_down " "--pmk_exchange_interval " "--pmk_initial_key ""\n"
      "   "  "--policing_en " "--power_state " "--power_state_capabilities " "--pqos_egress_numflows ""\n"
      "   "  "--pqos_max_packet_size " "--preferred_nc " "--privacy_defaults " "--privacy_en ""\n"
      "   "  "--prop_bond_comp_mode " "--psm_config " "--psm_dis " "--qam256_capability " "--rdeg_3450 ""\n"
      "   "  "--remote_man " "--rework " "--rf_band " "--rlapm_cap_100 " "--rlapm_cap_50 " "--rlapm_en ""\n"
      "   "  "--rlapm_table_100 " "--rlapm_table_50 " "--rtr_config " "--rx_gain_params ""\n"
      "   "  "--rx_power_tune " "--rx_tx_packets_per_qm " "--sapm_en " "--sapm_table_100 ""\n"
      "   "  "--sapm_table_50 " "--sapm_table_sec " "--schop " "--sco " "--selective_rr " "--sigma2_prints ""\n"
      "   "  "--snr_margin_ldpc " "--snr_margin_ldpc_pre5 " "--snr_margin_ldpc_pri_ch ""\n"
      "   "  "--snr_margin_ldpc_sec_ch " "--snr_margin_ofdma " "--snr_margin_pre5_pri_ch ""\n"
      "   "  "--snr_margin_pre5_sec_ch " "--snr_margin_rs " "--snr_prints " "--src_addr ""\n"
      "   "  "--stag_priority " "--stag_removal " "--standby_power_state " "--star_topology_en ""\n"
      "   "  "--start_ulmo " "--stats " "--taboo " "--target_phy_rate_20 " "--target_phy_rate_20_sec_ch ""\n"
      "   "  "--target_phy_rate_20_turbo " "--target_phy_rate_20_turbo_sec_ch ""\n"
      "   "  "--target_phy_rate_20_turbo_vlper " "--target_phy_rate_20_turbo_vlper_sec_ch ""\n"
      "   "  "--target_phy_rate_qam128 " "--target_phy_rate_qam256 " "--tek_exchange_interval ""\n"
      "   "  "--tlp_mode " "--tpc_en " "--tpcap_capture_time " "--trace " "--turbo_en " "--tx_power_params ""\n"
      "   "  "--uc_fwd " "--use_ext_data_mem " "--verbose " "--wdog_enable " "--wom_ip ""\n"
      "   "  "--wom_magic_enable " "--wom_magic_mac " "--wom_mode " "--wom_pattern ""\n"
      "set\n"
      "   "  "--adc_mode " "--aes_exchange_interval " "--aes_mm_key " "--aes_pm_key ""\n"
      "   "  "--aes_pmk_initial_key " "--aif_mode " "--amp_reg " "--amp_type " "--arpl_th_100 ""\n"
      "   "  "--arpl_th_50 " "--assertText " "--bad_probe_prints " "--beacon_channel_set ""\n"
      "   "  "--beacon_pwr_reduction " "--beacon_pwr_reduction_en " "--bo_mode " "--bonding ""\n"
      "   "  "--brcmtag_enable " "--bw " "--c4_moca20_en " "--cap_phy_rate_en " "--cap_snr_base_margin ""\n"
      "   "  "--cap_target_phy_rate " "--cir_prints " "--cof " "--continuous_rx_mode_attn " "--ctx ""\n"
      "   "  "--ctxparms " "--dont_start_moca " "--egr_mc_addr_filter " "--egr_mc_filter_en ""\n"
      "   "  "--en_capable " "--error_to_mask " "--extra_rx_packets_per_qm " "--fc_mode ""\n"
      "   "  "--filter_m2_data_wakeUp " "--force_handoff " "--freq_mask " "--freq_shift ""\n"
      "   "  "--gmii_trap_header " "--host_qos " "--if_access_en " "--if_access_table ""\n"
      "   "  "--impedance_mode_bonding " "--lab_iq_diagram_set " "--lab_mode " "--lab_register ""\n"
      "   "  "--led_mode " "--limit_traffic " "--listening_duration " "--lof " "--lof_update ""\n"
      "   "  "--loopback_en " "--m1_tx_power_variation " "--mac_addr " "--mac_aging ""\n"
      "   "  "--max_constellation " "--max_constellation_all " "--max_frame_size " "--max_phy_rate ""\n"
      "   "  "--max_phy_rate_50M " "--max_phy_rate_turbo " "--max_pkt_aggr " "--max_pkt_aggr_bonding ""\n"
      "   "  "--max_transmit_time " "--max_tx_power " "--max_tx_power_tune ""\n"
      "   "  "--max_tx_power_tune_sec_ch " "--mcfilter_addentry " "--mcfilter_clear_table ""\n"
      "   "  "--mcfilter_delentry " "--mcfilter_enable " "--min_bw_alarm_threshold ""\n"
      "   "  "--mocad_forwarding_rx_mac " "--mps_button_press " "--mps_en " "--mps_privacy_down ""\n"
      "   "  "--mps_privacy_receive " "--mps_reset " "--mps_unpaired_time " "--mps_walk_time ""\n"
      "   "  "--mr_seq_num " "--mtm_en " "--multicast_mode " "--nc_heartbeat_interval ""\n"
      "   "  "--nc_listening_interval " "--nc_mode " "--no_rtt " "--nv_cal_clear " "--nv_cal_enable ""\n"
      "   "  "--ofdma_en " "--ooo_lmo " "--orr_en " "--otf_en " "--password " "--pause_fc_en " "--pco ""\n"
      "   "  "--per_mode " "--phy_clock " "--pm_restore_on_link_down " "--pmk_exchange_interval ""\n"
      "   "  "--policing_en " "--pqos_max_packet_size " "--preferred_nc " "--privacy_defaults ""\n"
      "   "  "--privacy_en " "--prop_bond_comp_mode " "--psm_config " "--psm_dis " "--qam256_capability ""\n"
      "   "  "--rdeg_3450 " "--remote_man " "--reset_stats " "--restart " "--restore_defaults " "--rework ""\n"
      "   "  "--rf_band " "--rlapm_cap_100 " "--rlapm_cap_50 " "--rlapm_en " "--rlapm_table_100 ""\n"
      "   "  "--rlapm_table_50 " "--rtr_config " "--rx_power_tune " "--rx_tx_packets_per_qm ""\n"
      "   "  "--rxd_lmo_request " "--sapm_en " "--sapm_table_100 " "--sapm_table_50 " "--sapm_table_sec ""\n"
      "   "  "--schop " "--sco " "--selective_rr " "--sigma2_prints " "--snr_margin_ldpc ""\n"
      "   "  "--snr_margin_ldpc_pre5 " "--snr_margin_ldpc_pri_ch " "--snr_margin_ldpc_sec_ch ""\n"
      "   "  "--snr_margin_ofdma " "--snr_margin_pre5_pri_ch " "--snr_margin_pre5_sec_ch ""\n"
      "   "  "--snr_margin_rs " "--snr_prints " "--stag_priority " "--stag_removal ""\n"
      "   "  "--standby_power_state " "--star_topology_en " "--start " "--start_ulmo " "--stop " "--taboo ""\n"
      "   "  "--target_phy_rate_20 " "--target_phy_rate_20_sec_ch " "--target_phy_rate_20_turbo ""\n"
      "   "  "--target_phy_rate_20_turbo_sec_ch " "--target_phy_rate_20_turbo_vlper ""\n"
      "   "  "--target_phy_rate_20_turbo_vlper_sec_ch " "--target_phy_rate_qam128 ""\n"
      "   "  "--target_phy_rate_qam256 " "--tek_exchange_interval " "--tlp_mode " "--tpc_en " "--trace ""\n"
      "   "  "--turbo_en " "--use_ext_data_mem " "--verbose " "--wdog_enable " "--wom_ip ""\n"
      "   "  "--wom_magic_enable " "--wom_magic_mac " "--wom_mode " "--wom_pattern ""\n"
      "do\n"
      "   "  "--aca " "--dd " "--fmr_20 " "--fmr_init " "--hostless_mode " "--mocad_printf " "--mr " "--pqosc ""\n"
      "   "  "--pqosd " "--pqosl " "--pqosq " "--pqoss " "--pqosu " "--ps_cmd " "--wakeup_node ""\n"
   );

   return(0);
}

MOCALIB_CLI_HELP static int mocacli_print_pvt_help( void )
{
   fprintf( stderr,
"\n"
      "get\n"
      "   "  "--ac_cc_shift " "--agc_const_address " "--agc_const_en " "--assert_restart ""\n"
      "   "  "--block_nack_rate " "--cir_data " "--const_rx_submode " "--cp_const ""\n"
      "   "  "--cp_margin_increase " "--fragmentation " "--ifg_moca20 " "--init1 " "--init2 " "--init3 ""\n"
      "   "  "--init4 " "--init5 " "--init6 " "--init7 " "--init8 " "--init9 " "--lab_cmd " "--lab_snr_graph_set ""\n"
      "   "  "--low_pri_q_num " "--map_capture " "--map_seed " "--max_nbas_pri_ch " "--max_nbas_sec_ch ""\n"
      "   "  "--mfc_th_increase " "--min_bo_insert_2_bfm_lock " "--min_snr_avg_db_2_bfm_lock ""\n"
      "   "  "--moca_cpu_freq " "--ooo_lmo_threshold " "--pad_ctrl_bonding " "--pad_ctrl_single ""\n"
      "   "  "--preamble_uc_const " "--priority_allocations " "--ps_swch_rx1 " "--ps_swch_rx2 ""\n"
      "   "  "--ps_swch_rx3 " "--ps_swch_tx1 " "--ps_swch_tx2 " "--res1 " "--res10 " "--res11 " "--res12 ""\n"
      "   "  "--res13 " "--res14 " "--res15 " "--res16 " "--res17 " "--res18 " "--res19 " "--res2 " "--res20 " "--res3 ""\n"
      "   "  "--res4 " "--res5 " "--res6 " "--res7 " "--res8 " "--res9 " "--rf_switch " "--rx_gain_agc_table ""\n"
      "   "  "--snr_margin_table_ldpc " "--snr_margin_table_ldpc_pre5 ""\n"
      "   "  "--snr_margin_table_ldpc_pri_ch " "--snr_margin_table_ldpc_sec_ch ""\n"
      "   "  "--snr_margin_table_ofdma " "--snr_margin_table_pre5_pri_ch ""\n"
      "   "  "--snr_margin_table_pre5_sec_ch " "--snr_margin_table_rs ""\n"
      "set\n"
      "   "  "--ac_cc_shift " "--agc_const_address " "--agc_const_en " "--assert_restart ""\n"
      "   "  "--block_nack_rate " "--const_rx_submode " "--cp_const " "--cp_margin_increase ""\n"
      "   "  "--cplength " "--fragmentation " "--ifg_moca20 " "--init1 " "--init2 " "--init3 " "--init4 ""\n"
      "   "  "--init5 " "--init6 " "--init7 " "--init8 " "--init9 " "--lab_cmd " "--lab_snr_graph_set ""\n"
      "   "  "--low_pri_q_num " "--map_capture " "--map_seed " "--max_nbas_pri_ch " "--max_nbas_sec_ch ""\n"
      "   "  "--mfc_th_increase " "--min_bo_insert_2_bfm_lock " "--min_snr_avg_db_2_bfm_lock ""\n"
      "   "  "--moca_cpu_freq " "--ooo_lmo_threshold " "--pad_ctrl_bonding " "--pad_ctrl_single ""\n"
      "   "  "--preamble_uc_const " "--priority_allocations " "--probe_request " "--ps_swch_rx1 ""\n"
      "   "  "--ps_swch_rx2 " "--ps_swch_rx3 " "--ps_swch_tx1 " "--ps_swch_tx2 " "--res1 " "--res10 " "--res11 ""\n"
      "   "  "--res12 " "--res13 " "--res14 " "--res15 " "--res16 " "--res17 " "--res18 " "--res19 " "--res2 " "--res20 ""\n"
      "   "  "--res3 " "--res4 " "--res5 " "--res6 " "--res7 " "--res8 " "--res9 " "--rf_switch ""\n"
      "   "  "--snr_margin_table_ldpc " "--snr_margin_table_ldpc_pre5 ""\n"
      "   "  "--snr_margin_table_ldpc_pri_ch " "--snr_margin_table_ldpc_sec_ch ""\n"
      "   "  "--snr_margin_table_ofdma " "--snr_margin_table_pre5_pri_ch ""\n"
      "   "  "--snr_margin_table_pre5_sec_ch " "--snr_margin_table_rs ""\n"
      "do\n"
"\n"
   );

   return(0);
}

static COMMAND_INFO g_Cmds[] =
{
   {"get", { "--ac_cc_shift", "--adc_mode", "--adm_stats", "--aes_exchange_interval", "--aes_mm_key", "--aes_pm_key", "--aes_pmk_initial_key", "--agc_const_address", "--agc_const_en", "--aif_mode", "--amp_reg", "--amp_type", "--arpl_th_100", "--arpl_th_50", "--assertText", "--assert_restart", "--bad_probe_prints", "--bandwidth", "--beacon_pwr_reduction", "--beacon_pwr_reduction_en", "--block_nack_rate", "--bo_mode", "--bonding", "--brcmtag_enable", "--c4_moca20_en", "--cap_phy_rate_en", "--cap_snr_base_margin", "--cap_target_phy_rate", "--cir_data", "--cir_prints", "--config", "--const_rx_submode", "--const_tx_params", "--continuous_power_tx_mode", "--continuous_rx_mode_attn", "--cp_const", "--cp_margin_increase", "--current_keys", "--dont_start_moca", "--drv_info", "--egr_mc_filter_en", "--en_capable", "--error_stats", "--error_to_mask", "--extra_rx_packets_per_qm", "--fc_mode", "--filter_m2_data_wakeUp", "--fragmentation", "--freq_shift", "--fw_version", "--gen_node_ext_status", "--gen_node_status", "--gen_stats", "--group", "--groupall", "--host_pool", "--host_qos", "--if_access_en", "--if_access_table", "--ifg_moca20", "--impedance_mode_bonding", "--init", "--init1", "--init2", "--init3", "--init4", "--init5", "--init6", "--init7", "--init8", "--init9", "--interface_status", "--lab_cmd", "--lab_mode", "--lab_register", "--lab_snr_graph_set", "--last_mr_events", "--last_ps_event_code", "--led_mode", "--led_status", "--limit_traffic", "--listening_duration", "--listening_freq_mask", "--lof", "--lof_update", "--loopback_en", "--low_pri_q_num", "--m1_tx_power_variation", "--mac_addr", "--mac_aging", "--map_capture", "--map_seed", "--max_constellation", "--max_constellation_all", "--max_frame_size", "--max_nbas_primary", "--max_nbas_secondary", "--max_phy_rate", "--max_phy_rate_50M", "--max_phy_rate_turbo", "--max_pkt_aggr", "--max_pkt_aggr_bonding", "--max_transmit_time", "--max_tx_power", "--max_tx_power_tune", "--max_tx_power_tune_sec_ch", "--mcfilter_enable", "--mcfilter_table", "--mfc_th_increase", "--min_bo_insert_2_bfm_lock", "--min_bw_alarm_threshold", "--min_snr_avg_db_2_bfm_lock", "--mmk_key", "--moca_core_trace_enable", "--moca_cpu_freq", "--mocad_version", "--mps_en", "--mps_init_scan_payload", "--mps_privacy_down", "--mps_privacy_receive", "--mps_state", "--mps_unpaired_time", "--mps_walk_time", "--mr_seq_num", "--mtm_en", "--multicast_mode", "--nc_heartbeat_interval", "--nc_listening_interval", "--nc_mode", "--network_status", "--node_power_state", "--node_stats", "--node_stats_ext", "--node_status", "--nv_cal_enable", "--nvram", "--ofdma_assignment_table", "--ofdma_definition_table", "--ofdma_en", "--ooo_lmo_threshold", "--orr_en", "--otf_en", "--password", "--pause_fc_en", "--per_mode", "--permanent_salt", "--phy_clock", "--phy_status", "--pm_restore_on_link_down", "--pmk_exchange_interval", "--pmk_initial_key", "--policing_en", "--power_save_mechanism_dis", "--power_state", "--power_state_capabilities", "--pqos_egress_numflows", "--pqos_max_packet_size", "--preamble_uc_const", "--preferred_nc", "--primary_ch_offset", "--priority_allocations", "--privacy_defaults", "--privacy_en", "--prof_pad_ctrl_deg_6802c0_bonding", "--prof_pad_ctrl_deg_6802c0_single", "--prop_bonding_compatibility_mode", "--ps_swch_rx1", "--ps_swch_rx2", "--ps_swch_rx3", "--ps_swch_tx1", "--ps_swch_tx2", "--psm_config", "--qam256_capability", "--rdeg_3450", "--remote_man", "--res1", "--res10", "--res11", "--res12", "--res13", "--res14", "--res15", "--res16", "--res17", "--res18", "--res19", "--res2", "--res20", "--res3", "--res4", "--res5", "--res6", "--res7", "--res8", "--res9", "--rework_6802", "--rf_band", "--rf_switch", "--rlapm_cap_100", "--rlapm_cap_50", "--rlapm_en", "--rlapm_table_100", "--rlapm_table_50", "--rtr_config", "--rx_gain_agc_table", "--rx_gain_params", "--rx_power_tune", "--rx_tx_packets_per_qm", "--sapm_en", "--sapm_table_100", "--sapm_table_50", "--sapm_table_sec", "--secondary_ch_offset", "--selective_rr", "--sigma2_prints", "--single_channel_operation", "--snr_margin_ldpc", "--snr_margin_ldpc_pre5", "--snr_margin_ldpc_pri_ch", "--snr_margin_ldpc_sec_ch", "--snr_margin_ofdma", "--snr_margin_pre5_pri_ch", "--snr_margin_pre5_sec_ch", "--snr_margin_rs", "--snr_margin_table_ldpc", "--snr_margin_table_ldpc_pre5", "--snr_margin_table_ldpc_pri_ch", "--snr_margin_table_ldpc_sec_ch", "--snr_margin_table_ofdma", "--snr_margin_table_pre5_pri_ch", "--snr_margin_table_pre5_sec_ch", "--snr_margin_table_rs", "--snr_prints", "--src_addr", "--stag_priority", "--stag_removal", "--standby_power_state", "--star_topology_en", "--start_ulmo", "--taboo_channels", "--target_phy_rate_20", "--target_phy_rate_20_sec_ch", "--target_phy_rate_20_turbo", "--target_phy_rate_20_turbo_sec_ch", "--target_phy_rate_20_turbo_vlper", "--target_phy_rate_20_turbo_vlper_sec_ch", "--target_phy_rate_qam128", "--target_phy_rate_qam256", "--tek_exchange_interval", "--tlp_mode", "--tpc_en", "--tpcap_capture_time", "--turbo_en", "--tx_power_params", "--uc_fwd", "--use_ext_data_mem", "--verbose", "--wdog_enable", "--wom_ip", "--wom_magic_enable", "--wom_magic_mac", "--wom_mode", "--wom_pattern"}, mocacli_get_handler},
   {"set", { "--ac_cc_shift", "--adc_mode", "--aes_exchange_interval", "--aes_mm_key", "--aes_pm_key", "--aes_pmk_initial_key", "--agc_const_address", "--agc_const_en", "--aif_mode", "--amp_reg", "--amp_type", "--arpl_th_100", "--arpl_th_50", "--assertText", "--assert_restart", "--bad_probe_prints", "--bandwidth", "--beacon_channel_set", "--beacon_pwr_reduction", "--beacon_pwr_reduction_en", "--block_nack_rate", "--bo_mode", "--bonding", "--brcmtag_enable", "--c4_moca20_en", "--cap_phy_rate_en", "--cap_snr_base_margin", "--cap_target_phy_rate", "--cir_prints", "--cof", "--const_rx_submode", "--const_tx_params", "--continuous_power_tx_mode", "--continuous_rx_mode_attn", "--cp_const", "--cp_margin_increase", "--cplength", "--dont_start_moca", "--egr_mc_addr_filter", "--egr_mc_filter_en", "--en_capable", "--error_to_mask", "--extra_rx_packets_per_qm", "--fc_mode", "--filter_m2_data_wakeUp", "--force_handoff", "--fragmentation", "--freq_shift", "--gmii_trap_header", "--host_qos", "--if_access_en", "--if_access_table", "--ifg_moca20", "--impedance_mode_bonding", "--init1", "--init2", "--init3", "--init4", "--init5", "--init6", "--init7", "--init8", "--init9", "--lab_cmd", "--lab_iq_diagram_set", "--lab_mode", "--lab_register", "--lab_snr_graph_set", "--led_mode", "--limit_traffic", "--listening_duration", "--listening_freq_mask", "--lof", "--lof_update", "--loopback_en", "--low_pri_q_num", "--m1_tx_power_variation", "--mac_addr", "--mac_aging", "--map_capture", "--map_seed", "--max_constellation", "--max_constellation_all", "--max_frame_size", "--max_nbas_primary", "--max_nbas_secondary", "--max_phy_rate", "--max_phy_rate_50M", "--max_phy_rate_turbo", "--max_pkt_aggr", "--max_pkt_aggr_bonding", "--max_transmit_time", "--max_tx_power", "--max_tx_power_tune", "--max_tx_power_tune_sec_ch", "--mcfilter_addentry", "--mcfilter_clear_table", "--mcfilter_delentry", "--mcfilter_enable", "--mfc_th_increase", "--min_bo_insert_2_bfm_lock", "--min_bw_alarm_threshold", "--min_snr_avg_db_2_bfm_lock", "--moca_core_trace_enable", "--moca_cpu_freq", "--mocad_forwarding_rx_mac", "--mps_button_press", "--mps_en", "--mps_privacy_down", "--mps_privacy_receive", "--mps_reset", "--mps_unpaired_time", "--mps_walk_time", "--mr_seq_num", "--mtm_en", "--multicast_mode", "--nc_heartbeat_interval", "--nc_listening_interval", "--nc_mode", "--no_rtt", "--nv_cal_clear", "--nv_cal_enable", "--ofdma_en", "--ooo_lmo", "--ooo_lmo_threshold", "--orr_en", "--otf_en", "--password", "--pause_fc_en", "--per_mode", "--phy_clock", "--pm_restore_on_link_down", "--pmk_exchange_interval", "--policing_en", "--power_save_mechanism_dis", "--pqos_max_packet_size", "--preamble_uc_const", "--preferred_nc", "--primary_ch_offset", "--priority_allocations", "--privacy_defaults", "--privacy_en", "--probe_request", "--prof_pad_ctrl_deg_6802c0_bonding", "--prof_pad_ctrl_deg_6802c0_single", "--prop_bonding_compatibility_mode", "--ps_swch_rx1", "--ps_swch_rx2", "--ps_swch_rx3", "--ps_swch_tx1", "--ps_swch_tx2", "--psm_config", "--qam256_capability", "--rdeg_3450", "--remote_man", "--res1", "--res10", "--res11", "--res12", "--res13", "--res14", "--res15", "--res16", "--res17", "--res18", "--res19", "--res2", "--res20", "--res3", "--res4", "--res5", "--res6", "--res7", "--res8", "--res9", "--reset_stats", "--restart", "--restore_defaults", "--rework_6802", "--rf_band", "--rf_switch", "--rlapm_cap_100", "--rlapm_cap_50", "--rlapm_en", "--rlapm_table_100", "--rlapm_table_50", "--rtr_config", "--rx_power_tune", "--rx_tx_packets_per_qm", "--rxd_lmo_request", "--sapm_en", "--sapm_table_100", "--sapm_table_50", "--sapm_table_sec", "--secondary_ch_offset", "--selective_rr", "--sigma2_prints", "--single_channel_operation", "--snr_margin_ldpc", "--snr_margin_ldpc_pre5", "--snr_margin_ldpc_pri_ch", "--snr_margin_ldpc_sec_ch", "--snr_margin_ofdma", "--snr_margin_pre5_pri_ch", "--snr_margin_pre5_sec_ch", "--snr_margin_rs", "--snr_margin_table_ldpc", "--snr_margin_table_ldpc_pre5", "--snr_margin_table_ldpc_pri_ch", "--snr_margin_table_ldpc_sec_ch", "--snr_margin_table_ofdma", "--snr_margin_table_pre5_pri_ch", "--snr_margin_table_pre5_sec_ch", "--snr_margin_table_rs", "--snr_prints", "--stag_priority", "--stag_removal", "--standby_power_state", "--star_topology_en", "--start", "--start_ulmo", "--stop", "--taboo_channels", "--target_phy_rate_20", "--target_phy_rate_20_sec_ch", "--target_phy_rate_20_turbo", "--target_phy_rate_20_turbo_sec_ch", "--target_phy_rate_20_turbo_vlper", "--target_phy_rate_20_turbo_vlper_sec_ch", "--target_phy_rate_qam128", "--target_phy_rate_qam256", "--tek_exchange_interval", "--tlp_mode", "--tpc_en", "--turbo_en", "--use_ext_data_mem", "--verbose", "--wdog_enable", "--wom_ip", "--wom_magic_enable", "--wom_magic_mac", "--wom_mode", "--wom_pattern"}, mocacli_set_handler},
   {"do", { "--aca", "--dd_init", "--fmr_20", "--fmr_init", "--hostless_mode", "--moca_reset", "--mocad_printf", "--pqos_create_flow", "--pqos_delete_flow", "--pqos_list", "--pqos_query", "--pqos_status", "--pqos_update_flow", "--ps_cmd", "--wakeup_node"}, mocacli_do_handler},
   {"--help", {""}, HelpHandler},
};

